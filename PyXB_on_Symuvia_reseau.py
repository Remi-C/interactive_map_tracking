# ./reseau.py
# -*- coding: utf-8 -*-
# PyXB bindings for NM:e92452c8d3e28a9e27abfc9994d2007779e7f4c9
# Generated 2015-04-24 17:52:11.865277 by PyXB version 1.2.4 using Python 2.7.6.final.0
# Namespace AbsentNamespace0

from __future__ import unicode_literals
import io

import pyxb
import pyxb.binding
import pyxb.binding.saxer
import pyxb.utils.utility
import pyxb.utils.domutils
import pyxb.utils.six as _six


# Unique identifier for bindings created at the same time
_GenerationUID = pyxb.utils.utility.UniqueIdentifier('urn:uuid:de80b2c4-ea99-11e4-9e7b-60a44c5c87bf')

# Version of PyXB used to generate the bindings
_PyXBVersion = '1.2.4'
# Generated bindings are not compatible across PyXB versions
if pyxb.__version__ != _PyXBVersion:
    raise pyxb.PyXBVersionError(_PyXBVersion)

# Import bindings for namespaces imported into schema
import pyxb.binding.datatypes

# NOTE: All namespace declarations are reserved within the binding
Namespace = pyxb.namespace.CreateAbsentNamespace()
Namespace.configureCategories(['typeBinding', 'elementBinding'])


def CreateFromDocument(xml_text, default_namespace=None, location_base=None):
    """Parse the given XML and use the document element to create a
    Python instance.

    @param xml_text An XML document.  This should be data (Python 2
    str or Python 3 bytes), or a text (Python 2 unicode or Python 3
    str) in the L{pyxb._InputEncoding} encoding.

    @keyword default_namespace The L{pyxb.Namespace} instance to use as the
    default namespace where there is no default namespace in scope.
    If unspecified or C{None}, the namespace of the module containing
    this function will be used.

    @keyword location_base: An object to be recorded as the base of all
    L{pyxb.utils.utility.Location} instances associated with events and
    objects handled by the parser.  You might pass the URI from which
    the document was obtained.
    """

    if pyxb.XMLStyle_saxer != pyxb._XMLStyle:
        dom = pyxb.utils.domutils.StringToDOM(xml_text)
        return CreateFromDOM(dom.documentElement, default_namespace=default_namespace)
    if default_namespace is None:
        default_namespace = Namespace.fallbackNamespace()
    saxer = pyxb.binding.saxer.make_parser(fallback_namespace=default_namespace, location_base=location_base)
    handler = saxer.getContentHandler()
    xmld = xml_text
    if isinstance(xmld, _six.text_type):
        xmld = xmld.encode(pyxb._InputEncoding)
    saxer.parse(io.BytesIO(xmld))
    instance = handler.rootObject()
    return instance


def CreateFromDOM(node, default_namespace=None):
    """Create a Python instance from the given DOM node.
    The node tag must correspond to an element declaration in this module.

    @deprecated: Forcing use of DOM interface is unnecessary; use L{CreateFromDocument}."""
    if default_namespace is None:
        default_namespace = Namespace.fallbackNamespace()
    return pyxb.binding.basis.element.AnyCreateFromDOM(node, default_namespace)


# Atomic simple type: typeFloatStrictPositif
class typeFloatStrictPositif(pyxb.binding.datatypes.float):
    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeFloatStrictPositif')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 5,
                                               2)
    _Documentation = None


typeFloatStrictPositif._CF_minExclusive = pyxb.binding.facets.CF_minExclusive(
    value_datatype=pyxb.binding.datatypes.float, value=pyxb.binding.datatypes.anySimpleType('0'))
typeFloatStrictPositif._InitializeFacetMap(typeFloatStrictPositif._CF_minExclusive)
Namespace.addCategoryObject('typeBinding', 'typeFloatStrictPositif', typeFloatStrictPositif)

# Atomic simple type: typeFloatPositif
class typeFloatPositif(pyxb.binding.datatypes.float):
    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeFloatPositif')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               10, 2)
    _Documentation = None


typeFloatPositif._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=typeFloatPositif,
                                                                        value=pyxb.binding.datatypes.float(0.0))
typeFloatPositif._InitializeFacetMap(typeFloatPositif._CF_minInclusive)
Namespace.addCategoryObject('typeBinding', 'typeFloatPositif', typeFloatPositif)

# Atomic simple type: typeFloatNegatif
class typeFloatNegatif(pyxb.binding.datatypes.float):
    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeFloatNegatif')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               15, 2)
    _Documentation = None


typeFloatNegatif._CF_maxInclusive = pyxb.binding.facets.CF_maxInclusive(value_datatype=typeFloatNegatif,
                                                                        value=pyxb.binding.datatypes.float(0.0))
typeFloatNegatif._InitializeFacetMap(typeFloatNegatif._CF_maxInclusive)
Namespace.addCategoryObject('typeBinding', 'typeFloatNegatif', typeFloatNegatif)

# Atomic simple type: typeFloat01
class typeFloat01(pyxb.binding.datatypes.float):
    """RÃ©el compris entre 0 et 1"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeFloat01')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               20, 2)
    _Documentation = 'R\xe9el compris entre 0 et 1'


typeFloat01._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=typeFloat01,
                                                                   value=pyxb.binding.datatypes.float(0.0))
typeFloat01._CF_maxInclusive = pyxb.binding.facets.CF_maxInclusive(value_datatype=typeFloat01,
                                                                   value=pyxb.binding.datatypes.float(1.0))
typeFloat01._InitializeFacetMap(typeFloat01._CF_minInclusive,
                                typeFloat01._CF_maxInclusive)
Namespace.addCategoryObject('typeBinding', 'typeFloat01', typeFloat01)

# Atomic simple type: typeIntStrictPositif
class typeIntStrictPositif(pyxb.binding.datatypes.positiveInteger):
    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeIntStrictPositif')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               29, 2)
    _Documentation = None


typeIntStrictPositif._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=typeIntStrictPositif,
                                                                            value=pyxb.binding.datatypes.positiveInteger(
                                                                                1))
typeIntStrictPositif._InitializeFacetMap(typeIntStrictPositif._CF_minInclusive)
Namespace.addCategoryObject('typeBinding', 'typeIntStrictPositif', typeIntStrictPositif)

# Atomic simple type: typeTouteLaSimulation
class typeTouteLaSimulation(pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeTouteLaSimulation')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               51, 2)
    _Documentation = None


typeTouteLaSimulation._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=typeTouteLaSimulation,
                                                                           enum_prefix=None)
typeTouteLaSimulation.always = typeTouteLaSimulation._CF_enumeration.addEnumeration(unicode_value='always',
                                                                                    tag='always')
typeTouteLaSimulation._InitializeFacetMap(typeTouteLaSimulation._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'typeTouteLaSimulation', typeTouteLaSimulation)

# Atomic simple type: typeDuree
class typeDuree(pyxb.binding.datatypes.string):
    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeDuree')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               56, 2)
    _Documentation = None


typeDuree._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', 'typeDuree', typeDuree)

# Atomic simple type: typeInfini
class typeInfini(pyxb.binding.datatypes.string, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeInfini')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               62, 2)
    _Documentation = None


typeInfini._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=typeInfini, enum_prefix=None)
typeInfini.infini = typeInfini._CF_enumeration.addEnumeration(unicode_value='infini', tag='infini')
typeInfini._InitializeFacetMap(typeInfini._CF_enumeration)
Namespace.addCategoryObject('typeBinding', 'typeInfini', typeInfini)

# List simple type: [anonymous]
# superclasses pyxb.binding.datatypes.anySimpleType
class STD_ANON(pyxb.binding.basis.STD_list):
    """Simple type that is a list of pyxb.binding.datatypes.float."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               73, 6)
    _Documentation = None

    _ItemType = pyxb.binding.datatypes.float


STD_ANON._InitializeFacetMap()

# Atomic simple type: [anonymous]
class STD_ANON_(pyxb.binding.datatypes.string):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               114, 6)
    _Documentation = None


STD_ANON_._InitializeFacetMap()

# Atomic simple type: [anonymous]
class STD_ANON_2(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               543, 12)
    _Documentation = None


STD_ANON_2._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_2, enum_prefix=None)
STD_ANON_2.normal = STD_ANON_2._CF_enumeration.addEnumeration(unicode_value='normal', tag='normal')
STD_ANON_2.light = STD_ANON_2._CF_enumeration.addEnumeration(unicode_value='light', tag='light')
STD_ANON_2._InitializeFacetMap(STD_ANON_2._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_3(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               661, 6)
    _Documentation = None


STD_ANON_3._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_3, enum_prefix=None)
STD_ANON_3.C = STD_ANON_3._CF_enumeration.addEnumeration(unicode_value='C', tag='C')
STD_ANON_3.P = STD_ANON_3._CF_enumeration.addEnumeration(unicode_value='P', tag='P')
STD_ANON_3._InitializeFacetMap(STD_ANON_3._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_4(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               680, 6)
    _Documentation = None


STD_ANON_4._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_4, enum_prefix=None)
STD_ANON_4.exacte = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='exacte', tag='exacte')
STD_ANON_4.estimee = STD_ANON_4._CF_enumeration.addEnumeration(unicode_value='estimee', tag='estimee')
STD_ANON_4._InitializeFacetMap(STD_ANON_4._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_5(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               699, 6)
    _Documentation = None


STD_ANON_5._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_5, enum_prefix=None)
STD_ANON_5.dir = STD_ANON_5._CF_enumeration.addEnumeration(unicode_value='dir', tag='dir')
STD_ANON_5.des = STD_ANON_5._CF_enumeration.addEnumeration(unicode_value='des', tag='des')
STD_ANON_5.iti = STD_ANON_5._CF_enumeration.addEnumeration(unicode_value='iti', tag='iti')
STD_ANON_5._InitializeFacetMap(STD_ANON_5._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_6(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               766, 6)
    _Documentation = None


STD_ANON_6._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_6, enum_prefix=None)
STD_ANON_6.statique = STD_ANON_6._CF_enumeration.addEnumeration(unicode_value='statique', tag='statique')
STD_ANON_6.dynamique = STD_ANON_6._CF_enumeration.addEnumeration(unicode_value='dynamique', tag='dynamique')
STD_ANON_6._InitializeFacetMap(STD_ANON_6._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_7(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               783, 6)
    _Documentation = None


STD_ANON_7._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_7, enum_prefix=None)
STD_ANON_7.NE = STD_ANON_7._CF_enumeration.addEnumeration(unicode_value='NE', tag='NE')
STD_ANON_7.ENM = STD_ANON_7._CF_enumeration.addEnumeration(unicode_value='ENM', tag='ENM')
STD_ANON_7.MSA = STD_ANON_7._CF_enumeration.addEnumeration(unicode_value='MSA', tag='MSA')
STD_ANON_7._InitializeFacetMap(STD_ANON_7._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_8(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               807, 6)
    _Documentation = None


STD_ANON_8._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_8, enum_prefix=None)
STD_ANON_8.R = STD_ANON_8._CF_enumeration.addEnumeration(unicode_value='R', tag='R')
STD_ANON_8.PN = STD_ANON_8._CF_enumeration.addEnumeration(unicode_value='PN', tag='PN')
STD_ANON_8.PL = STD_ANON_8._CF_enumeration.addEnumeration(unicode_value='PL', tag='PL')
STD_ANON_8._InitializeFacetMap(STD_ANON_8._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_9(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               849, 6)
    _Documentation = None


STD_ANON_9._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_9, enum_prefix=None)
STD_ANON_9.logit = STD_ANON_9._CF_enumeration.addEnumeration(unicode_value='logit', tag='logit')
STD_ANON_9.wardrop = STD_ANON_9._CF_enumeration.addEnumeration(unicode_value='wardrop', tag='wardrop')
STD_ANON_9._InitializeFacetMap(STD_ANON_9._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_10(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               879, 6)
    _Documentation = None


STD_ANON_10._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_10, enum_prefix=None)
STD_ANON_10.basique = STD_ANON_10._CF_enumeration.addEnumeration(unicode_value='basique', tag='basique')
STD_ANON_10.Dijkstra = STD_ANON_10._CF_enumeration.addEnumeration(unicode_value='Dijkstra', tag='Dijkstra')
STD_ANON_10._InitializeFacetMap(STD_ANON_10._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_11(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               909, 6)
    _Documentation = None


STD_ANON_11._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_11, enum_prefix=None)
STD_ANON_11.M = STD_ANON_11._CF_enumeration.addEnumeration(unicode_value='M', tag='M')
STD_ANON_11.H = STD_ANON_11._CF_enumeration.addEnumeration(unicode_value='H', tag='H')
STD_ANON_11.E = STD_ANON_11._CF_enumeration.addEnumeration(unicode_value='E', tag='E')
STD_ANON_11._InitializeFacetMap(STD_ANON_11._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_12(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               963, 6)
    _Documentation = None


STD_ANON_12._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_12, enum_prefix=None)
STD_ANON_12.peripherique = STD_ANON_12._CF_enumeration.addEnumeration(unicode_value='peripherique', tag='peripherique')
STD_ANON_12.surfacique = STD_ANON_12._CF_enumeration.addEnumeration(unicode_value='surfacique', tag='surfacique')
STD_ANON_12._InitializeFacetMap(STD_ANON_12._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_13(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               982, 6)
    _Documentation = None


STD_ANON_13._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_13, enum_prefix=None)
STD_ANON_13.peripherique = STD_ANON_13._CF_enumeration.addEnumeration(unicode_value='peripherique', tag='peripherique')
STD_ANON_13.surfacique = STD_ANON_13._CF_enumeration.addEnumeration(unicode_value='surfacique', tag='surfacique')
STD_ANON_13._InitializeFacetMap(STD_ANON_13._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_14(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1212, 6)
    _Documentation = None


STD_ANON_14._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_14, enum_prefix=None)
STD_ANON_14.U = STD_ANON_14._CF_enumeration.addEnumeration(unicode_value='U', tag='U')
STD_ANON_14.D = STD_ANON_14._CF_enumeration.addEnumeration(unicode_value='D', tag='D')
STD_ANON_14._InitializeFacetMap(STD_ANON_14._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_15(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1231, 6)
    _Documentation = None


STD_ANON_15._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_15, enum_prefix=None)
STD_ANON_15.S = STD_ANON_15._CF_enumeration.addEnumeration(unicode_value='S', tag='S')
STD_ANON_15.A = STD_ANON_15._CF_enumeration.addEnumeration(unicode_value='A', tag='A')
STD_ANON_15._InitializeFacetMap(STD_ANON_15._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_16(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1250, 6)
    _Documentation = None


STD_ANON_16._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_16, enum_prefix=None)
STD_ANON_16.GD = STD_ANON_16._CF_enumeration.addEnumeration(unicode_value='GD', tag='GD')
STD_ANON_16.DG = STD_ANON_16._CF_enumeration.addEnumeration(unicode_value='DG', tag='DG')
STD_ANON_16.F = STD_ANON_16._CF_enumeration.addEnumeration(unicode_value='F', tag='F')
STD_ANON_16._InitializeFacetMap(STD_ANON_16._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_17(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1551, 6)
    _Documentation = None


STD_ANON_17._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_17, enum_prefix=None)
STD_ANON_17.M = STD_ANON_17._CF_enumeration.addEnumeration(unicode_value='M', tag='M')
STD_ANON_17.H = STD_ANON_17._CF_enumeration.addEnumeration(unicode_value='H', tag='H')
STD_ANON_17.E = STD_ANON_17._CF_enumeration.addEnumeration(unicode_value='E', tag='E')
STD_ANON_17._InitializeFacetMap(STD_ANON_17._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_18(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2109, 10)
    _Documentation = None


STD_ANON_18._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_18, enum_prefix=None)
STD_ANON_18.ponctuel = STD_ANON_18._CF_enumeration.addEnumeration(unicode_value='ponctuel', tag='ponctuel')
STD_ANON_18.insertion = STD_ANON_18._CF_enumeration.addEnumeration(unicode_value='insertion', tag='insertion')
STD_ANON_18._InitializeFacetMap(STD_ANON_18._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_19(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2270, 10)
    _Documentation = None


STD_ANON_19._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_19, enum_prefix=None)
STD_ANON_19.D = STD_ANON_19._CF_enumeration.addEnumeration(unicode_value='D', tag='D')
STD_ANON_19.U = STD_ANON_19._CF_enumeration.addEnumeration(unicode_value='U', tag='U')
STD_ANON_19.P = STD_ANON_19._CF_enumeration.addEnumeration(unicode_value='P', tag='P')
STD_ANON_19._InitializeFacetMap(STD_ANON_19._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_20(pyxb.binding.datatypes.string):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2332, 34)
    _Documentation = None


STD_ANON_20._CF_maxLength = pyxb.binding.facets.CF_maxLength(value=pyxb.binding.datatypes.nonNegativeInteger(128))
STD_ANON_20._InitializeFacetMap(STD_ANON_20._CF_maxLength)

# Atomic simple type: [anonymous]
class STD_ANON_21(pyxb.binding.datatypes.integer):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2389, 46)
    _Documentation = None


STD_ANON_21._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=STD_ANON_21,
                                                                   value=pyxb.binding.datatypes.integer(0))
STD_ANON_21._InitializeFacetMap(STD_ANON_21._CF_minInclusive)

# Atomic simple type: [anonymous]
class STD_ANON_22(pyxb.binding.datatypes.string):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2405, 34)
    _Documentation = None


STD_ANON_22._CF_maxLength = pyxb.binding.facets.CF_maxLength(value=pyxb.binding.datatypes.nonNegativeInteger(512))
STD_ANON_22._InitializeFacetMap(STD_ANON_22._CF_maxLength)

# Atomic simple type: [anonymous]
class STD_ANON_23(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2455, 22)
    _Documentation = None


STD_ANON_23._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_23, enum_prefix=None)
STD_ANON_23.defaut = STD_ANON_23._CF_enumeration.addEnumeration(unicode_value='defaut', tag='defaut')
STD_ANON_23.cedez_le_passage = STD_ANON_23._CF_enumeration.addEnumeration(unicode_value='cedez_le_passage',
                                                                          tag='cedez_le_passage')
STD_ANON_23.stop = STD_ANON_23._CF_enumeration.addEnumeration(unicode_value='stop', tag='stop')
STD_ANON_23._InitializeFacetMap(STD_ANON_23._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_24(pyxb.binding.datatypes.string):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2515, 34)
    _Documentation = None


STD_ANON_24._CF_maxLength = pyxb.binding.facets.CF_maxLength(value=pyxb.binding.datatypes.nonNegativeInteger(128))
STD_ANON_24._InitializeFacetMap(STD_ANON_24._CF_maxLength)

# Atomic simple type: [anonymous]
class STD_ANON_25(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2653, 18)
    _Documentation = None


STD_ANON_25._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_25, enum_prefix=None)
STD_ANON_25.G = STD_ANON_25._CF_enumeration.addEnumeration(unicode_value='G', tag='G')
STD_ANON_25.M = STD_ANON_25._CF_enumeration.addEnumeration(unicode_value='M', tag='M')
STD_ANON_25._InitializeFacetMap(STD_ANON_25._CF_enumeration)

# List simple type: [anonymous]
# superclasses pyxb.binding.datatypes.anySimpleType
class STD_ANON_26(pyxb.binding.basis.STD_list):
    """Simple type that is a list of pyxb.binding.datatypes.string."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2681, 22)
    _Documentation = None

    _ItemType = pyxb.binding.datatypes.string


STD_ANON_26._InitializeFacetMap()

# List simple type: [anonymous]
# superclasses pyxb.binding.datatypes.anySimpleType
class STD_ANON_27(pyxb.binding.basis.STD_list):
    """Simple type that is a list of pyxb.binding.datatypes.string."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2827, 22)
    _Documentation = None

    _ItemType = pyxb.binding.datatypes.string


STD_ANON_27._InitializeFacetMap()

# List simple type: [anonymous]
# superclasses pyxb.binding.datatypes.anySimpleType
class STD_ANON_28(pyxb.binding.basis.STD_list):
    """Simple type that is a list of pyxb.binding.datatypes.nonNegativeInteger."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2839, 22)
    _Documentation = None

    _ItemType = pyxb.binding.datatypes.nonNegativeInteger


STD_ANON_28._InitializeFacetMap()

# Atomic simple type: [anonymous]
class STD_ANON_29(pyxb.binding.datatypes.int):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2970, 42)
    _Documentation = None


STD_ANON_29._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=STD_ANON_29,
                                                                   value=pyxb.binding.datatypes.int(0))
STD_ANON_29._InitializeFacetMap(STD_ANON_29._CF_minInclusive)

# Atomic simple type: [anonymous]
class STD_ANON_30(pyxb.binding.datatypes.int):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2981, 42)
    _Documentation = None


STD_ANON_30._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=STD_ANON_30,
                                                                   value=pyxb.binding.datatypes.int(0))
STD_ANON_30._InitializeFacetMap(STD_ANON_30._CF_minInclusive)

# Atomic simple type: [anonymous]
class STD_ANON_31(pyxb.binding.datatypes.int):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2993, 42)
    _Documentation = None


STD_ANON_31._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=STD_ANON_31,
                                                                   value=pyxb.binding.datatypes.int(0))
STD_ANON_31._InitializeFacetMap(STD_ANON_31._CF_minInclusive)

# Atomic simple type: [anonymous]
class STD_ANON_32(pyxb.binding.datatypes.int):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3023, 30)
    _Documentation = None


STD_ANON_32._CF_minExclusive = pyxb.binding.facets.CF_minExclusive(value_datatype=pyxb.binding.datatypes.int,
                                                                   value=pyxb.binding.datatypes.long(0))
STD_ANON_32._InitializeFacetMap(STD_ANON_32._CF_minExclusive)

# Atomic simple type: [anonymous]
class STD_ANON_33(pyxb.binding.datatypes.string):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3039, 18)
    _Documentation = None


STD_ANON_33._CF_maxLength = pyxb.binding.facets.CF_maxLength(value=pyxb.binding.datatypes.nonNegativeInteger(80))
STD_ANON_33._InitializeFacetMap(STD_ANON_33._CF_maxLength)

# List simple type: [anonymous]
# superclasses pyxb.binding.datatypes.anySimpleType
class STD_ANON_34(pyxb.binding.basis.STD_list):
    """Simple type that is a list of pyxb.binding.datatypes.string."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3073, 22)
    _Documentation = None

    _ItemType = pyxb.binding.datatypes.string


STD_ANON_34._InitializeFacetMap()

# Atomic simple type: [anonymous]
class STD_ANON_35(pyxb.binding.datatypes.int):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3119, 18)
    _Documentation = None


STD_ANON_35._CF_minInclusive = pyxb.binding.facets.CF_minInclusive(value_datatype=STD_ANON_35,
                                                                   value=pyxb.binding.datatypes.int(1))
STD_ANON_35._InitializeFacetMap(STD_ANON_35._CF_minInclusive)

# Atomic simple type: [anonymous]
class STD_ANON_36(pyxb.binding.datatypes.string):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3161, 6)
    _Documentation = None


STD_ANON_36._CF_maxLength = pyxb.binding.facets.CF_maxLength(value=pyxb.binding.datatypes.nonNegativeInteger(80))
STD_ANON_36._InitializeFacetMap(STD_ANON_36._CF_maxLength)

# Atomic simple type: [anonymous]
class STD_ANON_37(pyxb.binding.datatypes.int):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3172, 6)
    _Documentation = None


STD_ANON_37._CF_minExclusive = pyxb.binding.facets.CF_minExclusive(value_datatype=pyxb.binding.datatypes.int,
                                                                   value=pyxb.binding.datatypes.long(0))
STD_ANON_37._InitializeFacetMap(STD_ANON_37._CF_minExclusive)

# Atomic simple type: [anonymous]
class STD_ANON_38(pyxb.binding.datatypes.int):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3183, 6)
    _Documentation = None


STD_ANON_38._CF_minExclusive = pyxb.binding.facets.CF_minExclusive(value_datatype=pyxb.binding.datatypes.int,
                                                                   value=pyxb.binding.datatypes.long(0))
STD_ANON_38._InitializeFacetMap(STD_ANON_38._CF_minExclusive)

# Atomic simple type: [anonymous]
class STD_ANON_39(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3195, 6)
    _Documentation = None


STD_ANON_39._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_39, enum_prefix=None)
STD_ANON_39.aucune = STD_ANON_39._CF_enumeration.addEnumeration(unicode_value='aucune', tag='aucune')
STD_ANON_39.vecteurs = STD_ANON_39._CF_enumeration.addEnumeration(unicode_value='vecteurs', tag='vecteurs')
STD_ANON_39._InitializeFacetMap(STD_ANON_39._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_40(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3417, 6)
    _Documentation = None


STD_ANON_40._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_40, enum_prefix=None)
STD_ANON_40.demande = STD_ANON_40._CF_enumeration.addEnumeration(unicode_value='demande', tag='demande')
STD_ANON_40.distributionExponentielle = STD_ANON_40._CF_enumeration.addEnumeration(
    unicode_value='distributionExponentielle', tag='distributionExponentielle')
STD_ANON_40.listeVehicules = STD_ANON_40._CF_enumeration.addEnumeration(unicode_value='listeVehicules',
                                                                        tag='listeVehicules')
STD_ANON_40._InitializeFacetMap(STD_ANON_40._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_41(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3767, 10)
    _Documentation = None


STD_ANON_41._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_41, enum_prefix=None)
STD_ANON_41.peripherique = STD_ANON_41._CF_enumeration.addEnumeration(unicode_value='peripherique', tag='peripherique')
STD_ANON_41.surfacique = STD_ANON_41._CF_enumeration.addEnumeration(unicode_value='surfacique', tag='surfacique')
STD_ANON_41._InitializeFacetMap(STD_ANON_41._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_42(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3786, 10)
    _Documentation = None


STD_ANON_42._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_42, enum_prefix=None)
STD_ANON_42.peripherique = STD_ANON_42._CF_enumeration.addEnumeration(unicode_value='peripherique', tag='peripherique')
STD_ANON_42.surfacique = STD_ANON_42._CF_enumeration.addEnumeration(unicode_value='surfacique', tag='surfacique')
STD_ANON_42._InitializeFacetMap(STD_ANON_42._CF_enumeration)

# Atomic simple type: [anonymous]
class STD_ANON_43(pyxb.binding.datatypes.NMTOKEN, pyxb.binding.basis.enumeration_mixin):
    """An atomic simple type."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4004, 14)
    _Documentation = None


STD_ANON_43._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=STD_ANON_43, enum_prefix=None)
STD_ANON_43.profil = STD_ANON_43._CF_enumeration.addEnumeration(unicode_value='profil', tag='profil')
STD_ANON_43.horaire = STD_ANON_43._CF_enumeration.addEnumeration(unicode_value='horaire', tag='horaire')
STD_ANON_43._InitializeFacetMap(STD_ANON_43._CF_enumeration)

# List simple type: [anonymous]
# superclasses pyxb.binding.datatypes.anySimpleType
class STD_ANON_44(pyxb.binding.basis.STD_list):
    """Simple type that is a list of typeFloat01."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               36, 6)
    _Documentation = None

    _ItemType = typeFloat01


STD_ANON_44._InitializeFacetMap()

# List simple type: [anonymous]
# superclasses pyxb.binding.datatypes.anySimpleType
class STD_ANON_45(pyxb.binding.basis.STD_list):
    """Simple type that is a list of typeFloat01."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               46, 6)
    _Documentation = None

    _ItemType = typeFloat01


STD_ANON_45._InitializeFacetMap()

# Union simple type: typeVitesses
# superclasses pyxb.binding.datatypes.anySimpleType
class typeVitesses(pyxb.binding.basis.STD_union):
    """Simple type that is a union of typeFloatStrictPositif."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeVitesses')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               59, 2)
    _Documentation = None

    _MemberTypes = ( typeFloatStrictPositif, )


typeVitesses._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=typeVitesses)
typeVitesses._CF_pattern = pyxb.binding.facets.CF_pattern()
typeVitesses._InitializeFacetMap(typeVitesses._CF_enumeration,
                                 typeVitesses._CF_pattern)
Namespace.addCategoryObject('typeBinding', 'typeVitesses', typeVitesses)

# Union simple type: typeVitMax
# superclasses pyxb.binding.datatypes.anySimpleType
class typeVitMax(pyxb.binding.basis.STD_union):
    """Simple type that is a union of typeFloatStrictPositif, typeInfini."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeVitMax')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               67, 2)
    _Documentation = ''

    _MemberTypes = ( typeFloatStrictPositif, typeInfini, )


typeVitMax._CF_enumeration = pyxb.binding.facets.CF_enumeration(value_datatype=typeVitMax)
typeVitMax._CF_pattern = pyxb.binding.facets.CF_pattern()
typeVitMax.infini = 'infini'  # originally typeInfini.infini
typeVitMax._InitializeFacetMap(typeVitMax._CF_enumeration,
                               typeVitMax._CF_pattern)
Namespace.addCategoryObject('typeBinding', 'typeVitMax', typeVitMax)

# List simple type: typeCoordonnees
# superclasses STD_ANON
class typeCoordonnees(pyxb.binding.basis.STD_list):
    """Simple type that is a list of pyxb.binding.datatypes.float."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeCoordonnees')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               71, 2)
    _Documentation = None

    _ItemType = pyxb.binding.datatypes.float


typeCoordonnees._CF_minLength = pyxb.binding.facets.CF_minLength(value=pyxb.binding.datatypes.nonNegativeInteger(2))
typeCoordonnees._CF_maxLength = pyxb.binding.facets.CF_maxLength(value=pyxb.binding.datatypes.nonNegativeInteger(3))
typeCoordonnees._CF_whiteSpace = pyxb.binding.facets.CF_whiteSpace(value=pyxb.binding.facets._WhiteSpace_enum.collapse)
typeCoordonnees._InitializeFacetMap(typeCoordonnees._CF_minLength,
                                    typeCoordonnees._CF_maxLength,
                                    typeCoordonnees._CF_whiteSpace)
Namespace.addCategoryObject('typeBinding', 'typeCoordonnees', typeCoordonnees)

# Atomic simple type: typeString256
class typeString256(STD_ANON_):
    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeString256')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               112, 2)
    _Documentation = None


typeString256._CF_maxLength = pyxb.binding.facets.CF_maxLength(value=pyxb.binding.datatypes.nonNegativeInteger(256))
typeString256._InitializeFacetMap(typeString256._CF_maxLength)
Namespace.addCategoryObject('typeBinding', 'typeString256', typeString256)

# List simple type: [anonymous]
# superclasses pyxb.binding.datatypes.anySimpleType
class STD_ANON_46(pyxb.binding.basis.STD_list):
    """Simple type that is a list of typeFloatPositif."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2603, 34)
    _Documentation = None

    _ItemType = typeFloatPositif


STD_ANON_46._InitializeFacetMap()

# List simple type: [anonymous]
# superclasses STD_ANON_26
class STD_ANON_47(pyxb.binding.basis.STD_list):
    """Simple type that is a list of pyxb.binding.datatypes.string."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2679, 18)
    _Documentation = None

    _ItemType = pyxb.binding.datatypes.string


STD_ANON_47._InitializeFacetMap()

# List simple type: [anonymous]
# superclasses STD_ANON_27
class STD_ANON_48(pyxb.binding.basis.STD_list):
    """Simple type that is a list of pyxb.binding.datatypes.string."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2825, 18)
    _Documentation = None

    _ItemType = pyxb.binding.datatypes.string


STD_ANON_48._InitializeFacetMap()

# List simple type: [anonymous]
# superclasses STD_ANON_28
class STD_ANON_49(pyxb.binding.basis.STD_list):
    """Simple type that is a list of pyxb.binding.datatypes.nonNegativeInteger."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2837, 18)
    _Documentation = None

    _ItemType = pyxb.binding.datatypes.nonNegativeInteger


STD_ANON_49._InitializeFacetMap()

# List simple type: [anonymous]
# superclasses STD_ANON_34
class STD_ANON_50(pyxb.binding.basis.STD_list):
    """Simple type that is a list of pyxb.binding.datatypes.string."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3071, 18)
    _Documentation = None

    _ItemType = pyxb.binding.datatypes.string


STD_ANON_50._InitializeFacetMap()

# List simple type: typeFloat01List
# superclasses STD_ANON_44
class typeFloat01List(pyxb.binding.basis.STD_list):
    """Simple type that is a list of typeFloat01."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeFloat01List')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               34, 2)
    _Documentation = None

    _ItemType = typeFloat01


typeFloat01List._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', 'typeFloat01List', typeFloat01List)

# List simple type: typeFloat01NormedList
# superclasses STD_ANON_45
class typeFloat01NormedList(pyxb.binding.basis.STD_list):
    """La somme des coefficients doit Ãªtre Ã©gale Ã  1"""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeFloat01NormedList')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               41, 2)
    _Documentation = 'La somme des coefficients doit \xeatre \xe9gale \xe0 1'

    _ItemType = typeFloat01


typeFloat01NormedList._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', 'typeFloat01NormedList', typeFloat01NormedList)

# List simple type: [anonymous]
# superclasses STD_ANON_46
class STD_ANON_51(pyxb.binding.basis.STD_list):
    """Simple type that is a list of typeFloatPositif."""

    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2601, 30)
    _Documentation = None

    _ItemType = typeFloatPositif


STD_ANON_51._InitializeFacetMap()

# List simple type: typeRGBAColor
# superclasses typeFloat01List
class typeRGBAColor(pyxb.binding.basis.STD_list):
    """Simple type that is a list of typeFloat01."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeRGBAColor')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               81, 2)
    _Documentation = None

    _ItemType = typeFloat01


typeRGBAColor._CF_minLength = pyxb.binding.facets.CF_minLength(value=pyxb.binding.datatypes.nonNegativeInteger(3))
typeRGBAColor._CF_maxLength = pyxb.binding.facets.CF_maxLength(value=pyxb.binding.datatypes.nonNegativeInteger(4))
typeRGBAColor._CF_whiteSpace = pyxb.binding.facets.CF_whiteSpace(value=pyxb.binding.facets._WhiteSpace_enum.collapse)
typeRGBAColor._InitializeFacetMap(typeRGBAColor._CF_minLength,
                                  typeRGBAColor._CF_maxLength,
                                  typeRGBAColor._CF_whiteSpace)
Namespace.addCategoryObject('typeBinding', 'typeRGBAColor', typeRGBAColor)

# Complex type typeAny with content type ELEMENT_ONLY
class typeAny(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeAny with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeAny')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               88, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _AttributeWildcard = pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_skip,
                                                       namespace_constraint=pyxb.binding.content.Wildcard.NC_any)
    _HasWildcardElement = True
    _ElementMap.update({

    })
    _AttributeMap.update({

    })


Namespace.addCategoryObject('typeBinding', 'typeAny', typeAny)


# Complex type typePointsInternes with content type ELEMENT_ONLY
class typePointsInternes(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typePointsInternes with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typePointsInternes')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               94, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element POINT_INTERNE uses Python identifier POINT_INTERNE
    __POINT_INTERNE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'POINT_INTERNE'),
                                                              'POINT_INTERNE',
                                                              '__AbsentNamespace0_typePointsInternes_POINT_INTERNE',
                                                              True, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 96, 6), )

    POINT_INTERNE = property(__POINT_INTERNE.value, __POINT_INTERNE.set, None,
                             "\n                  Description d'un point interne du tron\xe7on\n                ")

    _ElementMap.update({
        __POINT_INTERNE.name(): __POINT_INTERNE
    })
    _AttributeMap.update({

    })


Namespace.addCategoryObject('typeBinding', 'typePointsInternes', typePointsInternes)


# Complex type typeCoeffDir with content type ELEMENT_ONLY
class typeCoeffDir(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeCoeffDir with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeCoeffDir')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               120, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element COEFF_DIR uses Python identifier COEFF_DIR
    __COEFF_DIR = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'COEFF_DIR'), 'COEFF_DIR',
                                                          '__AbsentNamespace0_typeCoeffDir_COEFF_DIR', True,
                                                          pyxb.utils.utility.Location(
                                                              '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                              122, 6), )

    COEFF_DIR = property(__COEFF_DIR.value, __COEFF_DIR.set, None,
                         "Description d'une variante temporelle des coefficients directionnels")

    _ElementMap.update({
        __COEFF_DIR.name(): __COEFF_DIR
    })
    _AttributeMap.update({

    })


Namespace.addCategoryObject('typeBinding', 'typeCoeffDir', typeCoeffDir)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON(pyxb.binding.basis.complexTypeDefinition):
    """Description d'une variante temporelle des coefficients directionnels"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               126, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element COEFFS_TRONCON_AMONT uses Python identifier COEFFS_TRONCON_AMONT
    __COEFFS_TRONCON_AMONT = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'COEFFS_TRONCON_AMONT'), 'COEFFS_TRONCON_AMONT',
        '__AbsentNamespace0_CTD_ANON_COEFFS_TRONCON_AMONT', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 128, 12), )

    COEFFS_TRONCON_AMONT = property(__COEFFS_TRONCON_AMONT.value, __COEFFS_TRONCON_AMONT.set, None,
                                    'Collection des coefficients directionnels pour la liste des tron\xe7ons amont')


    # Attribute duree uses Python identifier duree
    __duree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree'), 'duree',
                                                '__AbsentNamespace0_CTD_ANON_duree', pyxb.binding.datatypes.string,
                                                unicode_default='always')
    __duree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 205, 10)
    __duree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 205, 10)

    duree = property(__duree.value, __duree.set, None,
                     'Identifiant de la plage temporelle associ\xe9e, ou dur\xe9e (en seconde) de la variante de r\xe9partition du flux')

    _ElementMap.update({
        __COEFFS_TRONCON_AMONT.name(): __COEFFS_TRONCON_AMONT
    })
    _AttributeMap.update({
        __duree.name(): __duree
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_(pyxb.binding.basis.complexTypeDefinition):
    """Collection des coefficients directionnels pour la liste des tronÃ§ons amont"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               132, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element COEFF_TRONCON_AMONT uses Python identifier COEFF_TRONCON_AMONT
    __COEFF_TRONCON_AMONT = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'COEFF_TRONCON_AMONT'), 'COEFF_TRONCON_AMONT',
        '__AbsentNamespace0_CTD_ANON__COEFF_TRONCON_AMONT', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 134, 18), )

    COEFF_TRONCON_AMONT = property(__COEFF_TRONCON_AMONT.value, __COEFF_TRONCON_AMONT.set, None,
                                   'Description des coefficients directionnels pour un tron\xe7on amont')

    _ElementMap.update({
        __COEFF_TRONCON_AMONT.name(): __COEFF_TRONCON_AMONT
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_2(pyxb.binding.basis.complexTypeDefinition):
    """Description des coefficients directionnels pour un tronÃ§on amont"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               138, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element COEFFS_VOIE_AMONT uses Python identifier COEFFS_VOIE_AMONT
    __COEFFS_VOIE_AMONT = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'COEFFS_VOIE_AMONT'), 'COEFFS_VOIE_AMONT',
        '__AbsentNamespace0_CTD_ANON_2_COEFFS_VOIE_AMONT', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 140, 24), )

    COEFFS_VOIE_AMONT = property(__COEFFS_VOIE_AMONT.value, __COEFFS_VOIE_AMONT.set, None,
                                 'Collection des coefficients directionnels pour la liste des voies du tron\xe7on amont')


    # Attribute id_amont uses Python identifier id_amont
    __id_amont = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_amont'), 'id_amont',
                                                   '__AbsentNamespace0_CTD_ANON_2_id_amont',
                                                   pyxb.binding.datatypes.string, required=True)
    __id_amont._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 194, 22)
    __id_amont._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 194, 22)

    id_amont = property(__id_amont.value, __id_amont.set, None, 'Identifiant du tron\xe7on amont')

    _ElementMap.update({
        __COEFFS_VOIE_AMONT.name(): __COEFFS_VOIE_AMONT
    })
    _AttributeMap.update({
        __id_amont.name(): __id_amont
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_3(pyxb.binding.basis.complexTypeDefinition):
    """Collection des coefficients directionnels pour la liste des voies du tronÃ§on amont"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               144, 26)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element COEFF_VOIE_AMONT uses Python identifier COEFF_VOIE_AMONT
    __COEFF_VOIE_AMONT = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'COEFF_VOIE_AMONT'),
                                                                 'COEFF_VOIE_AMONT',
                                                                 '__AbsentNamespace0_CTD_ANON_3_COEFF_VOIE_AMONT', True,
                                                                 pyxb.utils.utility.Location(
                                                                     '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                     146, 30), )

    COEFF_VOIE_AMONT = property(__COEFF_VOIE_AMONT.value, __COEFF_VOIE_AMONT.set, None,
                                'Description des coefficients directionnels pour un tron\xe7on amont et une voie donn\xe9e')

    _ElementMap.update({
        __COEFF_VOIE_AMONT.name(): __COEFF_VOIE_AMONT
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_4(pyxb.binding.basis.complexTypeDefinition):
    """Collection des coefficients directionnels des tronÃ§ons aval pour un tronÃ§on et une voie donnÃ©es en amont. Si un tronÃ§on aval du rÃ©partiteur parent ne se trouve pas dans la liste, cela signifie qu'aucun vÃ©hicule ou flux provenant de la voie du tronÃ§on amont considÃ©rÃ© ne sort du rÃ©partiteur par ce tronÃ§on aval"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               156, 38)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element COEFF_TRONCON_AVAL uses Python identifier COEFF_TRONCON_AVAL
    __COEFF_TRONCON_AVAL = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'COEFF_TRONCON_AVAL'), 'COEFF_TRONCON_AVAL',
        '__AbsentNamespace0_CTD_ANON_4_COEFF_TRONCON_AVAL', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 158, 42), )

    COEFF_TRONCON_AVAL = property(__COEFF_TRONCON_AVAL.value, __COEFF_TRONCON_AVAL.set, None,
                                  'Collection des coefficients directionnels pour un tron\xe7on amont, une voie donn\xe9e et un tron\xe7on aval')

    _ElementMap.update({
        __COEFF_TRONCON_AVAL.name(): __COEFF_TRONCON_AVAL
    })
    _AttributeMap.update({

    })


# Complex type typeAffectation with content type ELEMENT_ONLY
class typeAffectation(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeAffectation with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeAffectation')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               214, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element AFFECTATION uses Python identifier AFFECTATION
    __AFFECTATION = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'AFFECTATION'),
                                                            'AFFECTATION',
                                                            '__AbsentNamespace0_typeAffectation_AFFECTATION', True,
                                                            pyxb.utils.utility.Location(
                                                                '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                216, 6), )

    AFFECTATION = property(__AFFECTATION.value, __AFFECTATION.set, None,
                           "Description d'une variante des donn\xe9es d'affectation de la connexion (ce noeud est d\xe9fini uniquement si le comportement de flux est de type 'destination').")

    _ElementMap.update({
        __AFFECTATION.name(): __AFFECTATION
    })
    _AttributeMap.update({

    })


Namespace.addCategoryObject('typeBinding', 'typeAffectation', typeAffectation)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_5(pyxb.binding.basis.complexTypeDefinition):
    """Noeud d'accÃ¨s Ã  la collection des couples entrÃ©e / destination des donnÃ©es d'affectation"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               226, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element COUPLE_ENTREE_DESTINATION uses Python identifier COUPLE_ENTREE_DESTINATION
    __COUPLE_ENTREE_DESTINATION = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'COUPLE_ENTREE_DESTINATION'), 'COUPLE_ENTREE_DESTINATION',
        '__AbsentNamespace0_CTD_ANON_5_COUPLE_ENTREE_DESTINATION', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 228, 18), )

    COUPLE_ENTREE_DESTINATION = property(__COUPLE_ENTREE_DESTINATION.value, __COUPLE_ENTREE_DESTINATION.set, None,
                                         "Description des donn\xe9es d'affectation d'un couple entr\xe9e / destination de la connexion")

    _ElementMap.update({
        __COUPLE_ENTREE_DESTINATION.name(): __COUPLE_ENTREE_DESTINATION
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_6(pyxb.binding.basis.complexTypeDefinition):
    """Description des donnÃ©es d'affectation d'un couple entrÃ©e / destination de la connexion"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               232, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element SORTIES_CONNEXION uses Python identifier SORTIES_CONNEXION
    __SORTIES_CONNEXION = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'SORTIES_CONNEXION'), 'SORTIES_CONNEXION',
        '__AbsentNamespace0_CTD_ANON_6_SORTIES_CONNEXION', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 234, 24), )

    SORTIES_CONNEXION = property(__SORTIES_CONNEXION.value, __SORTIES_CONNEXION.set, None,
                                 "Noeud d'acc\xe8s \xe0 la liste des sorties affect\xe9es")


    # Attribute id_troncon_amont uses Python identifier id_troncon_amont
    __id_troncon_amont = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_troncon_amont'),
                                                           'id_troncon_amont',
                                                           '__AbsentNamespace0_CTD_ANON_6_id_troncon_amont',
                                                           pyxb.binding.datatypes.string, required=True)
    __id_troncon_amont._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 264, 22)
    __id_troncon_amont._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 264, 22)

    id_troncon_amont = property(__id_troncon_amont.value, __id_troncon_amont.set, None,
                                'Identifiant du tron\xe7on amont (entr\xe9e) de la connexion')


    # Attribute id_destination uses Python identifier id_destination
    __id_destination = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_destination'),
                                                         'id_destination',
                                                         '__AbsentNamespace0_CTD_ANON_6_id_destination',
                                                         pyxb.binding.datatypes.string, required=True)
    __id_destination._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 269, 22)
    __id_destination._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 269, 22)

    id_destination = property(__id_destination.value, __id_destination.set, None, 'Identifiant de la destination')

    _ElementMap.update({
        __SORTIES_CONNEXION.name(): __SORTIES_CONNEXION
    })
    _AttributeMap.update({
        __id_troncon_amont.name(): __id_troncon_amont,
        __id_destination.name(): __id_destination
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_7(pyxb.binding.basis.complexTypeDefinition):
    """Noeud d'accÃ¨s Ã  la liste des sorties affectÃ©es"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               238, 26)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element SORTIE_CONNEXION uses Python identifier SORTIE_CONNEXION
    __SORTIE_CONNEXION = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SORTIE_CONNEXION'),
                                                                 'SORTIE_CONNEXION',
                                                                 '__AbsentNamespace0_CTD_ANON_7_SORTIE_CONNEXION', True,
                                                                 pyxb.utils.utility.Location(
                                                                     '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                     240, 30), )

    SORTIE_CONNEXION = property(__SORTIE_CONNEXION.value, __SORTIE_CONNEXION.set, None,
                                'Description de la sortie affect\xe9e')

    _ElementMap.update({
        __SORTIE_CONNEXION.name(): __SORTIE_CONNEXION
    })
    _AttributeMap.update({

    })


# Complex type typeMouvementAutorise with content type ELEMENT_ONLY
class typeMouvementAutorise(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeMouvementAutorise with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeMouvementAutorise')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               289, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element MOUVEMENT_AUTORISE uses Python identifier MOUVEMENT_AUTORISE
    __MOUVEMENT_AUTORISE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'MOUVEMENT_AUTORISE'), 'MOUVEMENT_AUTORISE',
        '__AbsentNamespace0_typeMouvementAutorise_MOUVEMENT_AUTORISE', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 291, 6), )

    MOUVEMENT_AUTORISE = property(__MOUVEMENT_AUTORISE.value, __MOUVEMENT_AUTORISE.set, None,
                                  "Description d'un mouvement de la connexion interne")

    _ElementMap.update({
        __MOUVEMENT_AUTORISE.name(): __MOUVEMENT_AUTORISE
    })
    _AttributeMap.update({

    })


Namespace.addCategoryObject('typeBinding', 'typeMouvementAutorise', typeMouvementAutorise)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_8(pyxb.binding.basis.complexTypeDefinition):
    """Description de l'aval du mouvement (si un tronÃ§on aval de la connexion n'est pas prÃ©sent, les vÃ©hicules entrant par le tronÃ§on et la voie considÃ©rÃ©s ne peuvent pas sortir par ce tronÃ§on)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               301, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element MOUVEMENT_SORTIE uses Python identifier MOUVEMENT_SORTIE
    __MOUVEMENT_SORTIE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MOUVEMENT_SORTIE'),
                                                                 'MOUVEMENT_SORTIE',
                                                                 '__AbsentNamespace0_CTD_ANON_8_MOUVEMENT_SORTIE', True,
                                                                 pyxb.utils.utility.Location(
                                                                     '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                     303, 18), )

    MOUVEMENT_SORTIE = property(__MOUVEMENT_SORTIE.value, __MOUVEMENT_SORTIE.set, None,
                                "Description de l'aval d'un mouvement")

    _ElementMap.update({
        __MOUVEMENT_SORTIE.name(): __MOUVEMENT_SORTIE
    })
    _AttributeMap.update({

    })


# Complex type typeConnexionInterne with content type ELEMENT_ONLY
class typeConnexionInterne(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeConnexionInterne with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeConnexionInterne')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               373, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element MOUVEMENTS_AUTORISES uses Python identifier MOUVEMENTS_AUTORISES
    __MOUVEMENTS_AUTORISES = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'MOUVEMENTS_AUTORISES'), 'MOUVEMENTS_AUTORISES',
        '__AbsentNamespace0_typeConnexionInterne_MOUVEMENTS_AUTORISES', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 375, 6), )

    MOUVEMENTS_AUTORISES = property(__MOUVEMENTS_AUTORISES.value, __MOUVEMENTS_AUTORISES.set, None, None)


    # Attribute z_level_crossing uses Python identifier z_level_crossing
    __z_level_crossing = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'z_level_crossing'),
                                                           'z_level_crossing',
                                                           '__AbsentNamespace0_typeConnexionInterne_z_level_crossing',
                                                           pyxb.binding.datatypes.int, unicode_default='0')
    __z_level_crossing._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 378, 4)
    __z_level_crossing._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 378, 4)

    z_level_crossing = property(__z_level_crossing.value, __z_level_crossing.set, None,
                                "Gestion des multi-niveaux des \xe9l\xe9ments du r\xe9seau (ponts, tunnels...): valeur du z-level\nDans le cas d'une brique de connexion, on suppose que l'ensemble des \xe9l\xe9ments la composant poss\xe8de une unique valeur de z-level.")

    _ElementMap.update({
        __MOUVEMENTS_AUTORISES.name(): __MOUVEMENTS_AUTORISES
    })
    _AttributeMap.update({
        __z_level_crossing.name(): __z_level_crossing
    })


Namespace.addCategoryObject('typeBinding', 'typeConnexionInterne', typeConnexionInterne)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_9(pyxb.binding.basis.complexTypeDefinition):
    """Noeud d'accÃ¨s Ã  la description des affectations par type de vÃ©hicule"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               397, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element AFFECTATION_TYPE_VEHICULE uses Python identifier AFFECTATION_TYPE_VEHICULE
    __AFFECTATION_TYPE_VEHICULE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'AFFECTATION_TYPE_VEHICULE'), 'AFFECTATION_TYPE_VEHICULE',
        '__AbsentNamespace0_CTD_ANON_9_AFFECTATION_TYPE_VEHICULE', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 399, 14), )

    AFFECTATION_TYPE_VEHICULE = property(__AFFECTATION_TYPE_VEHICULE.value, __AFFECTATION_TYPE_VEHICULE.set, None,
                                         "Noeud d'acc\xe8s \xe0 la description de l'affectation pour un type de v\xe9hicule")

    _ElementMap.update({
        __AFFECTATION_TYPE_VEHICULE.name(): __AFFECTATION_TYPE_VEHICULE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_10(pyxb.binding.basis.complexTypeDefinition):
    """Noeud d'accÃ¨s Ã  la description de l'affectation pour un type de vÃ©hicule"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               403, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element AFFECTATIONS uses Python identifier AFFECTATIONS
    __AFFECTATIONS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'AFFECTATIONS'),
                                                             'AFFECTATIONS',
                                                             '__AbsentNamespace0_CTD_ANON_10_AFFECTATIONS', False,
                                                             pyxb.utils.utility.Location(
                                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                 405, 20), )

    AFFECTATIONS = property(__AFFECTATIONS.value, __AFFECTATIONS.set, None, None)


    # Attribute id_type_vehicule uses Python identifier id_type_vehicule
    __id_type_vehicule = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_type_vehicule'),
                                                           'id_type_vehicule',
                                                           '__AbsentNamespace0_CTD_ANON_10_id_type_vehicule',
                                                           pyxb.binding.datatypes.string, required=True)
    __id_type_vehicule._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 408, 18)
    __id_type_vehicule._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 408, 18)

    id_type_vehicule = property(__id_type_vehicule.value, __id_type_vehicule.set, None,
                                'Identifiant du type de v\xe9hicule d\xe9crit')

    _ElementMap.update({
        __AFFECTATIONS.name(): __AFFECTATIONS
    })
    _AttributeMap.update({
        __id_type_vehicule.name(): __id_type_vehicule
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_11(pyxb.binding.basis.complexTypeDefinition):
    """Liste des temps d'insertion sur la connexion pour tous les types de vÃ©hicule circulant sur le rÃ©seau"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               424, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TEMPS_INSERTION uses Python identifier TEMPS_INSERTION
    __TEMPS_INSERTION = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TEMPS_INSERTION'),
                                                                'TEMPS_INSERTION',
                                                                '__AbsentNamespace0_CTD_ANON_11_TEMPS_INSERTION', True,
                                                                pyxb.utils.utility.Location(
                                                                    '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                    426, 12), )

    TEMPS_INSERTION = property(__TEMPS_INSERTION.value, __TEMPS_INSERTION.set, None,
                               "Temps d'insertion sur la connexion pour un type de v\xe9hicule")

    _ElementMap.update({
        __TEMPS_INSERTION.name(): __TEMPS_INSERTION
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_12(pyxb.binding.basis.complexTypeDefinition):
    """Plages temporelles d'Ã©criture des instants de la simulation. Sans plage d'extraction l'Ã©criture est rÃ©alisÃ©e sur toute la simulation."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               505, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element PLAGE_EXTRACTION uses Python identifier PLAGE_EXTRACTION
    __PLAGE_EXTRACTION = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PLAGE_EXTRACTION'),
                                                                 'PLAGE_EXTRACTION',
                                                                 '__AbsentNamespace0_CTD_ANON_12_PLAGE_EXTRACTION',
                                                                 True, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 507, 18), )

    PLAGE_EXTRACTION = property(__PLAGE_EXTRACTION.value, __PLAGE_EXTRACTION.set, None,
                                "Plage temporelle d'\xe9criture des instants de la simulation.")

    _ElementMap.update({
        __PLAGE_EXTRACTION.name(): __PLAGE_EXTRACTION
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_13(pyxb.binding.basis.complexTypeDefinition):
    """Plage temporelle d'Ã©criture des instants de la simulation."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               511, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute debut_extraction uses Python identifier debut_extraction
    __debut_extraction = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'debut_extraction'),
                                                           'debut_extraction',
                                                           '__AbsentNamespace0_CTD_ANON_13_debut_extraction',
                                                           pyxb.binding.datatypes.time, unicode_default='00:00:00')
    __debut_extraction._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 512, 22)
    __debut_extraction._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 512, 22)

    debut_extraction = property(__debut_extraction.value, __debut_extraction.set, None,
                                "Heure de d\xe9but d'extraction des r\xe9sultats de la simulation (Heures:Minutes:Secondes)")


    # Attribute fin_extraction uses Python identifier fin_extraction
    __fin_extraction = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'fin_extraction'),
                                                         'fin_extraction',
                                                         '__AbsentNamespace0_CTD_ANON_13_fin_extraction',
                                                         pyxb.binding.datatypes.time, unicode_default='00:00:00')
    __fin_extraction._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 517, 22)
    __fin_extraction._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 517, 22)

    fin_extraction = property(__fin_extraction.value, __fin_extraction.set, None,
                              "Heure de fin d'extraction des r\xe9sultats de la simulation (Heures:Minutes:Secondes)")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __debut_extraction.name(): __debut_extraction,
        __fin_extraction.name(): __fin_extraction
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_14(pyxb.binding.basis.complexTypeDefinition):
    """Ensemble des Ã©lÃ©ments du rÃ©seau pour lesquels sont dÃ©finis des paramÃ¨tres de simulation spÃ©cifiques"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               611, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element ELEMENT uses Python identifier ELEMENT
    __ELEMENT = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ELEMENT'), 'ELEMENT',
                                                        '__AbsentNamespace0_CTD_ANON_14_ELEMENT', True,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            613, 12), )

    ELEMENT = property(__ELEMENT.value, __ELEMENT.set, None,
                       'El\xe9ment du r\xe9seau pour lequel sont d\xe9finis des param\xe8tres de simulation sp\xe9cifiques')

    _ElementMap.update({
        __ELEMENT.name(): __ELEMENT
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_15(pyxb.binding.basis.complexTypeDefinition):
    """Ensemble des tronÃ§ons pour lesquels sont dÃ©finis des paramÃ¨tres de trafic particuliers"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1063, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TRONCON uses Python identifier TRONCON
    __TRONCON = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRONCON'), 'TRONCON',
                                                        '__AbsentNamespace0_CTD_ANON_15_TRONCON', True,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            1065, 12), )

    TRONCON = property(__TRONCON.value, __TRONCON.set, None,
                       'Tron\xe7on pour lequel est d\xe9fini des param\xe8tres de trafic particuliers')

    _ElementMap.update({
        __TRONCON.name(): __TRONCON
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_16(pyxb.binding.basis.complexTypeDefinition):
    """Liste des types de vÃ©hicule"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1077, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TYPE_DE_VEHICULE uses Python identifier TYPE_DE_VEHICULE
    __TYPE_DE_VEHICULE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TYPE_DE_VEHICULE'),
                                                                 'TYPE_DE_VEHICULE',
                                                                 '__AbsentNamespace0_CTD_ANON_16_TYPE_DE_VEHICULE',
                                                                 True, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1079, 12), )

    TYPE_DE_VEHICULE = property(__TYPE_DE_VEHICULE.value, __TYPE_DE_VEHICULE.set, None,
                                "Description d'un type de v\xe9hicule")

    _ElementMap.update({
        __TYPE_DE_VEHICULE.name(): __TYPE_DE_VEHICULE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_17(pyxb.binding.basis.complexTypeDefinition):
    """Liste des extremitÃ©s (entrÃ©es et sorties) du rÃ©seau pour lesquelles des paramÃ¨tres de trafic spÃ©cifiques sont dÃ©finis"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1096, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element EXTREMITE uses Python identifier EXTREMITE
    __EXTREMITE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'EXTREMITE'), 'EXTREMITE',
                                                          '__AbsentNamespace0_CTD_ANON_17_EXTREMITE', True,
                                                          pyxb.utils.utility.Location(
                                                              '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                              1098, 12), )

    EXTREMITE = property(__EXTREMITE.value, __EXTREMITE.set, None,
                         "Description des param\xe8tres de trafic d'une extremit\xe9 (entr\xe9e ou sortie)")

    _ElementMap.update({
        __EXTREMITE.name(): __EXTREMITE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_18(pyxb.binding.basis.complexTypeDefinition):
    """Liste des parkings du rÃ©seau pour lesquels des paramÃ¨tres de trafic spÃ©cifiques sont dÃ©finis"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1111, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element PARKING uses Python identifier PARKING
    __PARKING = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PARKING'), 'PARKING',
                                                        '__AbsentNamespace0_CTD_ANON_18_PARKING', True,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            1113, 12), )

    PARKING = property(__PARKING.value, __PARKING.set, None, "Description des param\xe8tres de trafic d'un parking")

    _ElementMap.update({
        __PARKING.name(): __PARKING
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_19(pyxb.binding.basis.complexTypeDefinition):
    """Liste des zones de terminaison du rÃ©seau pour lesquelles des paramÃ¨tres de trafic spÃ©cifiques sont dÃ©finis"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1125, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element ZONE_DE_TERMINAISON uses Python identifier ZONE_DE_TERMINAISON
    __ZONE_DE_TERMINAISON = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'ZONE_DE_TERMINAISON'), 'ZONE_DE_TERMINAISON',
        '__AbsentNamespace0_CTD_ANON_19_ZONE_DE_TERMINAISON', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1127, 12), )

    ZONE_DE_TERMINAISON = property(__ZONE_DE_TERMINAISON.value, __ZONE_DE_TERMINAISON.set, None,
                                   "Description des param\xe8tres de trafic d'une zone de terminaison")

    _ElementMap.update({
        __ZONE_DE_TERMINAISON.name(): __ZONE_DE_TERMINAISON
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_20(pyxb.binding.basis.complexTypeDefinition):
    """Liste des connexions internes au rÃ©seau pour lesquelles des paramÃ¨tres de trafic spÃ©cifiques sont dÃ©finis"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1140, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element CONNEXION_INTERNE uses Python identifier CONNEXION_INTERNE
    __CONNEXION_INTERNE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'CONNEXION_INTERNE'), 'CONNEXION_INTERNE',
        '__AbsentNamespace0_CTD_ANON_20_CONNEXION_INTERNE', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1142, 12), )

    CONNEXION_INTERNE = property(__CONNEXION_INTERNE.value, __CONNEXION_INTERNE.set, None,
                                 'Connexion interne pour laquelle sont d\xe9finis des param\xe8tres de trafic particuliers')

    _ElementMap.update({
        __CONNEXION_INTERNE.name(): __CONNEXION_INTERNE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_21(pyxb.binding.basis.complexTypeDefinition):
    """Liste des contrÃ´leurs de feux
"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1161, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element CONTROLEUR_DE_FEUX uses Python identifier CONTROLEUR_DE_FEUX
    __CONTROLEUR_DE_FEUX = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'CONTROLEUR_DE_FEUX'), 'CONTROLEUR_DE_FEUX',
        '__AbsentNamespace0_CTD_ANON_21_CONTROLEUR_DE_FEUX', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1163, 12), )

    CONTROLEUR_DE_FEUX = property(__CONTROLEUR_DE_FEUX.value, __CONTROLEUR_DE_FEUX.set, None,
                                  "Description d'un contr\xf4leur de feux\n")

    _ElementMap.update({
        __CONTROLEUR_DE_FEUX.name(): __CONTROLEUR_DE_FEUX
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_22(pyxb.binding.basis.complexTypeDefinition):
    """Liste des briques de rÃ©gulation de trafic dÃ©finies"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1177, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element REGULATION uses Python identifier REGULATION
    __REGULATION = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'REGULATION'),
                                                           'REGULATION', '__AbsentNamespace0_CTD_ANON_22_REGULATION',
                                                           True, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1179, 12), )

    REGULATION = property(__REGULATION.value, __REGULATION.set, None, "D\xe9finition d'une brique de r\xe9gulation")

    _ElementMap.update({
        __REGULATION.name(): __REGULATION
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_23(pyxb.binding.basis.complexTypeDefinition):
    """Liste ordonnÃ©e des plages de l'accÃ©lÃ©ration en fonction de la vitesse dans le cas d'une accÃ©lÃ©ration non constante (ce noeud n'est pas lu dans le cas oÃ¹ la simulation a pour caractÃ©ristique "accÃ©lÃ©ration non bornÃ©e")"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1364, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element ACCELERATION_PLAGE uses Python identifier ACCELERATION_PLAGE
    __ACCELERATION_PLAGE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'ACCELERATION_PLAGE'), 'ACCELERATION_PLAGE',
        '__AbsentNamespace0_CTD_ANON_23_ACCELERATION_PLAGE', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1366, 12), )

    ACCELERATION_PLAGE = property(__ACCELERATION_PLAGE.value, __ACCELERATION_PLAGE.set, None,
                                  "Description d'une plage d'acc\xe9l\xe9ration")

    _ElementMap.update({
        __ACCELERATION_PLAGE.name(): __ACCELERATION_PLAGE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_24(pyxb.binding.basis.complexTypeDefinition):
    """Liste des sources acoustiques du vÃ©hicule"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1390, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element SOURCE_ACOUSTIQUE uses Python identifier SOURCE_ACOUSTIQUE
    __SOURCE_ACOUSTIQUE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'SOURCE_ACOUSTIQUE'), 'SOURCE_ACOUSTIQUE',
        '__AbsentNamespace0_CTD_ANON_24_SOURCE_ACOUSTIQUE', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1392, 12), )

    SOURCE_ACOUSTIQUE = property(__SOURCE_ACOUSTIQUE.value, __SOURCE_ACOUSTIQUE.set, None,
                                 "Description d'une source acoustique du type de v\xe9hicule parent")

    _ElementMap.update({
        __SOURCE_ACOUSTIQUE.name(): __SOURCE_ACOUSTIQUE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_25(pyxb.binding.basis.complexTypeDefinition):
    """Description d'une source acoustique du type de vÃ©hicule parent"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1396, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute position uses Python identifier position
    __position = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position'), 'position',
                                                   '__AbsentNamespace0_CTD_ANON_25_position',
                                                   pyxb.binding.datatypes.float, unicode_default='0')
    __position._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1397, 16)
    __position._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1397, 16)

    position = property(__position.value, __position.set, None,
                        "Position de la source acoustique du v\xe9hicule (l'origine est l'avant du v\xe9hicule)")


    # Attribute id_DB_LoiEmission uses Python identifier id_DB_LoiEmission
    __id_DB_LoiEmission = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_DB_LoiEmission'),
                                                            'id_DB_LoiEmission',
                                                            '__AbsentNamespace0_CTD_ANON_25_id_DB_LoiEmission',
                                                            pyxb.binding.datatypes.string, required=True)
    __id_DB_LoiEmission._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1402, 16)
    __id_DB_LoiEmission._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1402, 16)

    id_DB_LoiEmission = property(__id_DB_LoiEmission.value, __id_DB_LoiEmission.set, None,
                                 "Identifiant base de donn\xe9e des lois d'\xe9mission de la source acoustique du type de v\xe9hicule")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __position.name(): __position,
        __id_DB_LoiEmission.name(): __id_DB_LoiEmission
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_26(pyxb.binding.basis.complexTypeDefinition):
    """Liste des voies rÃ©duites pour les tronÃ§ons microscopiques(Symubruit force le changement de voie avant la fin du tronÃ§on pour de telles voies)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1605, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element VOIE_REDUITE uses Python identifier VOIE_REDUITE
    __VOIE_REDUITE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VOIE_REDUITE'),
                                                             'VOIE_REDUITE',
                                                             '__AbsentNamespace0_CTD_ANON_26_VOIE_REDUITE', True,
                                                             pyxb.utils.utility.Location(
                                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                 1607, 12), )

    VOIE_REDUITE = property(__VOIE_REDUITE.value, __VOIE_REDUITE.set, None, "Description d'une voie r\xe9duite")

    _ElementMap.update({
        __VOIE_REDUITE.name(): __VOIE_REDUITE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_27(pyxb.binding.basis.complexTypeDefinition):
    """Liste des vitesses rÃ©glementaires spÃ©cifiques Ã  un type de vÃ©hicule (Ã  dÃ©finir uniquement dans le cas d'un tronÃ§on microscopique et lorsque la vitesse rÃ©glementaire n'est pas commune Ã  tous les types de vÃ©hicules)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1636, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element VITESSE_REG uses Python identifier VITESSE_REG
    __VITESSE_REG = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VITESSE_REG'),
                                                            'VITESSE_REG', '__AbsentNamespace0_CTD_ANON_27_VITESSE_REG',
                                                            True, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1638, 12), )

    VITESSE_REG = property(__VITESSE_REG.value, __VITESSE_REG.set, None,
                           'Description des vitesses r\xe9glementaires du tron\xe7on pour une variante temporelle donn\xe9e')

    _ElementMap.update({
        __VITESSE_REG.name(): __VITESSE_REG
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_28(pyxb.binding.basis.complexTypeDefinition):
    """Description des vitesses rÃ©glementaires du tronÃ§on pour une liste de types de vÃ©hicules donnÃ©e"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1648, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element VITESSE_REG_PAR_VOIE uses Python identifier VITESSE_REG_PAR_VOIE
    __VITESSE_REG_PAR_VOIE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'VITESSE_REG_PAR_VOIE'), 'VITESSE_REG_PAR_VOIE',
        '__AbsentNamespace0_CTD_ANON_28_VITESSE_REG_PAR_VOIE', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1650, 24), )

    VITESSE_REG_PAR_VOIE = property(__VITESSE_REG_PAR_VOIE.value, __VITESSE_REG_PAR_VOIE.set, None,
                                    'Description de al vitesse r\xe9glementaire pour une voie et \xe9ventuellement une portion spaciale donn\xe9e')


    # Attribute types_vehicules uses Python identifier types_vehicules
    __types_vehicules = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'types_vehicules'),
                                                          'types_vehicules',
                                                          '__AbsentNamespace0_CTD_ANON_28_types_vehicules',
                                                          pyxb.binding.datatypes.string)
    __types_vehicules._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1681, 22)
    __types_vehicules._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1681, 22)

    types_vehicules = property(__types_vehicules.value, __types_vehicules.set, None,
                               'Identifiants du ou des types de v\xe9hicules concern\xe9s (ils doivent \xeatre d\xe9finis dans la liste TYPES_DE_VEHICULE). Par d\xe9faut, tous les types de v\xe9hicules sont concern\xe9s.')

    _ElementMap.update({
        __VITESSE_REG_PAR_VOIE.name(): __VITESSE_REG_PAR_VOIE
    })
    _AttributeMap.update({
        __types_vehicules.name(): __types_vehicules
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_29(pyxb.binding.basis.complexTypeDefinition):
    """Liste des traversÃ©es prioritaires pour les tronÃ§ons microscopiques"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1710, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TRAVERSEE uses Python identifier TRAVERSEE
    __TRAVERSEE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRAVERSEE'), 'TRAVERSEE',
                                                          '__AbsentNamespace0_CTD_ANON_29_TRAVERSEE', True,
                                                          pyxb.utils.utility.Location(
                                                              '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                              1712, 12), )

    TRAVERSEE = property(__TRAVERSEE.value, __TRAVERSEE.set, None, "Description d'une travers\xe9e prioritaire")

    _ElementMap.update({
        __TRAVERSEE.name(): __TRAVERSEE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_30(pyxb.binding.basis.complexTypeDefinition):
    """Description d'une traversÃ©e prioritaire"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1716, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element LISTE_TEMPS_TRAVERSEE uses Python identifier LISTE_TEMPS_TRAVERSEE
    __LISTE_TEMPS_TRAVERSEE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'LISTE_TEMPS_TRAVERSEE'), 'LISTE_TEMPS_TRAVERSEE',
        '__AbsentNamespace0_CTD_ANON_30_LISTE_TEMPS_TRAVERSEE', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1718, 18), )

    LISTE_TEMPS_TRAVERSEE = property(__LISTE_TEMPS_TRAVERSEE.value, __LISTE_TEMPS_TRAVERSEE.set, None,
                                     'Liste des temps de travers\xe9e du tron\xe7on prioritaire pour tous les types de v\xe9hicule circulant sur le r\xe9seau')


    # Attribute troncon uses Python identifier troncon
    __troncon = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'troncon'), 'troncon',
                                                  '__AbsentNamespace0_CTD_ANON_30_troncon',
                                                  pyxb.binding.datatypes.string, required=True)
    __troncon._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1745, 16)
    __troncon._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1745, 16)

    troncon = property(__troncon.value, __troncon.set, None,
                       "Tron\xe7on prioritaire traversant le tron\xe7on parent (g\xe9om\xe9triquement, les deux tron\xe7ons doivent s'intersecter)")

    _ElementMap.update({
        __LISTE_TEMPS_TRAVERSEE.name(): __LISTE_TEMPS_TRAVERSEE
    })
    _AttributeMap.update({
        __troncon.name(): __troncon
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_31(pyxb.binding.basis.complexTypeDefinition):
    """Liste des temps de traversÃ©e du tronÃ§on prioritaire pour tous les types de vÃ©hicule circulant sur le rÃ©seau"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1722, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TEMPS_TRAVERSEE uses Python identifier TEMPS_TRAVERSEE
    __TEMPS_TRAVERSEE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TEMPS_TRAVERSEE'),
                                                                'TEMPS_TRAVERSEE',
                                                                '__AbsentNamespace0_CTD_ANON_31_TEMPS_TRAVERSEE', True,
                                                                pyxb.utils.utility.Location(
                                                                    '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                    1724, 24), )

    TEMPS_TRAVERSEE = property(__TEMPS_TRAVERSEE.value, __TEMPS_TRAVERSEE.set, None,
                               'Temps de travers\xe9e du tron\xe7on prioritaire pour un type de v\xe9hicule')

    _ElementMap.update({
        __TEMPS_TRAVERSEE.name(): __TEMPS_TRAVERSEE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_32(pyxb.binding.basis.complexTypeDefinition):
    """DÃ©finition des voies rÃ©servÃ©es sur ce tronÃ§on"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1759, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element VOIE_RESERVEE uses Python identifier VOIE_RESERVEE
    __VOIE_RESERVEE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VOIE_RESERVEE'),
                                                              'VOIE_RESERVEE',
                                                              '__AbsentNamespace0_CTD_ANON_32_VOIE_RESERVEE', True,
                                                              pyxb.utils.utility.Location(
                                                                  '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                  1761, 12), )

    VOIE_RESERVEE = property(__VOIE_RESERVEE.value, __VOIE_RESERVEE.set, None,
                             "D\xe9finition d'une voie r\xe9serv\xe9e")

    _ElementMap.update({
        __VOIE_RESERVEE.name(): __VOIE_RESERVEE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_33(pyxb.binding.basis.complexTypeDefinition):
    """DÃ©finition des voies interdites sur le tronÃ§on"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1800, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element VOIE_INTERDITE uses Python identifier VOIE_INTERDITE
    __VOIE_INTERDITE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VOIE_INTERDITE'),
                                                               'VOIE_INTERDITE',
                                                               '__AbsentNamespace0_CTD_ANON_33_VOIE_INTERDITE', True,
                                                               pyxb.utils.utility.Location(
                                                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                   1802, 12), )

    VOIE_INTERDITE = property(__VOIE_INTERDITE.value, __VOIE_INTERDITE.set, None, None)

    _ElementMap.update({
        __VOIE_INTERDITE.name(): __VOIE_INTERDITE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_34(pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type EMPTY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1803, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute num_voie uses Python identifier num_voie
    __num_voie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'num_voie'), 'num_voie',
                                                   '__AbsentNamespace0_CTD_ANON_34_num_voie',
                                                   pyxb.binding.datatypes.positiveInteger, required=True)
    __num_voie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1804, 16)
    __num_voie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1804, 16)

    num_voie = property(__num_voie.value, __num_voie.set, None, 'Num\xe9ro de la voie interdite sur le tron\xe7on')


    # Attribute id_typesvehicules uses Python identifier id_typesvehicules
    __id_typesvehicules = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_typesvehicules'),
                                                            'id_typesvehicules',
                                                            '__AbsentNamespace0_CTD_ANON_34_id_typesvehicules',
                                                            pyxb.binding.datatypes.string, required=True)
    __id_typesvehicules._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1809, 16)
    __id_typesvehicules._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1809, 16)

    id_typesvehicules = property(__id_typesvehicules.value, __id_typesvehicules.set, None,
                                 'Liste des identifiants des types de v\xe9hicule pour lesquels la voie est interdite')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __num_voie.name(): __num_voie,
        __id_typesvehicules.name(): __id_typesvehicules
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_35(pyxb.binding.basis.complexTypeDefinition):
    """Ensemble des terre-pleins prÃ©sents sur le tronÃ§on"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1823, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TERRE_PLEIN uses Python identifier TERRE_PLEIN
    __TERRE_PLEIN = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TERRE_PLEIN'),
                                                            'TERRE_PLEIN', '__AbsentNamespace0_CTD_ANON_35_TERRE_PLEIN',
                                                            True, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1825, 12), )

    TERRE_PLEIN = property(__TERRE_PLEIN.value, __TERRE_PLEIN.set, None, 'Terre-plein pr\xe9sent sur le tron\xe7on')

    _ElementMap.update({
        __TERRE_PLEIN.name(): __TERRE_PLEIN
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_36(pyxb.binding.basis.complexTypeDefinition):
    """Ensemble des zones dans lesquelles le dÃ©passement par passage sur la voie de gauche du tronÃ§on opposÃ© est interdit """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1873, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element ZONE_DEPASSEMENT_INTERDIT uses Python identifier ZONE_DEPASSEMENT_INTERDIT
    __ZONE_DEPASSEMENT_INTERDIT = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'ZONE_DEPASSEMENT_INTERDIT'), 'ZONE_DEPASSEMENT_INTERDIT',
        '__AbsentNamespace0_CTD_ANON_36_ZONE_DEPASSEMENT_INTERDIT', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1875, 12), )

    ZONE_DEPASSEMENT_INTERDIT = property(__ZONE_DEPASSEMENT_INTERDIT.value, __ZONE_DEPASSEMENT_INTERDIT.set, None,
                                         'Zone dans laquelle le d\xe9passement par passage sur la voie de gauche du tron\xe7on oppos\xe9 est interdit')

    _ElementMap.update({
        __ZONE_DEPASSEMENT_INTERDIT.name(): __ZONE_DEPASSEMENT_INTERDIT
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_37(pyxb.binding.basis.complexTypeDefinition):
    """Ensemble des zones dans lesquelles le trafic ne doit pas Ãªtre pris en compte. A exploiter au niveau des outils de post-traitement."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1899, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element ZONE_EXCLUSION uses Python identifier ZONE_EXCLUSION
    __ZONE_EXCLUSION = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ZONE_EXCLUSION'),
                                                               'ZONE_EXCLUSION',
                                                               '__AbsentNamespace0_CTD_ANON_37_ZONE_EXCLUSION', True,
                                                               pyxb.utils.utility.Location(
                                                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                   1901, 12), )

    ZONE_EXCLUSION = property(__ZONE_EXCLUSION.value, __ZONE_EXCLUSION.set, None,
                              'Zone dans laquelle le trafic ne doit pas \xeatre pris en compte. A exploiter au niveau des outils de post-traitement.')

    _ElementMap.update({
        __ZONE_EXCLUSION.name(): __ZONE_EXCLUSION
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_38(pyxb.binding.basis.complexTypeDefinition):
    """DÃ©finition des portions du tronÃ§on pour lesquellse on dÃ©finit un zLevel particulier"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1925, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element Z_LEVEL_CROSSING uses Python identifier Z_LEVEL_CROSSING
    __Z_LEVEL_CROSSING = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'Z_LEVEL_CROSSING'),
                                                                 'Z_LEVEL_CROSSING',
                                                                 '__AbsentNamespace0_CTD_ANON_38_Z_LEVEL_CROSSING',
                                                                 True, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1927, 12), )

    Z_LEVEL_CROSSING = property(__Z_LEVEL_CROSSING.value, __Z_LEVEL_CROSSING.set, None, None)

    _ElementMap.update({
        __Z_LEVEL_CROSSING.name(): __Z_LEVEL_CROSSING
    })
    _AttributeMap.update({

    })


# Complex type typeEntree with content type EMPTY
class typeEntree(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeEntree with content type EMPTY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeEntree')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2028, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeEntree_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2029, 4)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2029, 4)

    id = property(__id.value, __id.set, None, "Identifiant de l'entr\xe9e")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id.name(): __id
    })


Namespace.addCategoryObject('typeBinding', 'typeEntree', typeEntree)


# Complex type typeSortie with content type EMPTY
class typeSortie(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeSortie with content type EMPTY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeSortie')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2035, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeSortie_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2036, 4)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2036, 4)

    id = property(__id.value, __id.set, None, 'Identifiant de la sortie')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id.name(): __id
    })


Namespace.addCategoryObject('typeBinding', 'typeSortie', typeSortie)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_39(pyxb.binding.basis.complexTypeDefinition):
    """Liste des tronÃ§ons amont du convergent"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2066, 12)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TRONCON_AMONT uses Python identifier TRONCON_AMONT
    __TRONCON_AMONT = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRONCON_AMONT'),
                                                              'TRONCON_AMONT',
                                                              '__AbsentNamespace0_CTD_ANON_39_TRONCON_AMONT', True,
                                                              pyxb.utils.utility.Location(
                                                                  '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                  2068, 16), )

    TRONCON_AMONT = property(__TRONCON_AMONT.value, __TRONCON_AMONT.set, None,
                             "Description d'un tron\xe7on amont du convergent")

    _ElementMap.update({
        __TRONCON_AMONT.name(): __TRONCON_AMONT
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_40(pyxb.binding.basis.complexTypeDefinition):
    """Liste des tronÃ§ons composant l'anneau du giratoire"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2145, 12)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TRONCON_INTERNE uses Python identifier TRONCON_INTERNE
    __TRONCON_INTERNE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRONCON_INTERNE'),
                                                                'TRONCON_INTERNE',
                                                                '__AbsentNamespace0_CTD_ANON_40_TRONCON_INTERNE', True,
                                                                pyxb.utils.utility.Location(
                                                                    '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                    2147, 16), )

    TRONCON_INTERNE = property(__TRONCON_INTERNE.value, __TRONCON_INTERNE.set, None,
                               "Caract\xe9ristiques d'un tron\xe7on de l'anneau du giratoire")

    _ElementMap.update({
        __TRONCON_INTERNE.name(): __TRONCON_INTERNE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_41(pyxb.binding.basis.complexTypeDefinition):
    """Liste des coefficients permettant de dÃ©finir manuellement les taux de choix de la voie d'insertion d'un vÃ©hicule sur le giratoire (utile pour le cas de giratoires Ã  plusieurs voies) en fonction de la voie d'entrÃ©e et du tronÃ§on de sortie"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2202, 12)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element COEFFICIENT_INSERTION uses Python identifier COEFFICIENT_INSERTION
    __COEFFICIENT_INSERTION = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'COEFFICIENT_INSERTION'), 'COEFFICIENT_INSERTION',
        '__AbsentNamespace0_CTD_ANON_41_COEFFICIENT_INSERTION', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2204, 16), )

    COEFFICIENT_INSERTION = property(__COEFFICIENT_INSERTION.value, __COEFFICIENT_INSERTION.set, None,
                                     "D\xe9finition manuelle des taux de choix de la voie d'insertion d'un v\xe9hicule sur le giratoire (utile pour le cas de giratoires \xe0 plusieurs voies) pour une voie d'entr\xe9e et un troncon de sortie donn\xe9s")

    _ElementMap.update({
        __COEFFICIENT_INSERTION.name(): __COEFFICIENT_INSERTION
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_42(pyxb.binding.basis.complexTypeDefinition):
    """DÃ©finition manuelle des taux de choix de la voie d'insertion d'un vÃ©hicule sur le giratoire (utile pour le cas de giratoires Ã  plusieurs voies) pour une voie d'entrÃ©e et un troncon de sortie donnÃ©s"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2208, 18)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute troncon_entree uses Python identifier troncon_entree
    __troncon_entree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'troncon_entree'),
                                                         'troncon_entree',
                                                         '__AbsentNamespace0_CTD_ANON_42_troncon_entree',
                                                         pyxb.binding.datatypes.string, required=True)
    __troncon_entree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2209, 20)
    __troncon_entree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2209, 20)

    troncon_entree = property(__troncon_entree.value, __troncon_entree.set, None,
                              "Identifiant du tron\xe7on d'entr\xe9e")


    # Attribute num_voie_entree uses Python identifier num_voie_entree
    __num_voie_entree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'num_voie_entree'),
                                                          'num_voie_entree',
                                                          '__AbsentNamespace0_CTD_ANON_42_num_voie_entree',
                                                          pyxb.binding.datatypes.positiveInteger, unicode_default='1')
    __num_voie_entree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2214, 20)
    __num_voie_entree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2214, 20)

    num_voie_entree = property(__num_voie_entree.value, __num_voie_entree.set, None, "Num\xe9ro de la voie d'entr\xe9e")


    # Attribute troncon_sortie uses Python identifier troncon_sortie
    __troncon_sortie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'troncon_sortie'),
                                                         'troncon_sortie',
                                                         '__AbsentNamespace0_CTD_ANON_42_troncon_sortie',
                                                         pyxb.binding.datatypes.string, required=True)
    __troncon_sortie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2220, 20)
    __troncon_sortie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2220, 20)

    troncon_sortie = property(__troncon_sortie.value, __troncon_sortie.set, None, 'Identifiant du tron\xe7on de sortie')


    # Attribute coeffs uses Python identifier coeffs
    __coeffs = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'coeffs'), 'coeffs',
                                                 '__AbsentNamespace0_CTD_ANON_42_coeffs', pyxb.binding.datatypes.string,
                                                 required=True)
    __coeffs._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2225, 20)
    __coeffs._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2225, 20)

    coeffs = property(__coeffs.value, __coeffs.set, None,
                      'Liste des coefficients pour chaque voie interne du giratoire (de la voie exterieure vers la voie int\xe9rieure)')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __troncon_entree.name(): __troncon_entree,
        __num_voie_entree.name(): __num_voie_entree,
        __troncon_sortie.name(): __troncon_sortie,
        __coeffs.name(): __coeffs
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_43(pyxb.binding.basis.complexTypeDefinition):
    """Liste des entrÃ©es et de ses caractÃ©ristiques du carrefour Ã  feu"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2301, 12)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element ENTREE_CAF uses Python identifier ENTREE_CAF
    __ENTREE_CAF = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ENTREE_CAF'),
                                                           'ENTREE_CAF', '__AbsentNamespace0_CTD_ANON_43_ENTREE_CAF',
                                                           True, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2303, 16), )

    ENTREE_CAF = property(__ENTREE_CAF.value, __ENTREE_CAF.set, None,
                          "Description d'une entr\xe9e du carrefour \xe0 feu (une entr\xe9e est d\xe9finie par un tron\xe7on et un num\xe9ro de voie)")

    _ElementMap.update({
        __ENTREE_CAF.name(): __ENTREE_CAF
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_44(pyxb.binding.basis.complexTypeDefinition):
    """Liste des divergents de l'entrÃ©e considÃ©rÃ©e. Ils sont ordonnÃ©s (du 1er au dernier rencontrÃ©). Si cette liste n'existe pas, l'ensemble des mouvements issus de l'entrÃ©e divergent immÃ©diatement Ã  l'extrÃ©mitÃ© aval du tronÃ§on d'entrÃ©e."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2313, 24)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element DIVERGENT uses Python identifier DIVERGENT
    __DIVERGENT = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DIVERGENT'), 'DIVERGENT',
                                                          '__AbsentNamespace0_CTD_ANON_44_DIVERGENT', True,
                                                          pyxb.utils.utility.Location(
                                                              '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                              2315, 28), )

    DIVERGENT = property(__DIVERGENT.value, __DIVERGENT.set, None,
                         "Description d'un divergent d'une branche d'entr\xe9e")

    _ElementMap.update({
        __DIVERGENT.name(): __DIVERGENT
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_45(pyxb.binding.basis.complexTypeDefinition):
    """Liste des mouvements possibles issus de l'entrÃ©e considÃ©rÃ©"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2352, 24)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element MOUVEMENT uses Python identifier MOUVEMENT
    __MOUVEMENT = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MOUVEMENT'), 'MOUVEMENT',
                                                          '__AbsentNamespace0_CTD_ANON_45_MOUVEMENT', True,
                                                          pyxb.utils.utility.Location(
                                                              '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                              2354, 28), )

    MOUVEMENT = property(__MOUVEMENT.value, __MOUVEMENT.set, None, "Description d'un mouvement")

    _ElementMap.update({
        __MOUVEMENT.name(): __MOUVEMENT
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_46(pyxb.binding.basis.complexTypeDefinition):
    """Liste des points d'attente des traversÃ©es du mouvement"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2370, 36)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element POINT_D_ATTENTE uses Python identifier POINT_D_ATTENTE
    __POINT_D_ATTENTE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'POINT_D_ATTENTE'),
                                                                'POINT_D_ATTENTE',
                                                                '__AbsentNamespace0_CTD_ANON_46_POINT_D_ATTENTE', True,
                                                                pyxb.utils.utility.Location(
                                                                    '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                    2372, 40), )

    POINT_D_ATTENTE = property(__POINT_D_ATTENTE.value, __POINT_D_ATTENTE.set, None,
                               "Description d'un point d'attente du mouvement. Lors du calcul des points d'intersection des mouvements pour d\xe9tecter les travers\xe9es non prioritaires, celles-ci seront regroup\xe9es en consid\xe9rant leur position par rapport au point d'attente. Ainsi, un point d'attente est utilis\xe9 pour les travers\xe9es du mouvement se situant en amont du point jusqu'au prochain point d'attente d\xe9fini ou jusqu'\xe0 l'extr\xe9mit\xe9 du mouvement")

    _ElementMap.update({
        __POINT_D_ATTENTE.name(): __POINT_D_ATTENTE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_47(pyxb.binding.basis.complexTypeDefinition):
    """Liste des sorties du CAF dans le cas oÃ¹ les convergents de rattachement au sortie ont besoin d'Ãªtre prÃ©cisÃ©s (sinon tous les mouvements se rattachent a l'extrÃ©mitÃ© aval de la sortie)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2484, 12)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element SORTIE_CAF uses Python identifier SORTIE_CAF
    __SORTIE_CAF = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SORTIE_CAF'),
                                                           'SORTIE_CAF', '__AbsentNamespace0_CTD_ANON_47_SORTIE_CAF',
                                                           True, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2486, 16), )

    SORTIE_CAF = property(__SORTIE_CAF.value, __SORTIE_CAF.set, None,
                          "Description d'une sortie du carrefour \xe0 feu (une sortie est d\xe9finie par un tron\xe7on et un num\xe9ro de voie)")

    _ElementMap.update({
        __SORTIE_CAF.name(): __SORTIE_CAF
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_48(pyxb.binding.basis.complexTypeDefinition):
    """Liste des convergents de la sortie. Ils sont ordonnÃ©s Ã  partir de la fin (du dernier au 1er rencontrÃ©). Si cette liste n'existe pas, l'ensemble des mouvements arrivant sur cette sortie convergent  immÃ©diatement Ã  l'extrÃ©mitÃ© amont du tronÃ§on de sortie."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2496, 24)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element CONVERGENT uses Python identifier CONVERGENT
    __CONVERGENT = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CONVERGENT'),
                                                           'CONVERGENT', '__AbsentNamespace0_CTD_ANON_48_CONVERGENT',
                                                           True, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2498, 28), )

    CONVERGENT = property(__CONVERGENT.value, __CONVERGENT.set, None,
                          "Description d'un divergent d'un tron\xe7on d'entr\xe9e")

    _ElementMap.update({
        __CONVERGENT.name(): __CONVERGENT
    })
    _AttributeMap.update({

    })


# Complex type typeLTG with content type ELEMENT_ONLY
class typeLTG(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeLTG with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeLTG')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2567, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element LIGNES_TRANSPORT_GUIDEES uses Python identifier LIGNES_TRANSPORT_GUIDEES
    __LIGNES_TRANSPORT_GUIDEES = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'LIGNES_TRANSPORT_GUIDEES'), 'LIGNES_TRANSPORT_GUIDEES',
        '__AbsentNamespace0_typeLTG_LIGNES_TRANSPORT_GUIDEES', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2569, 6), )

    LIGNES_TRANSPORT_GUIDEES = property(__LIGNES_TRANSPORT_GUIDEES.value, __LIGNES_TRANSPORT_GUIDEES.set, None,
                                        'Liste des lignes de transport guid\xe9e du r\xe9seau')


    # Element ARRETS uses Python identifier ARRETS
    __ARRETS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ARRETS'), 'ARRETS',
                                                       '__AbsentNamespace0_typeLTG_ARRETS', False,
                                                       pyxb.utils.utility.Location(
                                                           '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                           2703, 6), )

    ARRETS = property(__ARRETS.value, __ARRETS.set, None, 'Liste des arr\xeats de la ligne')

    _ElementMap.update({
        __LIGNES_TRANSPORT_GUIDEES.name(): __LIGNES_TRANSPORT_GUIDEES,
        __ARRETS.name(): __ARRETS
    })
    _AttributeMap.update({

    })


Namespace.addCategoryObject('typeBinding', 'typeLTG', typeLTG)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_49(pyxb.binding.basis.complexTypeDefinition):
    """Liste des lignes de transport guidÃ©e du rÃ©seau"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2573, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element LIGNE_TRANSPORT_GUIDEE uses Python identifier LIGNE_TRANSPORT_GUIDEE
    __LIGNE_TRANSPORT_GUIDEE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'LIGNE_TRANSPORT_GUIDEE'), 'LIGNE_TRANSPORT_GUIDEE',
        '__AbsentNamespace0_CTD_ANON_49_LIGNE_TRANSPORT_GUIDEE', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2575, 12), )

    LIGNE_TRANSPORT_GUIDEE = property(__LIGNE_TRANSPORT_GUIDEE.value, __LIGNE_TRANSPORT_GUIDEE.set, None,
                                      "Description d'une ligne de transport guid\xe9e")

    _ElementMap.update({
        __LIGNE_TRANSPORT_GUIDEE.name(): __LIGNE_TRANSPORT_GUIDEE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_50(pyxb.binding.basis.complexTypeDefinition):
    """Liste des horaires des vÃ©hicules guidÃ©s (uniquement le premier vÃ©hicule guidÃ© dans le cas d'un paramÃ©trage de type global)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2585, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element HORAIRE uses Python identifier HORAIRE
    __HORAIRE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'HORAIRE'), 'HORAIRE',
                                                        '__AbsentNamespace0_CTD_ANON_50_HORAIRE', True,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            2587, 24), )

    HORAIRE = property(__HORAIRE.value, __HORAIRE.set, None,
                       "Description d'un horaire de v\xe9hicule guid\xe9 (heure de d\xe9part et dur\xe9e des arr\xeats>")

    _ElementMap.update({
        __HORAIRE.name(): __HORAIRE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_51(pyxb.binding.basis.complexTypeDefinition):
    """DÃ©finition des variations temporelles de frÃ©quence des vÃ©hicules guidÃ©s sur la ligne, en cas de paramÃ¨trage de type 'Global'. L'attribut "frÃ©quence" du NOEUD "LIGNE_TRANSPORT_GUIDEE" sera ignorÃ© si des variations temporelles sotn dÃ©finies ici."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2618, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element FREQUENCE uses Python identifier FREQUENCE
    __FREQUENCE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FREQUENCE'), 'FREQUENCE',
                                                          '__AbsentNamespace0_CTD_ANON_51_FREQUENCE', True,
                                                          pyxb.utils.utility.Location(
                                                              '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                              2620, 24), )

    FREQUENCE = property(__FREQUENCE.value, __FREQUENCE.set, None, None)

    _ElementMap.update({
        __FREQUENCE.name(): __FREQUENCE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_52(pyxb.binding.basis.complexTypeDefinition):
    """Liste des arrÃªts de la ligne"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2707, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element ARRET uses Python identifier ARRET
    __ARRET = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ARRET'), 'ARRET',
                                                      '__AbsentNamespace0_CTD_ANON_52_ARRET', True,
                                                      pyxb.utils.utility.Location(
                                                          '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                          2709, 12), )

    ARRET = property(__ARRET.value, __ARRET.set, None, "Description d'un arr\xeat")

    _ElementMap.update({
        __ARRET.name(): __ARRET
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_53(pyxb.binding.basis.complexTypeDefinition):
    """Liste des variantes temporelles de dÃ©finition du profil des demandes pour l'arrÃªt"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2719, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element LIGNE uses Python identifier LIGNE
    __LIGNE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LIGNE'), 'LIGNE',
                                                      '__AbsentNamespace0_CTD_ANON_53_LIGNE', True,
                                                      pyxb.utils.utility.Location(
                                                          '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                          2721, 24), )

    LIGNE = property(__LIGNE.value, __LIGNE.set, None,
                     'D\xe9finition des param\xe8tres de mont\xe9e pour une ligne donn\xe9e')

    _ElementMap.update({
        __LIGNE.name(): __LIGNE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_54(pyxb.binding.basis.complexTypeDefinition):
    """DÃ©finition des paramÃ¨tres de montÃ©e pour une ligne donnÃ©e"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2725, 26)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element DEMANDE uses Python identifier DEMANDE
    __DEMANDE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DEMANDE'), 'DEMANDE',
                                                        '__AbsentNamespace0_CTD_ANON_54_DEMANDE', True,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            2727, 30), )

    DEMANDE = property(__DEMANDE.value, __DEMANDE.set, None,
                       "D\xe9finition d'une variante temporelle de demande pour la ligne consid\xe9r\xe9e")


    # Attribute ligne uses Python identifier ligne
    __ligne = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'ligne'), 'ligne',
                                                '__AbsentNamespace0_CTD_ANON_54_ligne', pyxb.binding.datatypes.string,
                                                required=True)
    __ligne._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2746, 28)
    __ligne._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2746, 28)

    ligne = property(__ligne.value, __ligne.set, None, 'Identifiant de la ligne concern\xe9e')


    # Attribute stock_initial uses Python identifier stock_initial
    __stock_initial = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'stock_initial'),
                                                        'stock_initial', '__AbsentNamespace0_CTD_ANON_54_stock_initial',
                                                        pyxb.binding.datatypes.nonNegativeInteger, unicode_default='0')
    __stock_initial._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2751, 28)
    __stock_initial._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2751, 28)

    stock_initial = property(__stock_initial.value, __stock_initial.set, None,
                             "Stock initial des pi\xe9tons \xe0 l'arr\xeat pour la ligne consid\xe9r\xe9e")

    _ElementMap.update({
        __DEMANDE.name(): __DEMANDE
    })
    _AttributeMap.update({
        __ligne.name(): __ligne,
        __stock_initial.name(): __stock_initial
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_55(pyxb.binding.basis.complexTypeDefinition):
    """DÃ©finition des paramÃ¨tres de descente des bus pour l'arrÃªt considÃ©rÃ©"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2766, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element LIGNE uses Python identifier LIGNE
    __LIGNE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'LIGNE'), 'LIGNE',
                                                      '__AbsentNamespace0_CTD_ANON_55_LIGNE', True,
                                                      pyxb.utils.utility.Location(
                                                          '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                          2768, 24), )

    LIGNE = property(__LIGNE.value, __LIGNE.set, None,
                     "D\xe9finition des param\xe8tres de descente \xe0 l'arr\xeat et pour la ligne consid\xe9r\xe9e")

    _ElementMap.update({
        __LIGNE.name(): __LIGNE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_56(pyxb.binding.basis.complexTypeDefinition):
    """DÃ©finition des paramÃ¨tres de descente Ã  l'arrÃªt et pour la ligne considÃ©rÃ©e"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2772, 26)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute ligne uses Python identifier ligne
    __ligne = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'ligne'), 'ligne',
                                                '__AbsentNamespace0_CTD_ANON_56_ligne', pyxb.binding.datatypes.string,
                                                required=True)
    __ligne._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2773, 28)
    __ligne._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2773, 28)

    ligne = property(__ligne.value, __ligne.set, None, 'Identifiant de la ligne concern\xe9e')


    # Attribute duree_descente uses Python identifier duree_descente
    __duree_descente = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree_descente'),
                                                         'duree_descente',
                                                         '__AbsentNamespace0_CTD_ANON_56_duree_descente',
                                                         pyxb.binding.datatypes.nonNegativeInteger, unicode_default='0')
    __duree_descente._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2778, 28)
    __duree_descente._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2778, 28)

    duree_descente = property(__duree_descente.value, __duree_descente.set, None,
                              "Dur\xe9e n\xe9cessaire \xe0 la descente pour l'arr\xeat et la ligne consid\xe9r\xe9s")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __ligne.name(): __ligne,
        __duree_descente.name(): __duree_descente
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_57(pyxb.binding.basis.complexTypeDefinition):
    """Liste des capteurs du rÃ©seau"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2858, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element CAPTEUR uses Python identifier CAPTEUR
    __CAPTEUR = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CAPTEUR'), 'CAPTEUR',
                                                        '__AbsentNamespace0_CTD_ANON_57_CAPTEUR', True,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            2860, 12), )

    CAPTEUR = property(__CAPTEUR.value, __CAPTEUR.set, None, None)


    # Element CAPTEUR_LONGITUDINAL uses Python identifier CAPTEUR_LONGITUDINAL
    __CAPTEUR_LONGITUDINAL = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'CAPTEUR_LONGITUDINAL'), 'CAPTEUR_LONGITUDINAL',
        '__AbsentNamespace0_CTD_ANON_57_CAPTEUR_LONGITUDINAL', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2862, 12), )

    CAPTEUR_LONGITUDINAL = property(__CAPTEUR_LONGITUDINAL.value, __CAPTEUR_LONGITUDINAL.set, None, None)


    # Element CAPTEUR_EDIE uses Python identifier CAPTEUR_EDIE
    __CAPTEUR_EDIE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CAPTEUR_EDIE'),
                                                             'CAPTEUR_EDIE',
                                                             '__AbsentNamespace0_CTD_ANON_57_CAPTEUR_EDIE', True,
                                                             pyxb.utils.utility.Location(
                                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                 2864, 12), )

    CAPTEUR_EDIE = property(__CAPTEUR_EDIE.value, __CAPTEUR_EDIE.set, None, None)


    # Element CAPTEUR_MFD uses Python identifier CAPTEUR_MFD
    __CAPTEUR_MFD = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CAPTEUR_MFD'),
                                                            'CAPTEUR_MFD', '__AbsentNamespace0_CTD_ANON_57_CAPTEUR_MFD',
                                                            True, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2866, 12), )

    CAPTEUR_MFD = property(__CAPTEUR_MFD.value, __CAPTEUR_MFD.set, None, None)


    # Element CAPTEUR_BLUETOOTH uses Python identifier CAPTEUR_BLUETOOTH
    __CAPTEUR_BLUETOOTH = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'CAPTEUR_BLUETOOTH'), 'CAPTEUR_BLUETOOTH',
        '__AbsentNamespace0_CTD_ANON_57_CAPTEUR_BLUETOOTH', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2868, 12), )

    CAPTEUR_BLUETOOTH = property(__CAPTEUR_BLUETOOTH.value, __CAPTEUR_BLUETOOTH.set, None, None)

    _ElementMap.update({
        __CAPTEUR.name(): __CAPTEUR,
        __CAPTEUR_LONGITUDINAL.name(): __CAPTEUR_LONGITUDINAL,
        __CAPTEUR_EDIE.name(): __CAPTEUR_EDIE,
        __CAPTEUR_MFD.name(): __CAPTEUR_MFD,
        __CAPTEUR_BLUETOOTH.name(): __CAPTEUR_BLUETOOTH
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_58(pyxb.binding.basis.complexTypeDefinition):
    """Noeud d'accÃ¨s Ã  la liste des plans de feux"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2934, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element PLAN_DE_FEUX uses Python identifier PLAN_DE_FEUX
    __PLAN_DE_FEUX = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PLAN_DE_FEUX'),
                                                             'PLAN_DE_FEUX',
                                                             '__AbsentNamespace0_CTD_ANON_58_PLAN_DE_FEUX', True,
                                                             pyxb.utils.utility.Location(
                                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                 2936, 12), )

    PLAN_DE_FEUX = property(__PLAN_DE_FEUX.value, __PLAN_DE_FEUX.set, None, "Noeud de description d'un plan de feux")

    _ElementMap.update({
        __PLAN_DE_FEUX.name(): __PLAN_DE_FEUX
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_59(pyxb.binding.basis.complexTypeDefinition):
    """Noeud d'accÃ¨s Ã  la liste des sÃ©quences du plan de feux"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2946, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element SEQUENCE uses Python identifier SEQUENCE
    __SEQUENCE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SEQUENCE'), 'SEQUENCE',
                                                         '__AbsentNamespace0_CTD_ANON_59_SEQUENCE', True,
                                                         pyxb.utils.utility.Location(
                                                             '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                             2948, 24), )

    SEQUENCE = property(__SEQUENCE.value, __SEQUENCE.set, None,
                        "Noeud de description d'une s\xe9quence du plan de feux\n")

    _ElementMap.update({
        __SEQUENCE.name(): __SEQUENCE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_60(pyxb.binding.basis.complexTypeDefinition):
    """Noeud d'accÃ¨s Ã  la liste de description des signaux actifs de la sÃ©quence
"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2960, 32)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element SIGNAL_ACTIF uses Python identifier SIGNAL_ACTIF
    __SIGNAL_ACTIF = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SIGNAL_ACTIF'),
                                                             'SIGNAL_ACTIF',
                                                             '__AbsentNamespace0_CTD_ANON_60_SIGNAL_ACTIF', True,
                                                             pyxb.utils.utility.Location(
                                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                 2962, 36), )

    SIGNAL_ACTIF = property(__SIGNAL_ACTIF.value, __SIGNAL_ACTIF.set, None, None)

    _ElementMap.update({
        __SIGNAL_ACTIF.name(): __SIGNAL_ACTIF
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_61(pyxb.binding.basis.complexTypeDefinition):
    """Noeud d'accÃ¨s Ã  la liste des lignes guidÃ©es prioritaires gÃ©rÃ©es par le contrÃ´leur de feux parent
"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3060, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element LIGNE_GUIDEE_PRIORITAIRE uses Python identifier LIGNE_GUIDEE_PRIORITAIRE
    __LIGNE_GUIDEE_PRIORITAIRE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'LIGNE_GUIDEE_PRIORITAIRE'), 'LIGNE_GUIDEE_PRIORITAIRE',
        '__AbsentNamespace0_CTD_ANON_61_LIGNE_GUIDEE_PRIORITAIRE', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3062, 12), )

    LIGNE_GUIDEE_PRIORITAIRE = property(__LIGNE_GUIDEE_PRIORITAIRE.value, __LIGNE_GUIDEE_PRIORITAIRE.set, None, '')

    _ElementMap.update({
        __LIGNE_GUIDEE_PRIORITAIRE.name(): __LIGNE_GUIDEE_PRIORITAIRE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_62(pyxb.binding.basis.complexTypeDefinition):
    """Noeud spÃ©cifique Ã  l'outils de visualisation Symuplayer permettant de paramÃ©trer la position des feux du contrÃ´leur"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3134, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element POSITION_FEU uses Python identifier POSITION_FEU
    __POSITION_FEU = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'POSITION_FEU'),
                                                             'POSITION_FEU',
                                                             '__AbsentNamespace0_CTD_ANON_62_POSITION_FEU', True,
                                                             pyxb.utils.utility.Location(
                                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                 3136, 12), )

    POSITION_FEU = property(__POSITION_FEU.value, __POSITION_FEU.set, None,
                            "Description de la position d'un feu pour une entr\xe9e du contr\xf4leur")

    _ElementMap.update({
        __POSITION_FEU.name(): __POSITION_FEU
    })
    _AttributeMap.update({

    })


# Complex type typeCapteur with content type EMPTY
class typeCapteur(pyxb.binding.basis.complexTypeDefinition):
    """type de base pour les capteurs"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeCapteur')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3217, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeCapteur_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3221, 4)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3221, 4)

    id = property(__id.value, __id.set, None, 'Identifiant du capteur')


    # Attribute troncon uses Python identifier troncon
    __troncon = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'troncon'), 'troncon',
                                                  '__AbsentNamespace0_typeCapteur_troncon',
                                                  pyxb.binding.datatypes.string, required=True)
    __troncon._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3226, 4)
    __troncon._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3226, 4)

    troncon = property(__troncon.value, __troncon.set, None, 'Tron\xe7on sur lequel est positionn\xe9 le capteur')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id.name(): __id,
        __troncon.name(): __troncon
    })


Namespace.addCategoryObject('typeBinding', 'typeCapteur', typeCapteur)


# Complex type typeCapteurMFD with content type ELEMENT_ONLY
class typeCapteurMFD(pyxb.binding.basis.complexTypeDefinition):
    """Capteur d'Edie (possÃ¨de la particularitÃ© de pouvoir s'Ã©tendre sur plusieurs tronÃ§ons)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeCapteurMFD')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3275, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TRONCONS uses Python identifier TRONCONS
    __TRONCONS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRONCONS'), 'TRONCONS',
                                                         '__AbsentNamespace0_typeCapteurMFD_TRONCONS', False,
                                                         pyxb.utils.utility.Location(
                                                             '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                             3280, 6), )

    TRONCONS = property(__TRONCONS.value, __TRONCONS.set, None,
                        'Liste des tron\xe7ons constituant la zone du capteur MFD')


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeCapteurMFD_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3302, 4)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3302, 4)

    id = property(__id.value, __id.set, None, 'Identifiant du capteur')

    _ElementMap.update({
        __TRONCONS.name(): __TRONCONS
    })
    _AttributeMap.update({
        __id.name(): __id
    })


Namespace.addCategoryObject('typeBinding', 'typeCapteurMFD', typeCapteurMFD)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_63(pyxb.binding.basis.complexTypeDefinition):
    """Liste des tronÃ§ons constituant la zone du capteur MFD"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3284, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TRONCON uses Python identifier TRONCON
    __TRONCON = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRONCON'), 'TRONCON',
                                                        '__AbsentNamespace0_CTD_ANON_63_TRONCON', True,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            3286, 12), )

    TRONCON = property(__TRONCON.value, __TRONCON.set, None, 'Troncon appartenant \xe0 la zone MFD')

    _ElementMap.update({
        __TRONCON.name(): __TRONCON
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_64(pyxb.binding.basis.complexTypeDefinition):
    """Troncon appartenant Ã  la zone MFD"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3290, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_64_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3291, 16)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3291, 16)

    id = property(__id.value, __id.set, None, 'Identifiant du tron\xe7on')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id.name(): __id
    })


# Complex type typeCapteurBlueTooth with content type ELEMENT_ONLY
class typeCapteurBlueTooth(pyxb.binding.basis.complexTypeDefinition):
    """Capteur associÃ© Ã  un carrefour Ã  feux ou un rÃ©partiteur et qui permet de mesurer les coefficients directionnels de ce noeud"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeCapteurBlueTooth')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3308, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element POSITION uses Python identifier POSITION
    __POSITION = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'POSITION'), 'POSITION',
                                                         '__AbsentNamespace0_typeCapteurBlueTooth_POSITION', True,
                                                         pyxb.utils.utility.Location(
                                                             '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                             3313, 6), )

    POSITION = property(__POSITION.value, __POSITION.set, None,
                        'Permet de sp\xe9cifier la positione des capteurs ponctuels d\xe9tectant les v\xe9hicules entrants et sortants du noeud (Par d\xe9faut, ces capteurs sont situ\xe9s aux extr\xe9mit\xe9s des tron\xe7ons amont et aval, au niveau du noeud)')


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeCapteurBlueTooth_id',
                                             pyxb.binding.datatypes.string, required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3336, 4)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3336, 4)

    id = property(__id.value, __id.set, None, 'Identifiant du capteur')


    # Attribute connexion uses Python identifier connexion
    __connexion = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'connexion'), 'connexion',
                                                    '__AbsentNamespace0_typeCapteurBlueTooth_connexion',
                                                    pyxb.binding.datatypes.string, required=True)
    __connexion._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3341, 4)
    __connexion._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3341, 4)

    connexion = property(__connexion.value, __connexion.set, None,
                         'Identifiant du CAF ou r\xe9partiteur associ\xe9 au capteur')

    _ElementMap.update({
        __POSITION.name(): __POSITION
    })
    _AttributeMap.update({
        __id.name(): __id,
        __connexion.name(): __connexion
    })


Namespace.addCategoryObject('typeBinding', 'typeCapteurBlueTooth', typeCapteurBlueTooth)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_65(pyxb.binding.basis.complexTypeDefinition):
    """Noeud d'accÃ¨s Ã  la collection des flux par type de vÃ©hicule pour l'extrÃ©mitÃ© courante"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3358, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element FLUX_TYPEVEH uses Python identifier FLUX_TYPEVEH
    __FLUX_TYPEVEH = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FLUX_TYPEVEH'),
                                                             'FLUX_TYPEVEH',
                                                             '__AbsentNamespace0_CTD_ANON_65_FLUX_TYPEVEH', True,
                                                             pyxb.utils.utility.Location(
                                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                 3360, 12), )

    FLUX_TYPEVEH = property(__FLUX_TYPEVEH.value, __FLUX_TYPEVEH.set, None, None)

    _ElementMap.update({
        __FLUX_TYPEVEH.name(): __FLUX_TYPEVEH
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_66(pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3361, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element FLUX uses Python identifier FLUX
    __FLUX = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FLUX'), 'FLUX',
                                                     '__AbsentNamespace0_CTD_ANON_66_FLUX', False,
                                                     pyxb.utils.utility.Location(
                                                         '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                         3363, 18), )

    FLUX = property(__FLUX.value, __FLUX.set, None,
                    "Description du flux pour un type de v\xe9hicule pour l'extr\xe9mit\xe9 courante")


    # Attribute id_typevehicule uses Python identifier id_typevehicule
    __id_typevehicule = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_typevehicule'),
                                                          'id_typevehicule',
                                                          '__AbsentNamespace0_CTD_ANON_66_id_typevehicule',
                                                          pyxb.binding.datatypes.string, required=True)
    __id_typevehicule._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3369, 16)
    __id_typevehicule._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3369, 16)

    id_typevehicule = property(__id_typevehicule.value, __id_typevehicule.set, None,
                               'Identifiant de type de v\xe9hicule associ\xe9 \xe0 la description du flux')

    _ElementMap.update({
        __FLUX.name(): __FLUX
    })
    _AttributeMap.update({
        __id_typevehicule.name(): __id_typevehicule
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_67(pyxb.binding.basis.complexTypeDefinition):
    """Description du caractÃ¨re agressif des vÃ©hicules issus de l'entrÃ©e"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3383, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element AGRESSIVITE uses Python identifier AGRESSIVITE
    __AGRESSIVITE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'AGRESSIVITE'),
                                                            'AGRESSIVITE', '__AbsentNamespace0_CTD_ANON_67_AGRESSIVITE',
                                                            True, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3385, 12), )

    AGRESSIVITE = property(__AGRESSIVITE.value, __AGRESSIVITE.set, None,
                           "Description du caract\xe8re agressif d'une classe de v\xe9hicule pour cette entr\xe9e (par d\xe9faut, le taux de v\xe9hicule agressif d'une classe est 0)\n")

    _ElementMap.update({
        __AGRESSIVITE.name(): __AGRESSIVITE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_68(pyxb.binding.basis.complexTypeDefinition):
    """Liste des vÃ©hicules Ã  crÃ©er"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3446, 12)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element CREATION_VEHICULE uses Python identifier CREATION_VEHICULE
    __CREATION_VEHICULE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'CREATION_VEHICULE'), 'CREATION_VEHICULE',
        '__AbsentNamespace0_CTD_ANON_68_CREATION_VEHICULE', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3448, 16), )

    CREATION_VEHICULE = property(__CREATION_VEHICULE.value, __CREATION_VEHICULE.set, None,
                                 "D\xe9finition d'une cr\xe9ation")

    _ElementMap.update({
        __CREATION_VEHICULE.name(): __CREATION_VEHICULE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_69(pyxb.binding.basis.complexTypeDefinition):
    """Liste des variantes de la capacitÃ© de la sortie. Si cette liste n'existe pas, la sortie est libre."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3490, 12)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element CAPACITE uses Python identifier CAPACITE
    __CAPACITE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CAPACITE'), 'CAPACITE',
                                                         '__AbsentNamespace0_CTD_ANON_69_CAPACITE', True,
                                                         pyxb.utils.utility.Location(
                                                             '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                             3492, 16), )

    CAPACITE = property(__CAPACITE.value, __CAPACITE.set, None, "Description d'une variante de la capacit\xe9")

    _ElementMap.update({
        __CAPACITE.name(): __CAPACITE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_70(pyxb.binding.basis.complexTypeDefinition):
    """Permet la dÃ©finition de types de vÃ©hicules interdits dans le parking"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3522, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'type'), 'type',
                                               '__AbsentNamespace0_CTD_ANON_70_type', pyxb.binding.datatypes.string,
                                               required=True)
    __type._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3523, 10)
    __type._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3523, 10)

    type = property(__type.value, __type.set, None, 'Type de v\xe9hicule interdit')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __type.name(): __type
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_71(pyxb.binding.basis.complexTypeDefinition):
    """Liste des tronÃ§ons dÃ©finissant la zone"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3580, 12)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TRONCON uses Python identifier TRONCON
    __TRONCON = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRONCON'), 'TRONCON',
                                                        '__AbsentNamespace0_CTD_ANON_71_TRONCON', True,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            3582, 16), )

    TRONCON = property(__TRONCON.value, __TRONCON.set, None, 'Tron\xe7on appartenant \xe0 la zone')

    _ElementMap.update({
        __TRONCON.name(): __TRONCON
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_72(pyxb.binding.basis.complexTypeDefinition):
    """TronÃ§on appartenant Ã  la zone"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3586, 18)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_72_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3587, 20)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3587, 20)

    id = property(__id.value, __id.set, None, 'Identifiant du tron\xe7on')


    # Attribute capacite_stationnement uses Python identifier capacite_stationnement
    __capacite_stationnement = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'capacite_stationnement'), 'capacite_stationnement',
        '__AbsentNamespace0_CTD_ANON_72_capacite_stationnement', pyxb.binding.datatypes.double, unicode_default='0')
    __capacite_stationnement._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3592, 20)
    __capacite_stationnement._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3592, 20)

    capacite_stationnement = property(__capacite_stationnement.value, __capacite_stationnement.set, None,
                                      'Capacit\xe9 de stationnement en m\xe8tres. (0 par d\xe9faut, -1 : capacit\xe9 illimit\xe9e)')


    # Attribute stationnement_initial uses Python identifier stationnement_initial
    __stationnement_initial = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'stationnement_initial'), 'stationnement_initial',
        '__AbsentNamespace0_CTD_ANON_72_stationnement_initial', pyxb.binding.datatypes.double, unicode_default='0')
    __stationnement_initial._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3598, 20)
    __stationnement_initial._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3598, 20)

    stationnement_initial = property(__stationnement_initial.value, __stationnement_initial.set, None,
                                     'Valeur de stationnement initiale en m\xe8tres.')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id.name(): __id,
        __capacite_stationnement.name(): __capacite_stationnement,
        __stationnement_initial.name(): __stationnement_initial
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_73(pyxb.binding.basis.complexTypeDefinition):
    """Liste des parkings compris dans la zone"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3612, 12)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element PARKING uses Python identifier PARKING
    __PARKING = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PARKING'), 'PARKING',
                                                        '__AbsentNamespace0_CTD_ANON_73_PARKING', True,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            3614, 16), )

    PARKING = property(__PARKING.value, __PARKING.set, None, 'Parking appartenant \xe0 la zone')


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_73_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3620, 14)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3620, 14)

    id = property(__id.value, __id.set, None, 'Identifiant du groupe de parking')

    _ElementMap.update({
        __PARKING.name(): __PARKING
    })
    _AttributeMap.update({
        __id.name(): __id
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_74(pyxb.binding.basis.complexTypeDefinition):
    """Liste des variantes temporelles de la matrice OD interne Ã  la zone de terminaison"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3631, 12)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element MATRICE_OD_INTERNE uses Python identifier MATRICE_OD_INTERNE
    __MATRICE_OD_INTERNE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'MATRICE_OD_INTERNE'), 'MATRICE_OD_INTERNE',
        '__AbsentNamespace0_CTD_ANON_74_MATRICE_OD_INTERNE', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3633, 16), )

    MATRICE_OD_INTERNE = property(__MATRICE_OD_INTERNE.value, __MATRICE_OD_INTERNE.set, None,
                                  "Description d'une variante de la matrice OD (la somme des coefficients d'affectation pour l'ensemble des destinations d\xe9clar\xe9es doit \xeatre \xe9gale \xe0 1, si une destination n'est pas d\xe9clar\xe9e son coefficient d'affectation est 0 par d\xe9faut)")

    _ElementMap.update({
        __MATRICE_OD_INTERNE.name(): __MATRICE_OD_INTERNE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_75(pyxb.binding.basis.complexTypeDefinition):
    """Liste des vÃ©hicules Ã  crÃ©er"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3668, 12)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element CREATION_VEHICULE uses Python identifier CREATION_VEHICULE
    __CREATION_VEHICULE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'CREATION_VEHICULE'), 'CREATION_VEHICULE',
        '__AbsentNamespace0_CTD_ANON_75_CREATION_VEHICULE', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3670, 16), )

    CREATION_VEHICULE = property(__CREATION_VEHICULE.value, __CREATION_VEHICULE.set, None,
                                 "D\xe9finition d'une cr\xe9ation")

    _ElementMap.update({
        __CREATION_VEHICULE.name(): __CREATION_VEHICULE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_76(pyxb.binding.basis.complexTypeDefinition):
    """DÃ©finition d'une crÃ©ation"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3674, 18)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute instant uses Python identifier instant
    __instant = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'instant'), 'instant',
                                                  '__AbsentNamespace0_CTD_ANON_76_instant',
                                                  pyxb.binding.datatypes.float)
    __instant._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3675, 20)
    __instant._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3675, 20)

    instant = property(__instant.value, __instant.set, None, 'Instant de cr\xe9ation du v\xe9hicule')


    # Attribute typeVehicule uses Python identifier typeVehicule
    __typeVehicule = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'typeVehicule'),
                                                       'typeVehicule', '__AbsentNamespace0_CTD_ANON_76_typeVehicule',
                                                       pyxb.binding.datatypes.string)
    __typeVehicule._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3680, 20)
    __typeVehicule._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3680, 20)

    typeVehicule = property(__typeVehicule.value, __typeVehicule.set, None, 'Type du v\xe9hicule \xe0 cr\xe9er')


    # Attribute destination uses Python identifier destination
    __destination = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'destination'), 'destination',
                                                      '__AbsentNamespace0_CTD_ANON_76_destination',
                                                      pyxb.binding.datatypes.string)
    __destination._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3685, 20)
    __destination._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3685, 20)

    destination = property(__destination.value, __destination.set, None,
                           'Destination du v\xe9hicule cr\xe9\xe9 du v\xe9hicule')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __instant.name(): __instant,
        __typeVehicule.name(): __typeVehicule,
        __destination.name(): __destination
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_77(pyxb.binding.basis.complexTypeDefinition):
    """Liste des variantes des rÃ©partitions des types de vÃ©hicule"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3699, 12)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element REPARTITION_TYPEVEHICULE uses Python identifier REPARTITION_TYPEVEHICULE
    __REPARTITION_TYPEVEHICULE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'REPARTITION_TYPEVEHICULE'), 'REPARTITION_TYPEVEHICULE',
        '__AbsentNamespace0_CTD_ANON_77_REPARTITION_TYPEVEHICULE', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3701, 16), )

    REPARTITION_TYPEVEHICULE = property(__REPARTITION_TYPEVEHICULE.value, __REPARTITION_TYPEVEHICULE.set, None,
                                        "Description d'une variante d'une r\xe9partition des types de v\xe9hicule")

    _ElementMap.update({
        __REPARTITION_TYPEVEHICULE.name(): __REPARTITION_TYPEVEHICULE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_78(pyxb.binding.basis.complexTypeDefinition):
    """Liste des coefficients de rÃ©partition de la demande sur les diffÃ©rents Ã©lÃ©ments de la zone d'origine (groupes de parkings et tronÃ§ons avec stationnement)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3725, 12)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element ORIGINE uses Python identifier ORIGINE
    __ORIGINE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ORIGINE'), 'ORIGINE',
                                                        '__AbsentNamespace0_CTD_ANON_78_ORIGINE', True,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            3727, 16), )

    ORIGINE = property(__ORIGINE.value, __ORIGINE.set, None,
                       "D\xe9finition du coefficient d'affectation associ\xe9 \xe0 une origine")

    _ElementMap.update({
        __ORIGINE.name(): __ORIGINE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_79(pyxb.binding.basis.complexTypeDefinition):
    """Ensemble des dÃ©tecteurs associÃ©s Ã  la brique de rÃ©gulation"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3810, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element CAPTEUR uses Python identifier CAPTEUR
    __CAPTEUR = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CAPTEUR'), 'CAPTEUR',
                                                        '__AbsentNamespace0_CTD_ANON_79_CAPTEUR', True,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            3812, 12), )

    CAPTEUR = property(__CAPTEUR.value, __CAPTEUR.set, None, 'Capteur associ\xe9 \xe0 la brique de r\xe9gulation')

    _ElementMap.update({
        __CAPTEUR.name(): __CAPTEUR
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_80(pyxb.binding.basis.complexTypeDefinition):
    """Capteur associÃ© Ã  la brique de rÃ©gulation"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3816, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element PARAMETRES uses Python identifier PARAMETRES
    __PARAMETRES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PARAMETRES'),
                                                           'PARAMETRES', '__AbsentNamespace0_CTD_ANON_80_PARAMETRES',
                                                           False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3818, 18), )

    PARAMETRES = property(__PARAMETRES.value, __PARAMETRES.set, None,
                          'D\xe9finition des param\xe8tres n\xe9cessaire \xe0 la fonction d\xe9finie pour le capteur')


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_80_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3824, 16)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3824, 16)

    id = property(__id.value, __id.set, None, 'Identifiant du capteur')


    # Attribute fonction uses Python identifier fonction
    __fonction = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'fonction'), 'fonction',
                                                   '__AbsentNamespace0_CTD_ANON_80_fonction',
                                                   pyxb.binding.datatypes.string, required=True)
    __fonction._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3829, 16)
    __fonction._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3829, 16)

    fonction = property(__fonction.value, __fonction.set, None, 'Fonction du capteur')


    # Attribute module uses Python identifier module
    __module = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'module'), 'module',
                                                 '__AbsentNamespace0_CTD_ANON_80_module', pyxb.binding.datatypes.string)
    __module._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3834, 16)
    __module._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3834, 16)

    module = property(__module.value, __module.set, None,
                      "Chemin du fichier python contenant la fonction, uniquement s'il s'agit d'une fonction non incluse dans les scripts fournis avec symubruit")

    _ElementMap.update({
        __PARAMETRES.name(): __PARAMETRES
    })
    _AttributeMap.update({
        __id.name(): __id,
        __fonction.name(): __fonction,
        __module.name(): __module
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_81(pyxb.binding.basis.complexTypeDefinition):
    """Ensemble des dÃ©clencheurs associÃ©s Ã  la brique de rÃ©gulation"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3848, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element CONDITION uses Python identifier CONDITION
    __CONDITION = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CONDITION'), 'CONDITION',
                                                          '__AbsentNamespace0_CTD_ANON_81_CONDITION', True,
                                                          pyxb.utils.utility.Location(
                                                              '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                              3850, 12), )

    CONDITION = property(__CONDITION.value, __CONDITION.set, None,
                         "Condition de d\xe9clenchement d'actions associ\xe9e \xe0 la brique de r\xe9gulation")

    _ElementMap.update({
        __CONDITION.name(): __CONDITION
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_82(pyxb.binding.basis.complexTypeDefinition):
    """Condition de dÃ©clenchement d'actions associÃ©e Ã  la brique de rÃ©gulation"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3854, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element PARAMETRES uses Python identifier PARAMETRES
    __PARAMETRES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PARAMETRES'),
                                                           'PARAMETRES', '__AbsentNamespace0_CTD_ANON_82_PARAMETRES',
                                                           False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3856, 18), )

    PARAMETRES = property(__PARAMETRES.value, __PARAMETRES.set, None,
                          'D\xe9finition des param\xe8tres n\xe9cessaire \xe0 la fonction d\xe9finie pour la condition')


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_82_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3862, 16)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3862, 16)

    id = property(__id.value, __id.set, None, 'Identifiant de la condition')


    # Attribute fonction uses Python identifier fonction
    __fonction = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'fonction'), 'fonction',
                                                   '__AbsentNamespace0_CTD_ANON_82_fonction',
                                                   pyxb.binding.datatypes.string, required=True)
    __fonction._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3867, 16)
    __fonction._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3867, 16)

    fonction = property(__fonction.value, __fonction.set, None, 'Fonction de la condition')


    # Attribute module uses Python identifier module
    __module = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'module'), 'module',
                                                 '__AbsentNamespace0_CTD_ANON_82_module', pyxb.binding.datatypes.string)
    __module._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3872, 16)
    __module._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3872, 16)

    module = property(__module.value, __module.set, None,
                      "Chemin du fichier python contenant la fonction, uniquement s'il s'agit d'une fonction non incluse dans les scripts fournis avec symubruit")

    _ElementMap.update({
        __PARAMETRES.name(): __PARAMETRES
    })
    _AttributeMap.update({
        __id.name(): __id,
        __fonction.name(): __fonction,
        __module.name(): __module
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_83(pyxb.binding.basis.complexTypeDefinition):
    """Ensemble des actions associÃ©es Ã  la brique de rÃ©gulation"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3886, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element ACTION uses Python identifier ACTION
    __ACTION = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ACTION'), 'ACTION',
                                                       '__AbsentNamespace0_CTD_ANON_83_ACTION', True,
                                                       pyxb.utils.utility.Location(
                                                           '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                           3888, 12), )

    ACTION = property(__ACTION.value, __ACTION.set, None, 'Action associ\xe9e \xe0 la brique de r\xe9gulation')

    _ElementMap.update({
        __ACTION.name(): __ACTION
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_84(pyxb.binding.basis.complexTypeDefinition):
    """Action associÃ©e Ã  la brique de rÃ©gulation"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3892, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element PARAMETRES uses Python identifier PARAMETRES
    __PARAMETRES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PARAMETRES'),
                                                           'PARAMETRES', '__AbsentNamespace0_CTD_ANON_84_PARAMETRES',
                                                           False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3894, 18), )

    PARAMETRES = property(__PARAMETRES.value, __PARAMETRES.set, None,
                          "D\xe9finition des param\xe8tres n\xe9cessaire \xe0 la fonction d\xe9finie pour l'action")


    # Attribute conditions uses Python identifier conditions
    __conditions = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'conditions'), 'conditions',
                                                     '__AbsentNamespace0_CTD_ANON_84_conditions',
                                                     pyxb.binding.datatypes.string)
    __conditions._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3900, 16)
    __conditions._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3900, 16)

    conditions = property(__conditions.value, __conditions.set, None,
                          "Liste des identifiants des conditions n\xe9cessaires \xe0 l'ex\xe9cution de l'action")


    # Attribute fonction uses Python identifier fonction
    __fonction = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'fonction'), 'fonction',
                                                   '__AbsentNamespace0_CTD_ANON_84_fonction',
                                                   pyxb.binding.datatypes.string, required=True)
    __fonction._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3905, 16)
    __fonction._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3905, 16)

    fonction = property(__fonction.value, __fonction.set, None, "Fonction de l'action")


    # Attribute module uses Python identifier module
    __module = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'module'), 'module',
                                                 '__AbsentNamespace0_CTD_ANON_84_module', pyxb.binding.datatypes.string)
    __module._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3910, 16)
    __module._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3910, 16)

    module = property(__module.value, __module.set, None,
                      "Chemin du fichier python contenant la fonction, uniquement s'il s'agit d'une fonction non incluse dans les scripts fournis avec symubruit")

    _ElementMap.update({
        __PARAMETRES.name(): __PARAMETRES
    })
    _AttributeMap.update({
        __conditions.name(): __conditions,
        __fonction.name(): __fonction,
        __module.name(): __module
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_85(pyxb.binding.basis.complexTypeDefinition):
    """Ensemble des dÃ©finitions de restitution dans le fichier de sortie pour la brique de rÃ©gulation"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3924, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element RESTITUTION uses Python identifier RESTITUTION
    __RESTITUTION = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RESTITUTION'),
                                                            'RESTITUTION', '__AbsentNamespace0_CTD_ANON_85_RESTITUTION',
                                                            True, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3926, 12), )

    RESTITUTION = property(__RESTITUTION.value, __RESTITUTION.set, None,
                           'D\xe9finition des sorties \xe0 produire dans le fichier de sortie poru la brique de r\xe9gulation')

    _ElementMap.update({
        __RESTITUTION.name(): __RESTITUTION
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_86(pyxb.binding.basis.complexTypeDefinition):
    """DÃ©finition des sorties Ã  produire dans le fichier de sortie poru la brique de rÃ©gulation"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3930, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element PARAMETRES uses Python identifier PARAMETRES
    __PARAMETRES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PARAMETRES'),
                                                           'PARAMETRES', '__AbsentNamespace0_CTD_ANON_86_PARAMETRES',
                                                           False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3932, 18), )

    PARAMETRES = property(__PARAMETRES.value, __PARAMETRES.set, None,
                          'D\xe9finition des param\xe8tres n\xe9cessaire \xe0 la fonction d\xe9finie pour la restitution')


    # Attribute fonction uses Python identifier fonction
    __fonction = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'fonction'), 'fonction',
                                                   '__AbsentNamespace0_CTD_ANON_86_fonction',
                                                   pyxb.binding.datatypes.string, required=True)
    __fonction._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3938, 16)
    __fonction._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3938, 16)

    fonction = property(__fonction.value, __fonction.set, None, 'Fonction de la resitution')


    # Attribute module uses Python identifier module
    __module = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'module'), 'module',
                                                 '__AbsentNamespace0_CTD_ANON_86_module', pyxb.binding.datatypes.string)
    __module._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3943, 16)
    __module._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3943, 16)

    module = property(__module.value, __module.set, None,
                      "Chemin du fichier python contenant la fonction, uniquement s'il s'agit d'une fonction non incluse dans les scripts fournis avec symubruit")

    _ElementMap.update({
        __PARAMETRES.name(): __PARAMETRES
    })
    _AttributeMap.update({
        __fonction.name(): __fonction,
        __module.name(): __module
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_87(pyxb.binding.basis.complexTypeDefinition):
    """Noeud racine des donnÃ©es d'entrÃ©e de la plateforme SymuVia"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3969, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element PLAGES_TEMPORELLES uses Python identifier PLAGES_TEMPORELLES
    __PLAGES_TEMPORELLES = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'PLAGES_TEMPORELLES'), 'PLAGES_TEMPORELLES',
        '__AbsentNamespace0_CTD_ANON_87_PLAGES_TEMPORELLES', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3971, 8), )

    PLAGES_TEMPORELLES = property(__PLAGES_TEMPORELLES.value, __PLAGES_TEMPORELLES.set, None,
                                  'Ensemble des plages temporelles d\xe9finies pour l\'ensemble de la ou des simulations, dont l\'ID peut \xeatre utilis\xe9 pour renseigner la plage de validit\xe9 des variantes temporelles (attributs "duree" de certains \xe9l\xe9ments)')


    # Element SIMULATIONS uses Python identifier SIMULATIONS
    __SIMULATIONS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SIMULATIONS'),
                                                            'SIMULATIONS', '__AbsentNamespace0_CTD_ANON_87_SIMULATIONS',
                                                            False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4026, 8), )

    SIMULATIONS = property(__SIMULATIONS.value, __SIMULATIONS.set, None,
                           'Liste des d\xe9finitions de param\xe8tres de simulation')


    # Element TRAFICS uses Python identifier TRAFICS
    __TRAFICS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRAFICS'), 'TRAFICS',
                                                        '__AbsentNamespace0_CTD_ANON_87_TRAFICS', False,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            4045, 8), )

    TRAFICS = property(__TRAFICS.value, __TRAFICS.set, None, 'Liste des d\xe9finitions de param\xe8tres de trafic')


    # Element RESEAUX uses Python identifier RESEAUX
    __RESEAUX = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RESEAUX'), 'RESEAUX',
                                                        '__AbsentNamespace0_CTD_ANON_87_RESEAUX', False,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            4064, 8), )

    RESEAUX = property(__RESEAUX.value, __RESEAUX.set, None, 'Liste des d\xe9finitions de r\xe9seaux')


    # Element SCENARIOS uses Python identifier SCENARIOS
    __SCENARIOS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SCENARIOS'), 'SCENARIOS',
                                                          '__AbsentNamespace0_CTD_ANON_87_SCENARIOS', False,
                                                          pyxb.utils.utility.Location(
                                                              '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                              4417, 8), )

    SCENARIOS = property(__SCENARIOS.value, __SCENARIOS.set, None, 'Liste des d\xe9finitions de sc\xe9narios')


    # Attribute version uses Python identifier version
    __version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'version'), 'version',
                                                  '__AbsentNamespace0_CTD_ANON_87_version',
                                                  pyxb.binding.datatypes.string, required=True)
    __version._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4464, 6)
    __version._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4464, 6)

    version = property(__version.value, __version.set, None,
                       'Num\xe9ro de version de format des donn\xe9es initiales de Symubruit')

    _ElementMap.update({
        __PLAGES_TEMPORELLES.name(): __PLAGES_TEMPORELLES,
        __SIMULATIONS.name(): __SIMULATIONS,
        __TRAFICS.name(): __TRAFICS,
        __RESEAUX.name(): __RESEAUX,
        __SCENARIOS.name(): __SCENARIOS
    })
    _AttributeMap.update({
        __version.name(): __version
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_88(pyxb.binding.basis.complexTypeDefinition):
    """Plage temporelle pouvant Ãªtre utilisÃ©e en mode "horaire" pour renseigner la plage de validitÃ© des variantes temporelles (attributs "duree" de certains Ã©lÃ©ments)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3981, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_88_id', pyxb.binding.datatypes.ID,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3982, 18)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3982, 18)

    id = property(__id.value, __id.set, None, 'identifiant de la plage temporelle')


    # Attribute debut uses Python identifier debut
    __debut = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'debut'), 'debut',
                                                '__AbsentNamespace0_CTD_ANON_88_debut', pyxb.binding.datatypes.time,
                                                required=True)
    __debut._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3987, 18)
    __debut._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3987, 18)

    debut = property(__debut.value, __debut.set, None, 'date de d\xe9but de la plage temporelle (hh:mm:ss)')


    # Attribute fin uses Python identifier fin
    __fin = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'fin'), 'fin',
                                              '__AbsentNamespace0_CTD_ANON_88_fin', pyxb.binding.datatypes.time,
                                              required=True)
    __fin._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3992, 18)
    __fin._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3992, 18)

    fin = property(__fin.value, __fin.set, None, 'date de fin de la plage temporelle (hh:mm:ss)')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id.name(): __id,
        __debut.name(): __debut,
        __fin.name(): __fin
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_89(pyxb.binding.basis.complexTypeDefinition):
    """Liste des dÃ©finitions de paramÃ¨tres de simulation"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4030, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element SIMULATION uses Python identifier SIMULATION
    __SIMULATION = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SIMULATION'),
                                                           'SIMULATION', '__AbsentNamespace0_CTD_ANON_89_SIMULATION',
                                                           True, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4032, 14), )

    SIMULATION = property(__SIMULATION.value, __SIMULATION.set, None, 'Param\xe9trage de la simulation')

    _ElementMap.update({
        __SIMULATION.name(): __SIMULATION
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_90(pyxb.binding.basis.complexTypeDefinition):
    """Liste des dÃ©finitions de paramÃ¨tres de trafic"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4049, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TRAFIC uses Python identifier TRAFIC
    __TRAFIC = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRAFIC'), 'TRAFIC',
                                                       '__AbsentNamespace0_CTD_ANON_90_TRAFIC', True,
                                                       pyxb.utils.utility.Location(
                                                           '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                           4051, 14), )

    TRAFIC = property(__TRAFIC.value, __TRAFIC.set, None, 'Param\xe9trage du trafic')

    _ElementMap.update({
        __TRAFIC.name(): __TRAFIC
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_91(pyxb.binding.basis.complexTypeDefinition):
    """Liste des dÃ©finitions de rÃ©seaux"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4068, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element RESEAU uses Python identifier RESEAU
    __RESEAU = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RESEAU'), 'RESEAU',
                                                       '__AbsentNamespace0_CTD_ANON_91_RESEAU', True,
                                                       pyxb.utils.utility.Location(
                                                           '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                           4070, 14), )

    RESEAU = property(__RESEAU.value, __RESEAU.set, None, 'Donn\xe9es du r\xe9seau')

    _ElementMap.update({
        __RESEAU.name(): __RESEAU
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_92(pyxb.binding.basis.complexTypeDefinition):
    """DonnÃ©es du rÃ©seau"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4074, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TRONCONS uses Python identifier TRONCONS
    __TRONCONS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRONCONS'), 'TRONCONS',
                                                         '__AbsentNamespace0_CTD_ANON_92_TRONCONS', False,
                                                         pyxb.utils.utility.Location(
                                                             '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                             4076, 20), )

    TRONCONS = property(__TRONCONS.value, __TRONCONS.set, None, 'Liste des tron\xe7ons')


    # Element CONNEXIONS uses Python identifier CONNEXIONS
    __CONNEXIONS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CONNEXIONS'),
                                                           'CONNEXIONS', '__AbsentNamespace0_CTD_ANON_92_CONNEXIONS',
                                                           False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4090, 20), )

    CONNEXIONS = property(__CONNEXIONS.value, __CONNEXIONS.set, None, 'Noeud ')


    # Element ZONES_DE_TERMINAISON uses Python identifier ZONES_DE_TERMINAISON
    __ZONES_DE_TERMINAISON = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'ZONES_DE_TERMINAISON'), 'ZONES_DE_TERMINAISON',
        '__AbsentNamespace0_CTD_ANON_92_ZONES_DE_TERMINAISON', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4201, 20), )

    ZONES_DE_TERMINAISON = property(__ZONES_DE_TERMINAISON.value, __ZONES_DE_TERMINAISON.set, None,
                                    'Liste des zones de terminaison')


    # Element PARAMETRAGE_VEHICULES_GUIDES uses Python identifier PARAMETRAGE_VEHICULES_GUIDES
    __PARAMETRAGE_VEHICULES_GUIDES = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'PARAMETRAGE_VEHICULES_GUIDES'), 'PARAMETRAGE_VEHICULES_GUIDES',
        '__AbsentNamespace0_CTD_ANON_92_PARAMETRAGE_VEHICULES_GUIDES', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4223, 20), )

    PARAMETRAGE_VEHICULES_GUIDES = property(__PARAMETRAGE_VEHICULES_GUIDES.value, __PARAMETRAGE_VEHICULES_GUIDES.set,
                                            None, 'Param\xe9trage des v\xe9hicules guid\xe9s du r\xe9seau')


    # Element ROUTES uses Python identifier ROUTES
    __ROUTES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ROUTES'), 'ROUTES',
                                                       '__AbsentNamespace0_CTD_ANON_92_ROUTES', False,
                                                       pyxb.utils.utility.Location(
                                                           '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                           4228, 20), )

    ROUTES = property(__ROUTES.value, __ROUTES.set, None, "Liste d'itin\xe9raires du r\xe9seau")


    # Element COORD_REFS uses Python identifier COORD_REFS
    __COORD_REFS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'COORD_REFS'),
                                                           'COORD_REFS', '__AbsentNamespace0_CTD_ANON_92_COORD_REFS',
                                                           False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4277, 20), )

    COORD_REFS = property(__COORD_REFS.value, __COORD_REFS.set, None,
                          'Liste des r\xe9f\xe9rentiels de coordonn\xe9es g\xe9ographiques utilis\xe9s\n')


    # Element INIT uses Python identifier INIT
    __INIT = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'INIT'), 'INIT',
                                                     '__AbsentNamespace0_CTD_ANON_92_INIT', False,
                                                     pyxb.utils.utility.Location(
                                                         '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                         4331, 20), )

    INIT = property(__INIT.value, __INIT.set, None,
                    "Initialisation du r\xe9seau par une liste de v\xe9hicule pr\xe9sent sur le r\xe9seau \xe0 l'instant 0")


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_92_id', pyxb.binding.datatypes.ID,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4407, 18)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4407, 18)

    id = property(__id.value, __id.set, None, 'Identifiant de la section RESEAU')

    _ElementMap.update({
        __TRONCONS.name(): __TRONCONS,
        __CONNEXIONS.name(): __CONNEXIONS,
        __ZONES_DE_TERMINAISON.name(): __ZONES_DE_TERMINAISON,
        __PARAMETRAGE_VEHICULES_GUIDES.name(): __PARAMETRAGE_VEHICULES_GUIDES,
        __ROUTES.name(): __ROUTES,
        __COORD_REFS.name(): __COORD_REFS,
        __INIT.name(): __INIT
    })
    _AttributeMap.update({
        __id.name(): __id
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_93(pyxb.binding.basis.complexTypeDefinition):
    """Liste des tronÃ§ons"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4080, 22)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TRONCON uses Python identifier TRONCON
    __TRONCON = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRONCON'), 'TRONCON',
                                                        '__AbsentNamespace0_CTD_ANON_93_TRONCON', True,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            4082, 26), )

    TRONCON = property(__TRONCON.value, __TRONCON.set, None, "Description d'un tron\xe7on")

    _ElementMap.update({
        __TRONCON.name(): __TRONCON
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_94(pyxb.binding.basis.complexTypeDefinition):
    """Noeud """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4094, 22)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element EXTREMITES uses Python identifier EXTREMITES
    __EXTREMITES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'EXTREMITES'),
                                                           'EXTREMITES', '__AbsentNamespace0_CTD_ANON_94_EXTREMITES',
                                                           False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4096, 26), )

    EXTREMITES = property(__EXTREMITES.value, __EXTREMITES.set, None,
                          'Liste des extr\xe9mit\xe9s (anciennement entr\xe9es et sorties)')


    # Element PARKINGS uses Python identifier PARKINGS
    __PARKINGS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PARKINGS'), 'PARKINGS',
                                                         '__AbsentNamespace0_CTD_ANON_94_PARKINGS', False,
                                                         pyxb.utils.utility.Location(
                                                             '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                             4117, 26), )

    PARKINGS = property(__PARKINGS.value, __PARKINGS.set, None, 'Liste des parkings')


    # Element REPARTITEURS uses Python identifier REPARTITEURS
    __REPARTITEURS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'REPARTITEURS'),
                                                             'REPARTITEURS',
                                                             '__AbsentNamespace0_CTD_ANON_94_REPARTITEURS', False,
                                                             pyxb.utils.utility.Location(
                                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                 4138, 26), )

    REPARTITEURS = property(__REPARTITEURS.value, __REPARTITEURS.set, None, 'Liste des r\xe9partiteurs')


    # Element CONVERGENTS uses Python identifier CONVERGENTS
    __CONVERGENTS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CONVERGENTS'),
                                                            'CONVERGENTS', '__AbsentNamespace0_CTD_ANON_94_CONVERGENTS',
                                                            False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4153, 26), )

    CONVERGENTS = property(__CONVERGENTS.value, __CONVERGENTS.set, None, 'Liste des convergents')


    # Element GIRATOIRES uses Python identifier GIRATOIRES
    __GIRATOIRES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'GIRATOIRES'),
                                                           'GIRATOIRES', '__AbsentNamespace0_CTD_ANON_94_GIRATOIRES',
                                                           False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4168, 26), )

    GIRATOIRES = property(__GIRATOIRES.value, __GIRATOIRES.set, None, 'Liste des giratoires')


    # Element CARREFOURSAFEUX uses Python identifier CARREFOURSAFEUX
    __CARREFOURSAFEUX = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CARREFOURSAFEUX'),
                                                                'CARREFOURSAFEUX',
                                                                '__AbsentNamespace0_CTD_ANON_94_CARREFOURSAFEUX', False,
                                                                pyxb.utils.utility.Location(
                                                                    '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                    4183, 26), )

    CARREFOURSAFEUX = property(__CARREFOURSAFEUX.value, __CARREFOURSAFEUX.set, None, 'Liste des carrefours \xe0 feux')

    _ElementMap.update({
        __EXTREMITES.name(): __EXTREMITES,
        __PARKINGS.name(): __PARKINGS,
        __REPARTITEURS.name(): __REPARTITEURS,
        __CONVERGENTS.name(): __CONVERGENTS,
        __GIRATOIRES.name(): __GIRATOIRES,
        __CARREFOURSAFEUX.name(): __CARREFOURSAFEUX
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_95(pyxb.binding.basis.complexTypeDefinition):
    """Liste des extrÃ©mitÃ©s (anciennement entrÃ©es et sorties)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4100, 28)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element EXTREMITE uses Python identifier EXTREMITE
    __EXTREMITE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'EXTREMITE'), 'EXTREMITE',
                                                          '__AbsentNamespace0_CTD_ANON_95_EXTREMITE', True,
                                                          pyxb.utils.utility.Location(
                                                              '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                              4102, 32), )

    EXTREMITE = property(__EXTREMITE.value, __EXTREMITE.set, None, "Description d'une extremit\xe9 du r\xe9seau")

    _ElementMap.update({
        __EXTREMITE.name(): __EXTREMITE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_96(pyxb.binding.basis.complexTypeDefinition):
    """Description d'une extremitÃ© du rÃ©seau"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4106, 34)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_96_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4107, 36)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4107, 36)

    id = property(__id.value, __id.set, None, "Identifiant de l'extremit\xe9")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id.name(): __id
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_97(pyxb.binding.basis.complexTypeDefinition):
    """Liste des parkings"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4121, 28)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element PARKING uses Python identifier PARKING
    __PARKING = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PARKING'), 'PARKING',
                                                        '__AbsentNamespace0_CTD_ANON_97_PARKING', True,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            4123, 32), )

    PARKING = property(__PARKING.value, __PARKING.set, None, "Description d'un parking du r\xe9seau")

    _ElementMap.update({
        __PARKING.name(): __PARKING
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_98(pyxb.binding.basis.complexTypeDefinition):
    """Description d'un parking du rÃ©seau"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4127, 34)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_98_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4128, 36)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4128, 36)

    id = property(__id.value, __id.set, None, 'Identifiant du parking')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id.name(): __id
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_99(pyxb.binding.basis.complexTypeDefinition):
    """Liste des rÃ©partiteurs"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4142, 28)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element REPARTITEUR uses Python identifier REPARTITEUR
    __REPARTITEUR = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'REPARTITEUR'),
                                                            'REPARTITEUR', '__AbsentNamespace0_CTD_ANON_99_REPARTITEUR',
                                                            True, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4144, 32), )

    REPARTITEUR = property(__REPARTITEUR.value, __REPARTITEUR.set, None, "Description d'un r\xe9partiteur")

    _ElementMap.update({
        __REPARTITEUR.name(): __REPARTITEUR
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_100(pyxb.binding.basis.complexTypeDefinition):
    """Liste des convergents"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4157, 28)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element CONVERGENT uses Python identifier CONVERGENT
    __CONVERGENT = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CONVERGENT'),
                                                           'CONVERGENT', '__AbsentNamespace0_CTD_ANON_100_CONVERGENT',
                                                           True, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4159, 32), )

    CONVERGENT = property(__CONVERGENT.value, __CONVERGENT.set, None, "Description d'un convergent")

    _ElementMap.update({
        __CONVERGENT.name(): __CONVERGENT
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_101(pyxb.binding.basis.complexTypeDefinition):
    """Liste des giratoires"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4172, 28)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element GIRATOIRE uses Python identifier GIRATOIRE
    __GIRATOIRE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'GIRATOIRE'), 'GIRATOIRE',
                                                          '__AbsentNamespace0_CTD_ANON_101_GIRATOIRE', True,
                                                          pyxb.utils.utility.Location(
                                                              '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                              4174, 32), )

    GIRATOIRE = property(__GIRATOIRE.value, __GIRATOIRE.set, None, "Description d'un r\xe9partiteur")

    _ElementMap.update({
        __GIRATOIRE.name(): __GIRATOIRE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_102(pyxb.binding.basis.complexTypeDefinition):
    """Liste des carrefours Ã  feux"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4187, 28)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element CARREFOURAFEUX uses Python identifier CARREFOURAFEUX
    __CARREFOURAFEUX = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CARREFOURAFEUX'),
                                                               'CARREFOURAFEUX',
                                                               '__AbsentNamespace0_CTD_ANON_102_CARREFOURAFEUX', True,
                                                               pyxb.utils.utility.Location(
                                                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                   4189, 32), )

    CARREFOURAFEUX = property(__CARREFOURAFEUX.value, __CARREFOURAFEUX.set, None,
                              "Description d'un carrefour \xe0 feux")

    _ElementMap.update({
        __CARREFOURAFEUX.name(): __CARREFOURAFEUX
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_103(pyxb.binding.basis.complexTypeDefinition):
    """Liste des zones de terminaison"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4205, 22)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element ZONE_DE_TERMINAISON uses Python identifier ZONE_DE_TERMINAISON
    __ZONE_DE_TERMINAISON = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'ZONE_DE_TERMINAISON'), 'ZONE_DE_TERMINAISON',
        '__AbsentNamespace0_CTD_ANON_103_ZONE_DE_TERMINAISON', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4207, 26), )

    ZONE_DE_TERMINAISON = property(__ZONE_DE_TERMINAISON.value, __ZONE_DE_TERMINAISON.set, None,
                                   "Description d'une zone de terminaison")

    _ElementMap.update({
        __ZONE_DE_TERMINAISON.name(): __ZONE_DE_TERMINAISON
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_104(pyxb.binding.basis.complexTypeDefinition):
    """Description d'une zone de terminaison"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4212, 28)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_104_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4213, 30)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4213, 30)

    id = property(__id.value, __id.set, None, 'Identifiant de la zone de terminaison')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id.name(): __id
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_105(pyxb.binding.basis.complexTypeDefinition):
    """Liste d'itinÃ©raires du rÃ©seau"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4232, 22)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element ROUTE uses Python identifier ROUTE
    __ROUTE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ROUTE'), 'ROUTE',
                                                      '__AbsentNamespace0_CTD_ANON_105_ROUTE', True,
                                                      pyxb.utils.utility.Location(
                                                          '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                          4234, 26), )

    ROUTE = property(__ROUTE.value, __ROUTE.set, None, "Description d'un itin\xe9raire du r\xe9seau")

    _ElementMap.update({
        __ROUTE.name(): __ROUTE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_106(pyxb.binding.basis.complexTypeDefinition):
    """Description d'un itinÃ©raire du rÃ©seau"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4238, 28)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TRONCONS_ uses Python identifier TRONCONS
    __TRONCONS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRONCONS_'), 'TRONCONS',
                                                         '__AbsentNamespace0_CTD_ANON_106_TRONCONS', False,
                                                         pyxb.utils.utility.Location(
                                                             '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                             4240, 32), )

    TRONCONS = property(__TRONCONS.value, __TRONCONS.set, None,
                        "Liste ordonn\xe9e des tron\xe7ons composant l'itin\xe9raire")


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_106_id', pyxb.binding.datatypes.ID,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4262, 30)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4262, 30)

    id = property(__id.value, __id.set, None, "Identifiant unique de l'itin\xe9raire")


    # Attribute description uses Python identifier description
    __description = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'description'), 'description',
                                                      '__AbsentNamespace0_CTD_ANON_106_description',
                                                      pyxb.binding.datatypes.string)
    __description._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4267, 30)
    __description._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4267, 30)

    description = property(__description.value, __description.set, None, "Description de l'itin\xe9raire")

    _ElementMap.update({
        __TRONCONS.name(): __TRONCONS
    })
    _AttributeMap.update({
        __id.name(): __id,
        __description.name(): __description
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_107(pyxb.binding.basis.complexTypeDefinition):
    """Liste ordonnÃ©e des tronÃ§ons composant l'itinÃ©raire"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4244, 34)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TRONCON_ uses Python identifier TRONCON
    __TRONCON = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRONCON_'), 'TRONCON',
                                                        '__AbsentNamespace0_CTD_ANON_107_TRONCON', True,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            4246, 38), )

    TRONCON = property(__TRONCON.value, __TRONCON.set, None, "Tron\xe7on de l'itin\xe9raire")

    _ElementMap.update({
        __TRONCON.name(): __TRONCON
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_108(pyxb.binding.basis.complexTypeDefinition):
    """TronÃ§on de l'itinÃ©raire"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4250, 40)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_108_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4251, 42)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4251, 42)

    id = property(__id.value, __id.set, None, 'Identifiant du tron\xe7on')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id.name(): __id
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_109(pyxb.binding.basis.complexTypeDefinition):
    """Liste des rÃ©fÃ©rentiels de coordonnÃ©es gÃ©ographiques utilisÃ©s
"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4282, 22)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element COORD_REF uses Python identifier COORD_REF
    __COORD_REF = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'COORD_REF'), 'COORD_REF',
                                                          '__AbsentNamespace0_CTD_ANON_109_COORD_REF', True,
                                                          pyxb.utils.utility.Location(
                                                              '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                              4284, 26), )

    COORD_REF = property(__COORD_REF.value, __COORD_REF.set, None,
                         "Description d'un r\xe9f\xe9renciel g\xe9ographiqe\n")

    _ElementMap.update({
        __COORD_REF.name(): __COORD_REF
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_110(pyxb.binding.basis.complexTypeDefinition):
    """Description d'un rÃ©fÃ©renciel gÃ©ographiqe
"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4289, 28)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element COORD_MAP uses Python identifier COORD_MAP
    __COORD_MAP = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'COORD_MAP'), 'COORD_MAP',
                                                          '__AbsentNamespace0_CTD_ANON_110_COORD_MAP', True,
                                                          pyxb.utils.utility.Location(
                                                              '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                              4291, 32), )

    COORD_MAP = property(__COORD_MAP.value, __COORD_MAP.set, None,
                         "Description d'un point du r\xe9seau dans le rep\xe8re r\xe9f\xe9rence et dans le rep\xe8re du r\xe9seau")


    # Attribute application uses Python identifier application
    __application = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'application'), 'application',
                                                      '__AbsentNamespace0_CTD_ANON_110_application',
                                                      pyxb.binding.datatypes.string)
    __application._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4310, 30)
    __application._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4310, 30)

    application = property(__application.value, __application.set, None,
                           "Nom de l'application utilisant ce r\xe9f\xe9rentiel de coordonn\xe9es")


    # Attribute proj uses Python identifier proj
    __proj = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'proj'), 'proj',
                                               '__AbsentNamespace0_CTD_ANON_110_proj', pyxb.binding.datatypes.string)
    __proj._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4315, 30)
    __proj._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4315, 30)

    proj = property(__proj.value, __proj.set, None, 'Identifiant de la projection utilis\xe9 (ex : WGS84)')


    # Attribute north uses Python identifier north
    __north = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'north'), 'north',
                                                '__AbsentNamespace0_CTD_ANON_110_north', pyxb.binding.datatypes.float)
    __north._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4320, 30)
    __north._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4320, 30)

    north = property(__north.value, __north.set, None, 'Angle de la zone de r\xe9f\xe9rence\n')

    _ElementMap.update({
        __COORD_MAP.name(): __COORD_MAP
    })
    _AttributeMap.update({
        __application.name(): __application,
        __proj.name(): __proj,
        __north.name(): __north
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_111(pyxb.binding.basis.complexTypeDefinition):
    """Description d'un point du rÃ©seau dans le repÃ¨re rÃ©fÃ©rence et dans le repÃ¨re du rÃ©seau"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4295, 34)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute internal uses Python identifier internal
    __internal = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'internal'), 'internal',
                                                   '__AbsentNamespace0_CTD_ANON_111_internal',
                                                   pyxb.binding.datatypes.string, required=True)
    __internal._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4296, 36)
    __internal._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4296, 36)

    internal = property(__internal.value, __internal.set, None, 'Coordonn\xe9es r\xe9seau')


    # Attribute external uses Python identifier external
    __external = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'external'), 'external',
                                                   '__AbsentNamespace0_CTD_ANON_111_external',
                                                   pyxb.binding.datatypes.string, required=True)
    __external._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4301, 36)
    __external._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4301, 36)

    external = property(__external.value, __external.set, None, 'Coordonn\xe9es r\xe9f\xe9rence\n')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __internal.name(): __internal,
        __external.name(): __external
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_112(pyxb.binding.basis.complexTypeDefinition):
    """Initialisation du rÃ©seau par une liste de vÃ©hicule prÃ©sent sur le rÃ©seau Ã  l'instant 0"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4335, 22)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TRAJS uses Python identifier TRAJS
    __TRAJS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRAJS'), 'TRAJS',
                                                      '__AbsentNamespace0_CTD_ANON_112_TRAJS', True,
                                                      pyxb.utils.utility.Location(
                                                          '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                          4337, 26), )

    TRAJS = property(__TRAJS.value, __TRAJS.set, None,
                     "Liste des v\xe9hicules pr\xe9sents \xe0 l'instant 0\n\t\t\t\t\t\t")

    _ElementMap.update({
        __TRAJS.name(): __TRAJS
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_113(pyxb.binding.basis.complexTypeDefinition):
    """Liste des vÃ©hicules prÃ©sents Ã  l'instant 0
						"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4342, 28)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TRAJ uses Python identifier TRAJ
    __TRAJ = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRAJ'), 'TRAJ',
                                                     '__AbsentNamespace0_CTD_ANON_113_TRAJ', True,
                                                     pyxb.utils.utility.Location(
                                                         '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                         4344, 32), )

    TRAJ = property(__TRAJ.value, __TRAJ.set, None,
                    "Description d'un v\xe9hicule pr\xe9sent sur le r\xe9seau \xe0 l'instant 0")

    _ElementMap.update({
        __TRAJ.name(): __TRAJ
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_114(pyxb.binding.basis.complexTypeDefinition):
    """Liste des dÃ©finitions de scÃ©narios"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4421, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element SCENARIO uses Python identifier SCENARIO
    __SCENARIO = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SCENARIO'), 'SCENARIO',
                                                         '__AbsentNamespace0_CTD_ANON_114_SCENARIO', True,
                                                         pyxb.utils.utility.Location(
                                                             '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                             4423, 14), )

    SCENARIO = property(__SCENARIO.value, __SCENARIO.set, None, "D\xe9finition d'un sc\xe9nario \xe0 simuler.")

    _ElementMap.update({
        __SCENARIO.name(): __SCENARIO
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_115(pyxb.binding.basis.complexTypeDefinition):
    """DÃ©finition d'un scÃ©nario Ã  simuler."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4427, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_115_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4428, 18)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4428, 18)

    id = property(__id.value, __id.set, None, 'identifiant du sc\xe9nario')


    # Attribute simulation_id uses Python identifier simulation_id
    __simulation_id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'simulation_id'),
                                                        'simulation_id',
                                                        '__AbsentNamespace0_CTD_ANON_115_simulation_id',
                                                        pyxb.binding.datatypes.string, required=True)
    __simulation_id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4433, 18)
    __simulation_id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4433, 18)

    simulation_id = property(__simulation_id.value, __simulation_id.set, None,
                             'identifiant de la section SIMULATION associ\xe9e')


    # Attribute trafic_id uses Python identifier trafic_id
    __trafic_id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'trafic_id'), 'trafic_id',
                                                    '__AbsentNamespace0_CTD_ANON_115_trafic_id',
                                                    pyxb.binding.datatypes.string, required=True)
    __trafic_id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4438, 18)
    __trafic_id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4438, 18)

    trafic_id = property(__trafic_id.value, __trafic_id.set, None, 'identifiant de la section TRAFIC associ\xe9e')


    # Attribute reseau_id uses Python identifier reseau_id
    __reseau_id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'reseau_id'), 'reseau_id',
                                                    '__AbsentNamespace0_CTD_ANON_115_reseau_id',
                                                    pyxb.binding.datatypes.string, required=True)
    __reseau_id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4443, 18)
    __reseau_id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4443, 18)

    reseau_id = property(__reseau_id.value, __reseau_id.set, None, 'identifiant de la section RESEAU associ\xe9e')


    # Attribute dirout uses Python identifier dirout
    __dirout = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'dirout'), 'dirout',
                                                 '__AbsentNamespace0_CTD_ANON_115_dirout',
                                                 pyxb.binding.datatypes.string)
    __dirout._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4448, 18)
    __dirout._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4448, 18)

    dirout = property(__dirout.value, __dirout.set, None, 'R\xe9pertoire de sortie des r\xe9sultats de la simulation')


    # Attribute prefout uses Python identifier prefout
    __prefout = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'prefout'), 'prefout',
                                                  '__AbsentNamespace0_CTD_ANON_115_prefout',
                                                  pyxb.binding.datatypes.string, required=True)
    __prefout._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4453, 18)
    __prefout._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4453, 18)

    prefout = property(__prefout.value, __prefout.set, None, 'Pr\xe9fixe des fichiers de sortie')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id.name(): __id,
        __simulation_id.name(): __simulation_id,
        __trafic_id.name(): __trafic_id,
        __reseau_id.name(): __reseau_id,
        __dirout.name(): __dirout,
        __prefout.name(): __prefout
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_116(pyxb.binding.basis.complexTypeDefinition):
    """Liste des tronÃ§ons constituant l'itinÃ©raire"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4867, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TRONCON_ uses Python identifier TRONCON
    __TRONCON = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRONCON_'), 'TRONCON',
                                                        '__AbsentNamespace0_CTD_ANON_116_TRONCON', True,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            4869, 12), )

    TRONCON = property(__TRONCON.value, __TRONCON.set, None, None)

    _ElementMap.update({
        __TRONCON.name(): __TRONCON
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_117(pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type EMPTY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4870, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute libelle uses Python identifier libelle
    __libelle = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'libelle'), 'libelle',
                                                  '__AbsentNamespace0_CTD_ANON_117_libelle',
                                                  pyxb.binding.datatypes.string, required=True)
    __libelle._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4871, 16)
    __libelle._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4871, 16)

    libelle = property(__libelle.value, __libelle.set, None, 'Identifiant du tron\xe7on')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __libelle.name(): __libelle
    })


# Complex type typeFLUX with content type ELEMENT_ONLY
class typeFLUX(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeFLUX with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeFLUX')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4893, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element DEMANDES uses Python identifier DEMANDES
    __DEMANDES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DEMANDES'), 'DEMANDES',
                                                         '__AbsentNamespace0_typeFLUX_DEMANDES', False,
                                                         pyxb.utils.utility.Location(
                                                             '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                             4895, 6), )

    DEMANDES = property(__DEMANDES.value, __DEMANDES.set, None,
                        "Noeud d'acc\xe8s aux variantes temporelles de la demande pour l'extr\xe9mit\xe9 courante")


    # Element REP_DESTINATIONS uses Python identifier REP_DESTINATIONS
    __REP_DESTINATIONS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'REP_DESTINATIONS'),
                                                                 'REP_DESTINATIONS',
                                                                 '__AbsentNamespace0_typeFLUX_REP_DESTINATIONS', False,
                                                                 pyxb.utils.utility.Location(
                                                                     '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                     4922, 6), )

    REP_DESTINATIONS = property(__REP_DESTINATIONS.value, __REP_DESTINATIONS.set, None,
                                "Noeud d'acc\xe8s aux variantes temporelles de la r\xe9partition vers les destinations pour l'extr\xe9mit\xe9 courante")


    # Element REP_VOIES uses Python identifier REP_VOIES
    __REP_VOIES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'REP_VOIES'), 'REP_VOIES',
                                                          '__AbsentNamespace0_typeFLUX_REP_VOIES', False,
                                                          pyxb.utils.utility.Location(
                                                              '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                              4997, 6), )

    REP_VOIES = property(__REP_VOIES.value, __REP_VOIES.set, None,
                         "Noeud d'acc\xe8s aux variantes temporelles de la r\xe9partition par voie du flux provenant de l'extr\xe9mit\xe9 (origine) courante")

    _ElementMap.update({
        __DEMANDES.name(): __DEMANDES,
        __REP_DESTINATIONS.name(): __REP_DESTINATIONS,
        __REP_VOIES.name(): __REP_VOIES
    })
    _AttributeMap.update({

    })


Namespace.addCategoryObject('typeBinding', 'typeFLUX', typeFLUX)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_118(pyxb.binding.basis.complexTypeDefinition):
    """Noeud d'accÃ¨s aux variantes temporelles de la demande pour l'extrÃ©mitÃ© courante"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4899, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element DEMANDE uses Python identifier DEMANDE
    __DEMANDE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DEMANDE'), 'DEMANDE',
                                                        '__AbsentNamespace0_CTD_ANON_118_DEMANDE', True,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            4901, 12), )

    DEMANDE = property(__DEMANDE.value, __DEMANDE.set, None,
                       "Description d'une variante temporelle de demande de l'extr\xe9mit\xe9 courante")

    _ElementMap.update({
        __DEMANDE.name(): __DEMANDE
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_119(pyxb.binding.basis.complexTypeDefinition):
    """Noeud d'accÃ¨s aux variantes temporelles de la rÃ©partition vers les destinations pour l'extrÃ©mitÃ© courante"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4926, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element REP_DESTINATION uses Python identifier REP_DESTINATION
    __REP_DESTINATION = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'REP_DESTINATION'),
                                                                'REP_DESTINATION',
                                                                '__AbsentNamespace0_CTD_ANON_119_REP_DESTINATION', True,
                                                                pyxb.utils.utility.Location(
                                                                    '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                    4928, 12), )

    REP_DESTINATION = property(__REP_DESTINATION.value, __REP_DESTINATION.set, None,
                               'Description de la variante temporelle de la r\xe9partition vers les destinations')

    _ElementMap.update({
        __REP_DESTINATION.name(): __REP_DESTINATION
    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_120(pyxb.binding.basis.complexTypeDefinition):
    """Noeud d'accÃ¨s aux variantes temporelles de la rÃ©partition par voie du flux provenant de l'extrÃ©mitÃ© (origine) courante"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               5001, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element REP_VOIE uses Python identifier REP_VOIE
    __REP_VOIE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'REP_VOIE'), 'REP_VOIE',
                                                         '__AbsentNamespace0_CTD_ANON_120_REP_VOIE', True,
                                                         pyxb.utils.utility.Location(
                                                             '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                             5003, 12), )

    REP_VOIE = property(__REP_VOIE.value, __REP_VOIE.set, None,
                        "Description d'une variante temporelle de la r\xe9partition par voie du flux provenant de l'extr\xe9mit\xe9 (origine) courante")

    _ElementMap.update({
        __REP_VOIE.name(): __REP_VOIE
    })
    _AttributeMap.update({

    })


# Complex type typeFLUX_GLOBAL with content type ELEMENT_ONLY
class typeFLUX_GLOBAL(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeFLUX_GLOBAL with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeFLUX_GLOBAL')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               5025, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element FLUX uses Python identifier FLUX
    __FLUX = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FLUX'), 'FLUX',
                                                     '__AbsentNamespace0_typeFLUX_GLOBAL_FLUX', False,
                                                     pyxb.utils.utility.Location(
                                                         '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                         5027, 6), )

    FLUX = property(__FLUX.value, __FLUX.set, None, 'Description du flux ')


    # Element REP_TYPEVEHICULES uses Python identifier REP_TYPEVEHICULES
    __REP_TYPEVEHICULES = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'REP_TYPEVEHICULES'), 'REP_TYPEVEHICULES',
        '__AbsentNamespace0_typeFLUX_GLOBAL_REP_TYPEVEHICULES', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 5032, 6), )

    REP_TYPEVEHICULES = property(__REP_TYPEVEHICULES.value, __REP_TYPEVEHICULES.set, None,
                                 'Description des variantes temporelles de la r\xe9partition du flux par type de v\xe9hicule (cette r\xe9partition est utilis\xe9e pour calculer le type de v\xe9hicule lors de sa cr\xe9ation)')

    _ElementMap.update({
        __FLUX.name(): __FLUX,
        __REP_TYPEVEHICULES.name(): __REP_TYPEVEHICULES
    })
    _AttributeMap.update({

    })


Namespace.addCategoryObject('typeBinding', 'typeFLUX_GLOBAL', typeFLUX_GLOBAL)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_121(pyxb.binding.basis.complexTypeDefinition):
    """Description des variantes temporelles de la rÃ©partition du flux par type de vÃ©hicule (cette rÃ©partition est utilisÃ©e pour calculer le type de vÃ©hicule lors de sa crÃ©ation)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               5036, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element REP_TYPEVEHICULE uses Python identifier REP_TYPEVEHICULE
    __REP_TYPEVEHICULE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'REP_TYPEVEHICULE'),
                                                                 'REP_TYPEVEHICULE',
                                                                 '__AbsentNamespace0_CTD_ANON_121_REP_TYPEVEHICULE',
                                                                 True, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 5038, 12), )

    REP_TYPEVEHICULE = property(__REP_TYPEVEHICULE.value, __REP_TYPEVEHICULE.set, None,
                                "Description d'une variante temporelle de la r\xe9partition du flux par type de v\xe9hicule")

    _ElementMap.update({
        __REP_TYPEVEHICULE.name(): __REP_TYPEVEHICULE
    })
    _AttributeMap.update({

    })


# Complex type typeFLUX_TYPEVEHS with content type EMPTY
class typeFLUX_TYPEVEHS(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeFLUX_TYPEVEHS with content type EMPTY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeFLUX_TYPEVEHS')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               5060, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({

    })
    _AttributeMap.update({

    })


Namespace.addCategoryObject('typeBinding', 'typeFLUX_TYPEVEHS', typeFLUX_TYPEVEHS)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_122(pyxb.binding.basis.complexTypeDefinition):
    """Description des coefficients directionnels pour un tronÃ§on amont et une voie donnÃ©e"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               150, 32)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element COEFFS_TRONCON_AVAL uses Python identifier COEFFS_TRONCON_AVAL
    __COEFFS_TRONCON_AVAL = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'COEFFS_TRONCON_AVAL'), 'COEFFS_TRONCON_AVAL',
        '__AbsentNamespace0_CTD_ANON_122_COEFFS_TRONCON_AVAL', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 152, 36), )

    COEFFS_TRONCON_AVAL = property(__COEFFS_TRONCON_AVAL.value, __COEFFS_TRONCON_AVAL.set, None,
                                   "Collection des coefficients directionnels des tron\xe7ons aval pour un tron\xe7on et une voie donn\xe9es en amont. Si un tron\xe7on aval du r\xe9partiteur parent ne se trouve pas dans la liste, cela signifie qu'aucun v\xe9hicule ou flux provenant de la voie du tron\xe7on amont consid\xe9r\xe9 ne sort du r\xe9partiteur par ce tron\xe7on aval")


    # Attribute numvoie uses Python identifier numvoie
    __numvoie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'numvoie'), 'numvoie',
                                                  '__AbsentNamespace0_CTD_ANON_122_numvoie', typeIntStrictPositif,
                                                  required=True)
    __numvoie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 182, 34)
    __numvoie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 182, 34)

    numvoie = property(__numvoie.value, __numvoie.set, None, 'Num\xe9ro de voie du tron\xe7on amont consid\xe9r\xe9')

    _ElementMap.update({
        __COEFFS_TRONCON_AVAL.name(): __COEFFS_TRONCON_AVAL
    })
    _AttributeMap.update({
        __numvoie.name(): __numvoie
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_123(pyxb.binding.basis.complexTypeDefinition):
    """Description d'une variante des donnÃ©es d'affectation de la connexion (ce noeud est dÃ©fini uniquement si le comportement de flux est de type 'destination')."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               220, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element COUPLES_ENTREE_DESTINATION uses Python identifier COUPLES_ENTREE_DESTINATION
    __COUPLES_ENTREE_DESTINATION = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'COUPLES_ENTREE_DESTINATION'), 'COUPLES_ENTREE_DESTINATION',
        '__AbsentNamespace0_CTD_ANON_123_COUPLES_ENTREE_DESTINATION', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 222, 12), )

    COUPLES_ENTREE_DESTINATION = property(__COUPLES_ENTREE_DESTINATION.value, __COUPLES_ENTREE_DESTINATION.set, None,
                                          "Noeud d'acc\xe8s \xe0 la collection des couples entr\xe9e / destination des donn\xe9es d'affectation")


    # Attribute duree uses Python identifier duree
    __duree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree'), 'duree',
                                                '__AbsentNamespace0_CTD_ANON_123_duree', typeDuree,
                                                unicode_default='always')
    __duree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 280, 10)
    __duree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 280, 10)

    duree = property(__duree.value, __duree.set, None,
                     "Identifiant de la plage temporelle associ\xe9e, ou dur\xe9e (en seconde) de la variante de l'affectation")

    _ElementMap.update({
        __COUPLES_ENTREE_DESTINATION.name(): __COUPLES_ENTREE_DESTINATION
    })
    _AttributeMap.update({
        __duree.name(): __duree
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_124(pyxb.binding.basis.complexTypeDefinition):
    """Description de la sortie affectÃ©e"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               245, 32)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id_troncon_aval uses Python identifier id_troncon_aval
    __id_troncon_aval = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_troncon_aval'),
                                                          'id_troncon_aval',
                                                          '__AbsentNamespace0_CTD_ANON_124_id_troncon_aval',
                                                          pyxb.binding.datatypes.string, required=True)
    __id_troncon_aval._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 246, 34)
    __id_troncon_aval._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 246, 34)

    id_troncon_aval = property(__id_troncon_aval.value, __id_troncon_aval.set, None,
                               'Identifiant du tron\xe7on aval (sortie) de la connexion')


    # Attribute coeff uses Python identifier coeff
    __coeff = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'coeff'), 'coeff',
                                                '__AbsentNamespace0_CTD_ANON_124_coeff', typeFloat01,
                                                unicode_default='1')
    __coeff._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 252, 34)
    __coeff._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 252, 34)

    coeff = property(__coeff.value, __coeff.set, None, "Coefficient d'affectation de la sortie")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id_troncon_aval.name(): __id_troncon_aval,
        __coeff.name(): __coeff
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_125(pyxb.binding.basis.complexTypeDefinition):
    """Description d'un mouvement de la connexion interne"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               295, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element MOUVEMENT_SORTIES uses Python identifier MOUVEMENT_SORTIES
    __MOUVEMENT_SORTIES = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'MOUVEMENT_SORTIES'), 'MOUVEMENT_SORTIES',
        '__AbsentNamespace0_CTD_ANON_125_MOUVEMENT_SORTIES', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 297, 12), )

    MOUVEMENT_SORTIES = property(__MOUVEMENT_SORTIES.value, __MOUVEMENT_SORTIES.set, None,
                                 "Description de l'aval du mouvement (si un tron\xe7on aval de la connexion n'est pas pr\xe9sent, les v\xe9hicules entrant par le tron\xe7on et la voie consid\xe9r\xe9s ne peuvent pas sortir par ce tron\xe7on)")


    # Attribute id_troncon_amont uses Python identifier id_troncon_amont
    __id_troncon_amont = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_troncon_amont'),
                                                           'id_troncon_amont',
                                                           '__AbsentNamespace0_CTD_ANON_125_id_troncon_amont',
                                                           pyxb.binding.datatypes.string)
    __id_troncon_amont._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 358, 10)
    __id_troncon_amont._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 358, 10)

    id_troncon_amont = property(__id_troncon_amont.value, __id_troncon_amont.set, None,
                                'Identifiant du tron\xe7on amont de la connexion interne')


    # Attribute num_voie_amont uses Python identifier num_voie_amont
    __num_voie_amont = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'num_voie_amont'),
                                                         'num_voie_amont',
                                                         '__AbsentNamespace0_CTD_ANON_125_num_voie_amont',
                                                         typeIntStrictPositif, unicode_default='1')
    __num_voie_amont._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 363, 10)
    __num_voie_amont._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 363, 10)

    num_voie_amont = property(__num_voie_amont.value, __num_voie_amont.set, None,
                              'Num\xe9ro de la voie du tron\xe7on amont consid\xe9r\xe9e')

    _ElementMap.update({
        __MOUVEMENT_SORTIES.name(): __MOUVEMENT_SORTIES
    })
    _AttributeMap.update({
        __id_troncon_amont.name(): __id_troncon_amont,
        __num_voie_amont.name(): __num_voie_amont
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_126(pyxb.binding.basis.complexTypeDefinition):
    """Description de l'aval d'un mouvement"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               307, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id_troncon_aval uses Python identifier id_troncon_aval
    __id_troncon_aval = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_troncon_aval'),
                                                          'id_troncon_aval',
                                                          '__AbsentNamespace0_CTD_ANON_126_id_troncon_aval',
                                                          pyxb.binding.datatypes.string, required=True)
    __id_troncon_aval._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 308, 22)
    __id_troncon_aval._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 308, 22)

    id_troncon_aval = property(__id_troncon_aval.value, __id_troncon_aval.set, None, 'Identifiant du tron\xe7on aval')


    # Attribute num_voie_aval uses Python identifier num_voie_aval
    __num_voie_aval = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'num_voie_aval'),
                                                        'num_voie_aval',
                                                        '__AbsentNamespace0_CTD_ANON_126_num_voie_aval',
                                                        typeIntStrictPositif, unicode_default='1')
    __num_voie_aval._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 313, 22)
    __num_voie_aval._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 313, 22)

    num_voie_aval = property(__num_voie_aval.value, __num_voie_aval.set, None, 'Num\xe9ro de la voie aval')


    # Attribute taux_utilisation uses Python identifier taux_utilisation
    __taux_utilisation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'taux_utilisation'),
                                                           'taux_utilisation',
                                                           '__AbsentNamespace0_CTD_ANON_126_taux_utilisation',
                                                           typeFloat01, unicode_default='1')
    __taux_utilisation._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 319, 22)
    __taux_utilisation._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 319, 22)

    taux_utilisation = property(__taux_utilisation.value, __taux_utilisation.set, None,
                                "Taux d'utilisation de cette voie aval parmi l'ensemble des voies du tron\xe7on aval pour les mouvements issus de la voie amont consid\xe9r\xe9. Si plusieurs mouvements issus de la m\xeame voie arrivent sur un m\xeame tron\xe7on aval, la somme des taux d'utilisation pour l'ensemble des voies de ce tron\xe7on aval doit \xeatre \xe9gale \xe0 1.")


    # Attribute libelle uses Python identifier libelle
    __libelle = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'libelle'), 'libelle',
                                                  '__AbsentNamespace0_CTD_ANON_126_libelle',
                                                  pyxb.binding.datatypes.string)
    __libelle._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 325, 22)
    __libelle._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 325, 22)

    libelle = property(__libelle.value, __libelle.set, None, 'Libell\xe9 du mouvement')


    # Attribute ligne_feu uses Python identifier ligne_feu
    __ligne_feu = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'ligne_feu'), 'ligne_feu',
                                                    '__AbsentNamespace0_CTD_ANON_126_ligne_feu',
                                                    pyxb.binding.datatypes.float, unicode_default='0')
    __ligne_feu._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 330, 22)
    __ligne_feu._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 330, 22)

    ligne_feu = property(__ligne_feu.value, __ligne_feu.set, None,
                         "Position curviligne de la ligne de feu rattach\xe9e au mouvement. Cette position est d\xe9finie  par rapport \xe0 l'extr\xe9mit\xe9 de la voie amont du mouvement et sur la trajectoire d\xe9finie par le mouvement.\nA d\xe9finir uniquuement si un contr\xf4leur de feux est associ\xe9 \xe0 la connexion.")


    # Attribute ligne_feu_relative uses Python identifier ligne_feu_relative
    __ligne_feu_relative = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'ligne_feu_relative'),
                                                             'ligne_feu_relative',
                                                             '__AbsentNamespace0_CTD_ANON_126_ligne_feu_relative',
                                                             pyxb.binding.datatypes.boolean, unicode_default='false')
    __ligne_feu_relative._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 336, 22)
    __ligne_feu_relative._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 336, 22)

    ligne_feu_relative = property(__ligne_feu_relative.value, __ligne_feu_relative.set, None,
                                  'Indique que la position de la ligne de feu est exprim\xe9e en pourcentage de la longueur du tron\xe7on amont')


    # Attribute vit_max uses Python identifier vit_max
    __vit_max = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'vit_max'), 'vit_max',
                                                  '__AbsentNamespace0_CTD_ANON_126_vit_max', typeFloatStrictPositif)
    __vit_max._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 342, 22)
    __vit_max._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 342, 22)

    vit_max = property(__vit_max.value, __vit_max.set, None,
                       'Vitesse maximale sp\xe9cifique \xe0 ce mouvement autoris\xe9 (en m/s)')


    # Attribute exclusion_types_vehicules uses Python identifier exclusion_types_vehicules
    __exclusion_types_vehicules = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'exclusion_types_vehicules'), 'exclusion_types_vehicules',
        '__AbsentNamespace0_CTD_ANON_126_exclusion_types_vehicules', pyxb.binding.datatypes.string)
    __exclusion_types_vehicules._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 347, 22)
    __exclusion_types_vehicules._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 347, 22)

    exclusion_types_vehicules = property(__exclusion_types_vehicules.value, __exclusion_types_vehicules.set, None,
                                         'Liste des identifiants des types de v\xe9hicules qui sont exclus de ce mouvement autoris\xe9')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id_troncon_aval.name(): __id_troncon_aval,
        __num_voie_aval.name(): __num_voie_aval,
        __taux_utilisation.name(): __taux_utilisation,
        __libelle.name(): __libelle,
        __ligne_feu.name(): __ligne_feu,
        __ligne_feu_relative.name(): __ligne_feu_relative,
        __vit_max.name(): __vit_max,
        __exclusion_types_vehicules.name(): __exclusion_types_vehicules
    })


# Complex type typeTraficConnexionInterne with content type ELEMENT_ONLY
class typeTraficConnexionInterne(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeTraficConnexionInterne with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeTraficConnexionInterne')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               385, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element AFFECTATIONS uses Python identifier AFFECTATIONS
    __AFFECTATIONS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'AFFECTATIONS'),
                                                             'AFFECTATIONS',
                                                             '__AbsentNamespace0_typeTraficConnexionInterne_AFFECTATIONS',
                                                             False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 388, 8), )

    AFFECTATIONS = property(__AFFECTATIONS.value, __AFFECTATIONS.set, None,
                            "Noeud d'acc\xe8s \xe0 la description de l'affectation pour l'ensemble des v\xe9hicules")


    # Element AFFECTATIONS_TYPE_VEHICULE uses Python identifier AFFECTATIONS_TYPE_VEHICULE
    __AFFECTATIONS_TYPE_VEHICULE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'AFFECTATIONS_TYPE_VEHICULE'), 'AFFECTATIONS_TYPE_VEHICULE',
        '__AbsentNamespace0_typeTraficConnexionInterne_AFFECTATIONS_TYPE_VEHICULE', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 393, 8), )

    AFFECTATIONS_TYPE_VEHICULE = property(__AFFECTATIONS_TYPE_VEHICULE.value, __AFFECTATIONS_TYPE_VEHICULE.set, None,
                                          "Noeud d'acc\xe8s \xe0 la description des affectations par type de v\xe9hicule")


    # Element COEFFS_DIR uses Python identifier COEFFS_DIR
    __COEFFS_DIR = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'COEFFS_DIR'),
                                                           'COEFFS_DIR',
                                                           '__AbsentNamespace0_typeTraficConnexionInterne_COEFFS_DIR',
                                                           False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 419, 6), )

    COEFFS_DIR = property(__COEFFS_DIR.value, __COEFFS_DIR.set, None, None)


    # Element LISTE_TEMPS_INSERTION uses Python identifier LISTE_TEMPS_INSERTION
    __LISTE_TEMPS_INSERTION = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'LISTE_TEMPS_INSERTION'), 'LISTE_TEMPS_INSERTION',
        '__AbsentNamespace0_typeTraficConnexionInterne_LISTE_TEMPS_INSERTION', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 420, 6), )

    LISTE_TEMPS_INSERTION = property(__LISTE_TEMPS_INSERTION.value, __LISTE_TEMPS_INSERTION.set, None,
                                     "Liste des temps d'insertion sur la connexion pour tous les types de v\xe9hicule circulant sur le r\xe9seau")


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeTraficConnexionInterne_id',
                                             pyxb.binding.datatypes.string, required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 452, 4)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 452, 4)

    id = property(__id.value, __id.set, None, "Identifiant de l'\xe9l\xe9ment du r\xe9seau associ\xe9")


    # Attribute PeriodeAgregationCapteurs uses Python identifier PeriodeAgregationCapteurs
    __PeriodeAgregationCapteurs = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'PeriodeAgregationCapteurs'), 'PeriodeAgregationCapteurs',
        '__AbsentNamespace0_typeTraficConnexionInterne_PeriodeAgregationCapteurs', typeFloatStrictPositif)
    __PeriodeAgregationCapteurs._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 457, 4)
    __PeriodeAgregationCapteurs._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 457, 4)

    PeriodeAgregationCapteurs = property(__PeriodeAgregationCapteurs.value, __PeriodeAgregationCapteurs.set, None,
                                         "P\xe9riode (en s) d'agr\xe9gation des capteurs")


    # Attribute Gamma uses Python identifier Gamma
    __Gamma = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Gamma'), 'Gamma',
                                                '__AbsentNamespace0_typeTraficConnexionInterne_Gamma',
                                                typeFloatStrictPositif)
    __Gamma._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 462, 4)
    __Gamma._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 462, 4)

    Gamma = property(__Gamma.value, __Gamma.set, None, 'Rapport Gamma')


    # Attribute Mu uses Python identifier Mu
    __Mu = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Mu'), 'Mu',
                                             '__AbsentNamespace0_typeTraficConnexionInterne_Mu', typeFloat01)
    __Mu._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 467, 4)
    __Mu._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 467, 4)

    Mu = property(__Mu.value, __Mu.set, None, 'Coefficient de priorit\xe9')


    # Attribute Beta uses Python identifier Beta
    __Beta = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Beta'), 'Beta',
                                               '__AbsentNamespace0_typeTraficConnexionInterne_Beta', typeFloat01)
    __Beta._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 472, 4)
    __Beta._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 472, 4)

    Beta = property(__Beta.value, __Beta.set, None,
                    "Pour giratoires uniquement : probabilit\xe9 pour un v\xe9hicule voulant s'ins\xe9rer de d\xe9tecter un v\xe9hicule sortant du giratoire en r\xe9gime fluide (le v\xe9hicule sortant d\xe9tect\xe9 ne g\xe8ne pas l'insertion).")


    # Attribute BetaInt uses Python identifier BetaInt
    __BetaInt = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'BetaInt'), 'BetaInt',
                                                  '__AbsentNamespace0_typeTraficConnexionInterne_BetaInt', typeFloat01)
    __BetaInt._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 477, 4)
    __BetaInt._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 477, 4)

    BetaInt = property(__BetaInt.value, __BetaInt.set, None,
                       "Pour giratoires uniquement : probabilit\xe9 pour un v\xe9hicule voulant s'ins\xe9rer d'\xeatre g\xe9n\xe9 par un v\xe9hicule arrivant sur la voie interne du giratoire en r\xe9gime fluide (\xe0 d\xe9finir uniquement dans le cas d'un giratoire \xe0 2 voies)")


    # Attribute pos_cpt_Av uses Python identifier pos_cpt_Av
    __pos_cpt_Av = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'pos_cpt_Av'), 'pos_cpt_Av',
                                                     '__AbsentNamespace0_typeTraficConnexionInterne_pos_cpt_Av',
                                                     typeFloatPositif)
    __pos_cpt_Av._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 482, 4)
    __pos_cpt_Av._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 482, 4)

    pos_cpt_Av = property(__pos_cpt_Av.value, __pos_cpt_Av.set, None,
                          'Pour convergents uniquement : Position (en m\xe8tre) du capteur sur le tron\xe7on aval')


    # Attribute traversees uses Python identifier traversees
    __traversees = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'traversees'), 'traversees',
                                                     '__AbsentNamespace0_typeTraficConnexionInterne_traversees',
                                                     pyxb.binding.datatypes.boolean, unicode_default='true')
    __traversees._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 487, 4)
    __traversees._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 487, 4)

    traversees = property(__traversees.value, __traversees.set, None,
                          "Permet d'activer o\xf9 non la gestion des conflits de travers\xe9e au niveau de la connexion interne (uniquement pour les briques de connexion : CAF et giratoire) ")

    _ElementMap.update({
        __AFFECTATIONS.name(): __AFFECTATIONS,
        __AFFECTATIONS_TYPE_VEHICULE.name(): __AFFECTATIONS_TYPE_VEHICULE,
        __COEFFS_DIR.name(): __COEFFS_DIR,
        __LISTE_TEMPS_INSERTION.name(): __LISTE_TEMPS_INSERTION
    })
    _AttributeMap.update({
        __id.name(): __id,
        __PeriodeAgregationCapteurs.name(): __PeriodeAgregationCapteurs,
        __Gamma.name(): __Gamma,
        __Mu.name(): __Mu,
        __Beta.name(): __Beta,
        __BetaInt.name(): __BetaInt,
        __pos_cpt_Av.name(): __pos_cpt_Av,
        __traversees.name(): __traversees
    })


Namespace.addCategoryObject('typeBinding', 'typeTraficConnexionInterne', typeTraficConnexionInterne)


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_127(pyxb.binding.basis.complexTypeDefinition):
    """Temps d'insertion sur la connexion pour un type de vÃ©hicule"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               430, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id_typevehicule uses Python identifier id_typevehicule
    __id_typevehicule = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_typevehicule'),
                                                          'id_typevehicule',
                                                          '__AbsentNamespace0_CTD_ANON_127_id_typevehicule',
                                                          pyxb.binding.datatypes.string, required=True)
    __id_typevehicule._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 431, 16)
    __id_typevehicule._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 431, 16)

    id_typevehicule = property(__id_typevehicule.value, __id_typevehicule.set, None,
                               'Identifiant du type de v\xe9hicule concern\xe9')


    # Attribute ti uses Python identifier ti
    __ti = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'ti'), 'ti',
                                             '__AbsentNamespace0_CTD_ANON_127_ti', typeFloatStrictPositif,
                                             required=True)
    __ti._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 436, 16)
    __ti._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 436, 16)

    ti = property(__ti.value, __ti.set, None, "Temps (en seconde) d'insertion")


    # Attribute tt uses Python identifier tt
    __tt = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'tt'), 'tt',
                                             '__AbsentNamespace0_CTD_ANON_127_tt', typeFloatStrictPositif)
    __tt._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 441, 16)
    __tt._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 441, 16)

    tt = property(__tt.value, __tt.set, None, 'Temps (en seconde) de travers\xe9e. Inutilis\xe9 pour les convergents.')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id_typevehicule.name(): __id_typevehicule,
        __ti.name(): __ti,
        __tt.name(): __tt
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_128(pyxb.binding.basis.complexTypeDefinition):
    """Noeud regroupant l'ensemble des options de modulation du contenu des fichiers de sortie"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               499, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element PLAGES_EXTRACTION uses Python identifier PLAGES_EXTRACTION
    __PLAGES_EXTRACTION = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'PLAGES_EXTRACTION'), 'PLAGES_EXTRACTION',
        '__AbsentNamespace0_CTD_ANON_128_PLAGES_EXTRACTION', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 501, 12), )

    PLAGES_EXTRACTION = property(__PLAGES_EXTRACTION.value, __PLAGES_EXTRACTION.set, None,
                                 "Plages temporelles d'\xe9criture des instants de la simulation. Sans plage d'extraction l'\xe9criture est r\xe9alis\xe9e sur toute la simulation.")


    # Attribute affectation_sortie uses Python identifier affectation_sortie
    __affectation_sortie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'affectation_sortie'),
                                                             'affectation_sortie',
                                                             '__AbsentNamespace0_CTD_ANON_128_affectation_sortie',
                                                             pyxb.binding.datatypes.boolean, unicode_default='false')
    __affectation_sortie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 528, 10)
    __affectation_sortie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 528, 10)

    affectation_sortie = property(__affectation_sortie.value, __affectation_sortie.set, None,
                                  "Indique si les informations issues du calcul d'affectation sont g\xe9n\xe9r\xe9es dans un fichier au format XML (exploitable par SymuPlayer)")


    # Attribute trace_route uses Python identifier trace_route
    __trace_route = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'trace_route'), 'trace_route',
                                                      '__AbsentNamespace0_CTD_ANON_128_trace_route',
                                                      pyxb.binding.datatypes.boolean, unicode_default='0')
    __trace_route._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 533, 10)
    __trace_route._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 533, 10)

    trace_route = property(__trace_route.value, __trace_route.set, None,
                           "Indique si les itin\xe9raires des v\xe9hicules sont trac\xe9s dans le fichier trafic. \nSi oui, le calcul de la distance parcourue dans la proc\xe9dure de trace des trajectoire s'effectue de fa\xe7on exacte sinon la proc\xe9dure utilise la vitesse \xe0 chaque pas de temps pour en d\xe9duire la distance parcourue.")


    # Attribute sortie uses Python identifier sortie
    __sortie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'sortie'), 'sortie',
                                                 '__AbsentNamespace0_CTD_ANON_128_sortie', STD_ANON_2,
                                                 unicode_default='normal')
    __sortie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 539, 10)
    __sortie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 539, 10)

    sortie = property(__sortie.value, __sortie.set, None,
                      "Mode se sortie du trafic. Le mode 'light' sauvegarde uniquement les r\xe9sultats utiles \xe0 SymuPlot et SymuPlayer (notamment le mode 'light' ne permet pas de lancer la simulation acoustique correspondante).")


    # Attribute trajectoires uses Python identifier trajectoires
    __trajectoires = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'trajectoires'),
                                                       'trajectoires', '__AbsentNamespace0_CTD_ANON_128_trajectoires',
                                                       pyxb.binding.datatypes.boolean, unicode_default='1')
    __trajectoires._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 550, 10)
    __trajectoires._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 550, 10)

    trajectoires = property(__trajectoires.value, __trajectoires.set, None,
                            'Indique si les trajectoires sont inscrites dans le fichier de sortie')


    # Attribute chgt_voie_debug uses Python identifier chgt_voie_debug
    __chgt_voie_debug = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'chgt_voie_debug'),
                                                          'chgt_voie_debug',
                                                          '__AbsentNamespace0_CTD_ANON_128_chgt_voie_debug',
                                                          pyxb.binding.datatypes.boolean, unicode_default='false')
    __chgt_voie_debug._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 555, 10)
    __chgt_voie_debug._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 555, 10)

    chgt_voie_debug = property(__chgt_voie_debug.value, __chgt_voie_debug.set, None, None)


    # Attribute debug uses Python identifier debug
    __debug = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'debug'), 'debug',
                                                '__AbsentNamespace0_CTD_ANON_128_debug', pyxb.binding.datatypes.boolean,
                                                unicode_default='0')
    __debug._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 556, 10)
    __debug._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 556, 10)

    debug = property(__debug.value, __debug.set, None,
                     "Cr\xe9ation d'un fichier trace et de sorties suppl\xe9mentaires dans le fichier trafic (leader, deltaN)")


    # Attribute debug_matrice_OD uses Python identifier debug_matrice_OD
    __debug_matrice_OD = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'debug_matrice_OD'),
                                                           'debug_matrice_OD',
                                                           '__AbsentNamespace0_CTD_ANON_128_debug_matrice_OD',
                                                           pyxb.binding.datatypes.boolean, unicode_default='0')
    __debug_matrice_OD._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 561, 10)
    __debug_matrice_OD._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 561, 10)

    debug_matrice_OD = property(__debug_matrice_OD.value, __debug_matrice_OD.set, None,
                                "Cr\xe9ation d'un fichier _debug.log contenant la trace des matrices OD ainsi que leurs diff\xe9rentes variations")


    # Attribute debug_SAS uses Python identifier debug_SAS
    __debug_SAS = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'debug_SAS'), 'debug_SAS',
                                                    '__AbsentNamespace0_CTD_ANON_128_debug_SAS',
                                                    pyxb.binding.datatypes.boolean, unicode_default='0')
    __debug_SAS._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 566, 10)
    __debug_SAS._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 566, 10)

    debug_SAS = property(__debug_SAS.value, __debug_SAS.set, None,
                         "Cr\xe9ation d'un fichier trace des SAS pour chaque voie microscopique")


    # Attribute vgp_debug uses Python identifier vgp_debug
    __vgp_debug = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'vgp_debug'), 'vgp_debug',
                                                    '__AbsentNamespace0_CTD_ANON_128_vgp_debug',
                                                    pyxb.binding.datatypes.boolean, unicode_default='0')
    __vgp_debug._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 571, 10)
    __vgp_debug._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 571, 10)

    vgp_debug = property(__vgp_debug.value, __vgp_debug.set, None,
                         'Sortie dans le fichier Simulation.log des informations relatives \xe0 la gestion des VGP par les controleurs de feux.')


    # Attribute trace_stocks uses Python identifier trace_stocks
    __trace_stocks = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'trace_stocks'),
                                                       'trace_stocks', '__AbsentNamespace0_CTD_ANON_128_trace_stocks',
                                                       pyxb.binding.datatypes.boolean, unicode_default='false')
    __trace_stocks._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 576, 10)
    __trace_stocks._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 576, 10)

    trace_stocks = property(__trace_stocks.value, __trace_stocks.set, None,
                            'Indique si on doit sortir les informations sur le stock de stationnement au niveau des parkings et tron\xe7ons')


    # Attribute csv uses Python identifier csv
    __csv = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'csv'), 'csv',
                                              '__AbsentNamespace0_CTD_ANON_128_csv', pyxb.binding.datatypes.boolean,
                                              unicode_default='false')
    __csv._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 581, 10)
    __csv._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 581, 10)

    csv = property(__csv.value, __csv.set, None,
                   'Indique si on doit produire les fichiers de r\xe9sultat au format CSV')


    # Attribute types_vehicules uses Python identifier types_vehicules
    __types_vehicules = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'types_vehicules'),
                                                          'types_vehicules',
                                                          '__AbsentNamespace0_CTD_ANON_128_types_vehicules',
                                                          pyxb.binding.datatypes.string)
    __types_vehicules._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 586, 10)
    __types_vehicules._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 586, 10)

    types_vehicules = property(__types_vehicules.value, __types_vehicules.set, None,
                               'Identifiants du ou des types de v\xe9hicules dont les trajectoires doivent \xeatre restitu\xe9es. par d\xe9faut, les trajectoires des v\xe9hicules de tous les types sont restitu\xe9s.')


    # Attribute EPSGoutput uses Python identifier EPSGoutput
    __EPSGoutput = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'EPSGoutput'), 'EPSGoutput',
                                                     '__AbsentNamespace0_CTD_ANON_128_EPSGoutput',
                                                     pyxb.binding.datatypes.int, unicode_default='0')
    __EPSGoutput._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 591, 10)
    __EPSGoutput._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 591, 10)

    EPSGoutput = property(__EPSGoutput.value, __EPSGoutput.set, None,
                          "Code EPSG du syst\xe8mes de coordonn\xe9es g\xe9or\xe9f\xe9renc\xe9es des r\xe9sultats restitu\xe9s\n(WGS84: 4326;\nLambert 93: 2154)\nSi ce code n'est pas d\xe9fini (ainsi que le code des donn\xe9es d'entr\xe9e - attribut EPSGinput), la restitution des r\xe9sultats s'effectuera sans transformation.\n")


    # Attribute vehicules_capteur_extraction uses Python identifier vehicules_capteur_extraction
    __vehicules_capteur_extraction = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'vehicules_capteur_extraction'), 'vehicules_capteur_extraction',
        '__AbsentNamespace0_CTD_ANON_128_vehicules_capteur_extraction', pyxb.binding.datatypes.boolean,
        unicode_default='true')
    __vehicules_capteur_extraction._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 600, 10)
    __vehicules_capteur_extraction._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 600, 10)

    vehicules_capteur_extraction = property(__vehicules_capteur_extraction.value, __vehicules_capteur_extraction.set,
                                            None,
                                            'Indique si on doit extraire les listes de v\xe9hicules des capteurs ponctuels')

    _ElementMap.update({
        __PLAGES_EXTRACTION.name(): __PLAGES_EXTRACTION
    })
    _AttributeMap.update({
        __affectation_sortie.name(): __affectation_sortie,
        __trace_route.name(): __trace_route,
        __sortie.name(): __sortie,
        __trajectoires.name(): __trajectoires,
        __chgt_voie_debug.name(): __chgt_voie_debug,
        __debug.name(): __debug,
        __debug_matrice_OD.name(): __debug_matrice_OD,
        __debug_SAS.name(): __debug_SAS,
        __vgp_debug.name(): __vgp_debug,
        __trace_stocks.name(): __trace_stocks,
        __csv.name(): __csv,
        __types_vehicules.name(): __types_vehicules,
        __EPSGoutput.name(): __EPSGoutput,
        __vehicules_capteur_extraction.name(): __vehicules_capteur_extraction
    })


# Complex type typeParametrageTrafic with content type ELEMENT_ONLY
class typeParametrageTrafic(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeParametrageTrafic with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeParametrageTrafic')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1057, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TRONCONS uses Python identifier TRONCONS
    __TRONCONS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRONCONS'), 'TRONCONS',
                                                         '__AbsentNamespace0_typeParametrageTrafic_TRONCONS', False,
                                                         pyxb.utils.utility.Location(
                                                             '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                             1059, 6), )

    TRONCONS = property(__TRONCONS.value, __TRONCONS.set, None,
                        'Ensemble des tron\xe7ons pour lesquels sont d\xe9finis des param\xe8tres de trafic particuliers')


    # Element TYPES_DE_VEHICULE uses Python identifier TYPES_DE_VEHICULE
    __TYPES_DE_VEHICULE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'TYPES_DE_VEHICULE'), 'TYPES_DE_VEHICULE',
        '__AbsentNamespace0_typeParametrageTrafic_TYPES_DE_VEHICULE', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1073, 6), )

    TYPES_DE_VEHICULE = property(__TYPES_DE_VEHICULE.value, __TYPES_DE_VEHICULE.set, None,
                                 'Liste des types de v\xe9hicule')


    # Element EXTREMITES uses Python identifier EXTREMITES
    __EXTREMITES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'EXTREMITES'),
                                                           'EXTREMITES',
                                                           '__AbsentNamespace0_typeParametrageTrafic_EXTREMITES', False,
                                                           pyxb.utils.utility.Location(
                                                               '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                               1092, 6), )

    EXTREMITES = property(__EXTREMITES.value, __EXTREMITES.set, None,
                          'Liste des extremit\xe9s (entr\xe9es et sorties) du r\xe9seau pour lesquelles des param\xe8tres de trafic sp\xe9cifiques sont d\xe9finis')


    # Element PARKINGS uses Python identifier PARKINGS
    __PARKINGS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PARKINGS'), 'PARKINGS',
                                                         '__AbsentNamespace0_typeParametrageTrafic_PARKINGS', False,
                                                         pyxb.utils.utility.Location(
                                                             '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                             1107, 6), )

    PARKINGS = property(__PARKINGS.value, __PARKINGS.set, None,
                        'Liste des parkings du r\xe9seau pour lesquels des param\xe8tres de trafic sp\xe9cifiques sont d\xe9finis')


    # Element ZONES_DE_TERMINAISON uses Python identifier ZONES_DE_TERMINAISON
    __ZONES_DE_TERMINAISON = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'ZONES_DE_TERMINAISON'), 'ZONES_DE_TERMINAISON',
        '__AbsentNamespace0_typeParametrageTrafic_ZONES_DE_TERMINAISON', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1121, 6), )

    ZONES_DE_TERMINAISON = property(__ZONES_DE_TERMINAISON.value, __ZONES_DE_TERMINAISON.set, None,
                                    'Liste des zones de terminaison du r\xe9seau pour lesquelles des param\xe8tres de trafic sp\xe9cifiques sont d\xe9finis')


    # Element CONNEXIONS_INTERNES uses Python identifier CONNEXIONS_INTERNES
    __CONNEXIONS_INTERNES = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'CONNEXIONS_INTERNES'), 'CONNEXIONS_INTERNES',
        '__AbsentNamespace0_typeParametrageTrafic_CONNEXIONS_INTERNES', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1136, 6), )

    CONNEXIONS_INTERNES = property(__CONNEXIONS_INTERNES.value, __CONNEXIONS_INTERNES.set, None,
                                   'Liste des connexions internes au r\xe9seau pour lesquelles des param\xe8tres de trafic sp\xe9cifiques sont d\xe9finis')


    # Element PARAMETRAGE_CAPTEURS uses Python identifier PARAMETRAGE_CAPTEURS
    __PARAMETRAGE_CAPTEURS = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'PARAMETRAGE_CAPTEURS'), 'PARAMETRAGE_CAPTEURS',
        '__AbsentNamespace0_typeParametrageTrafic_PARAMETRAGE_CAPTEURS', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1151, 6), )

    PARAMETRAGE_CAPTEURS = property(__PARAMETRAGE_CAPTEURS.value, __PARAMETRAGE_CAPTEURS.set, None,
                                    'Param\xe9trage des capteurs du r\xe9seau')


    # Element CONTROLEURS_DE_FEUX uses Python identifier CONTROLEURS_DE_FEUX
    __CONTROLEURS_DE_FEUX = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'CONTROLEURS_DE_FEUX'), 'CONTROLEURS_DE_FEUX',
        '__AbsentNamespace0_typeParametrageTrafic_CONTROLEURS_DE_FEUX', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1156, 6), )

    CONTROLEURS_DE_FEUX = property(__CONTROLEURS_DE_FEUX.value, __CONTROLEURS_DE_FEUX.set, None,
                                   'Liste des contr\xf4leurs de feux\n')


    # Element REGULATIONS uses Python identifier REGULATIONS
    __REGULATIONS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'REGULATIONS'),
                                                            'REGULATIONS',
                                                            '__AbsentNamespace0_typeParametrageTrafic_REGULATIONS',
                                                            False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1173, 6), )

    REGULATIONS = property(__REGULATIONS.value, __REGULATIONS.set, None,
                           'Liste des briques de r\xe9gulation de trafic d\xe9finies')


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeParametrageTrafic_id', pyxb.binding.datatypes.ID,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1188, 4)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1188, 4)

    id = property(__id.value, __id.set, None, 'Identifiant de la section TRAFIC')


    # Attribute accbornee uses Python identifier accbornee
    __accbornee = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'accbornee'), 'accbornee',
                                                    '__AbsentNamespace0_typeParametrageTrafic_accbornee',
                                                    pyxb.binding.datatypes.boolean, required=True)
    __accbornee._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1193, 4)
    __accbornee._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1193, 4)

    accbornee = property(__accbornee.value, __accbornee.set, None, "Simulation de l'acc\xe9l\xe9ration born\xe9e ")


    # Attribute chgtvoie uses Python identifier chgtvoie
    __chgtvoie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'chgtvoie'), 'chgtvoie',
                                                   '__AbsentNamespace0_typeParametrageTrafic_chgtvoie',
                                                   pyxb.binding.datatypes.boolean, unicode_default='true')
    __chgtvoie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1198, 4)
    __chgtvoie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1198, 4)

    chgtvoie = property(__chgtvoie.value, __chgtvoie.set, None, 'Simulation du changement de voie')


    # Attribute chgtvoie_mandatory_falpha uses Python identifier chgtvoie_mandatory_falpha
    __chgtvoie_mandatory_falpha = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'chgtvoie_mandatory_falpha'), 'chgtvoie_mandatory_falpha',
        '__AbsentNamespace0_typeParametrageTrafic_chgtvoie_mandatory_falpha', pyxb.binding.datatypes.float,
        unicode_default='0.5')
    __chgtvoie_mandatory_falpha._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1203, 4)
    __chgtvoie_mandatory_falpha._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1203, 4)

    chgtvoie_mandatory_falpha = property(__chgtvoie_mandatory_falpha.value, __chgtvoie_mandatory_falpha.set, None,
                                         "Valeur du rapport alpha/(1+alpha) dans le cas d'un changement de voie 'mandatory' li\xe9e \xe0 une r\xe9duction de voie uniquement")


    # Attribute chgtvoie_mandatory_probabilite uses Python identifier chgtvoie_mandatory_probabilite
    __chgtvoie_mandatory_probabilite = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'chgtvoie_mandatory_probabilite'), 'chgtvoie_mandatory_probabilite',
        '__AbsentNamespace0_typeParametrageTrafic_chgtvoie_mandatory_probabilite', STD_ANON_14, unicode_default='U')
    __chgtvoie_mandatory_probabilite._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1208, 4)
    __chgtvoie_mandatory_probabilite._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1208, 4)

    chgtvoie_mandatory_probabilite = property(__chgtvoie_mandatory_probabilite.value,
                                              __chgtvoie_mandatory_probabilite.set, None,
                                              "Type de probabilit\xe9 dans le cas d'une changement de voie 'mandatory' : uniforme (U) ou distribu\xe9 (D)")


    # Attribute chgtvoie_mandatory_mode uses Python identifier chgtvoie_mandatory_mode
    __chgtvoie_mandatory_mode = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'chgtvoie_mandatory_mode'), 'chgtvoie_mandatory_mode',
        '__AbsentNamespace0_typeParametrageTrafic_chgtvoie_mandatory_mode', STD_ANON_15, unicode_default='S')
    __chgtvoie_mandatory_mode._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1227, 4)
    __chgtvoie_mandatory_mode._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1227, 4)

    chgtvoie_mandatory_mode = property(__chgtvoie_mandatory_mode.value, __chgtvoie_mandatory_mode.set, None,
                                       "Mode de gestion des changements de voie 'mandatory' : synchrone (S) ou asynchrone (A)")


    # Attribute chgtvoie_discr_ordre uses Python identifier chgtvoie_discr_ordre
    __chgtvoie_discr_ordre = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'chgtvoie_discr_ordre'), 'chgtvoie_discr_ordre',
        '__AbsentNamespace0_typeParametrageTrafic_chgtvoie_discr_ordre', STD_ANON_16, unicode_default='GD')
    __chgtvoie_discr_ordre._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1246, 4)
    __chgtvoie_discr_ordre._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1246, 4)

    chgtvoie_discr_ordre = property(__chgtvoie_discr_ordre.value, __chgtvoie_discr_ordre.set, None,
                                    "Ordre d'\xe9tude des voies possibles du changement de voie")


    # Attribute coeffrelax uses Python identifier coeffrelax
    __coeffrelax = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'coeffrelax'), 'coeffrelax',
                                                     '__AbsentNamespace0_typeParametrageTrafic_coeffrelax',
                                                     pyxb.binding.datatypes.float, unicode_default='1')
    __coeffrelax._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1270, 4)
    __coeffrelax._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1270, 4)

    coeffrelax = property(__coeffrelax.value, __coeffrelax.set, None, 'Coefficient de relaxation du r\xe9seau')


    # Attribute chgtvoie_dstfin uses Python identifier chgtvoie_dstfin
    __chgtvoie_dstfin = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'chgtvoie_dstfin'),
                                                          'chgtvoie_dstfin',
                                                          '__AbsentNamespace0_typeParametrageTrafic_chgtvoie_dstfin',
                                                          pyxb.binding.datatypes.float, unicode_default='50')
    __chgtvoie_dstfin._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1275, 4)
    __chgtvoie_dstfin._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1275, 4)

    chgtvoie_dstfin = property(__chgtvoie_dstfin.value, __chgtvoie_dstfin.set, None,
                               "Distance avant la fin du tron\xe7on pour forcer un changement de voie d'un v\xe9hicule si il ne se trouve pas sur la bonne voie pour prendre la prochaine direction (en m\xe8tre)")


    # Attribute agressivite uses Python identifier agressivite
    __agressivite = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'agressivite'), 'agressivite',
                                                      '__AbsentNamespace0_typeParametrageTrafic_agressivite',
                                                      pyxb.binding.datatypes.boolean, unicode_default='false')
    __agressivite._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1280, 4)
    __agressivite._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1280, 4)

    agressivite = property(__agressivite.value, __agressivite.set, None,
                           "Indique si la proc\xe9dure d'agressivit\xe9 des v\xe9hicules est appliqu\xe9e")


    # Attribute chgtvoie_ghost uses Python identifier chgtvoie_ghost
    __chgtvoie_ghost = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'chgtvoie_ghost'),
                                                         'chgtvoie_ghost',
                                                         '__AbsentNamespace0_typeParametrageTrafic_chgtvoie_ghost',
                                                         pyxb.binding.datatypes.boolean, unicode_default='0')
    __chgtvoie_ghost._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1285, 4)
    __chgtvoie_ghost._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1285, 4)

    chgtvoie_ghost = property(__chgtvoie_ghost.value, __chgtvoie_ghost.set, None,
                              "Indique si le changement de voie g\xe8re mod\xe9lise la transition d'une voie \xe0 l'autre (g\xe9n\xe9ration de ghost sur les voies)")


    # Attribute chgtvoie_ghost_durationMin uses Python identifier chgtvoie_ghost_durationMin
    __chgtvoie_ghost_durationMin = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'chgtvoie_ghost_durationMin'), 'chgtvoie_ghost_durationMin',
        '__AbsentNamespace0_typeParametrageTrafic_chgtvoie_ghost_durationMin', typeFloatPositif, unicode_default='0')
    __chgtvoie_ghost_durationMin._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1290, 4)
    __chgtvoie_ghost_durationMin._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1290, 4)

    chgtvoie_ghost_durationMin = property(__chgtvoie_ghost_durationMin.value, __chgtvoie_ghost_durationMin.set, None,
                                          "Minimum de la dur\xe9e en seconde de l'existence des ghosts suite \xe0 une changement de voie")


    # Attribute chgtvoie_ghost_durationMax uses Python identifier chgtvoie_ghost_durationMax
    __chgtvoie_ghost_durationMax = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'chgtvoie_ghost_durationMax'), 'chgtvoie_ghost_durationMax',
        '__AbsentNamespace0_typeParametrageTrafic_chgtvoie_ghost_durationMax', typeFloatPositif, unicode_default='8')
    __chgtvoie_ghost_durationMax._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1296, 4)
    __chgtvoie_ghost_durationMax._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1296, 4)

    chgtvoie_ghost_durationMax = property(__chgtvoie_ghost_durationMax.value, __chgtvoie_ghost_durationMax.set, None,
                                          "Maximum de la dur\xe9e en seconde de l'existence des ghosts suite \xe0 une changement de voie")


    # Attribute chgtvoie_ghost_lenghtBevel uses Python identifier chgtvoie_ghost_lenghtBevel
    __chgtvoie_ghost_lenghtBevel = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'chgtvoie_ghost_lenghtBevel'), 'chgtvoie_ghost_lenghtBevel',
        '__AbsentNamespace0_typeParametrageTrafic_chgtvoie_ghost_lenghtBevel', typeFloatPositif, unicode_default='20')
    __chgtvoie_ghost_lenghtBevel._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1302, 4)
    __chgtvoie_ghost_lenghtBevel._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1302, 4)

    chgtvoie_ghost_lenghtBevel = property(__chgtvoie_ghost_lenghtBevel.value, __chgtvoie_ghost_lenghtBevel.set, None,
                                          "Dans le cas d'une r\xe9duction de voie, longueur utile en fin de tron\xe7on pour effectuer la proc\xe9dure de ghost (le v\xe9hicule sur la voie r\xe9duite s'arr\xeatera donc \xe0 longueur(troncon) - chgtvoie_ghost_lengthBevel )")


    # Attribute PeriodeAgregationCapteurs uses Python identifier PeriodeAgregationCapteurs
    __PeriodeAgregationCapteurs = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'PeriodeAgregationCapteurs'), 'PeriodeAgregationCapteurs',
        '__AbsentNamespace0_typeParametrageTrafic_PeriodeAgregationCapteurs', typeFloatStrictPositif,
        unicode_default='30')
    __PeriodeAgregationCapteurs._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1307, 4)
    __PeriodeAgregationCapteurs._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1307, 4)

    PeriodeAgregationCapteurs = property(__PeriodeAgregationCapteurs.value, __PeriodeAgregationCapteurs.set, None,
                                         "P\xe9riode (en s) d'agr\xe9gation des capteurs")


    # Attribute Gamma uses Python identifier Gamma
    __Gamma = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Gamma'), 'Gamma',
                                                '__AbsentNamespace0_typeParametrageTrafic_Gamma',
                                                typeFloatStrictPositif, unicode_default='1')
    __Gamma._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1312, 4)
    __Gamma._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1312, 4)

    Gamma = property(__Gamma.value, __Gamma.set, None, 'Rapport Gamma')


    # Attribute Mu uses Python identifier Mu
    __Mu = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Mu'), 'Mu',
                                             '__AbsentNamespace0_typeParametrageTrafic_Mu', typeFloat01,
                                             unicode_default='1')
    __Mu._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1317, 4)
    __Mu._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1317, 4)

    Mu = property(__Mu.value, __Mu.set, None, 'Coefficient de priorit\xe9')


    # Attribute Beta uses Python identifier Beta
    __Beta = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'Beta'), 'Beta',
                                               '__AbsentNamespace0_typeParametrageTrafic_Beta', typeFloat01,
                                               unicode_default='0.5')
    __Beta._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1322, 4)
    __Beta._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1322, 4)

    Beta = property(__Beta.value, __Beta.set, None,
                    "Pour giratoires uniquement : probabilit\xe9 pour un v\xe9hicule voulant s'ins\xe9rer de d\xe9tecter un v\xe9hicule sortant du giratoire en r\xe9gime fluide (le v\xe9hicule sortant d\xe9tect\xe9 ne g\xe8ne pas l'insertion).")


    # Attribute BetaInt uses Python identifier BetaInt
    __BetaInt = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'BetaInt'), 'BetaInt',
                                                  '__AbsentNamespace0_typeParametrageTrafic_BetaInt', typeFloat01,
                                                  unicode_default='0.3')
    __BetaInt._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1327, 4)
    __BetaInt._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1327, 4)

    BetaInt = property(__BetaInt.value, __BetaInt.set, None,
                       "Pour giratoires uniquement : probabilit\xe9 pour un v\xe9hicule voulant s'ins\xe9rer d'\xeatre g\xe9n\xe9 par un v\xe9hicule arrivant sur la voie interne du giratoire en r\xe9gime fluide (\xe0 d\xe9finir uniquement dans le cas d'un giratoire \xe0 2 voies)")


    # Attribute pos_cpt_Av uses Python identifier pos_cpt_Av
    __pos_cpt_Av = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'pos_cpt_Av'), 'pos_cpt_Av',
                                                     '__AbsentNamespace0_typeParametrageTrafic_pos_cpt_Av',
                                                     typeFloatPositif, unicode_default='20')
    __pos_cpt_Av._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1332, 4)
    __pos_cpt_Av._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1332, 4)

    pos_cpt_Av = property(__pos_cpt_Av.value, __pos_cpt_Av.set, None,
                          'Pour convergents uniquement : Position (en m\xe8tre) du capteur sur le tron\xe7on aval')


    # Attribute ti uses Python identifier ti
    __ti = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'ti'), 'ti',
                                             '__AbsentNamespace0_typeParametrageTrafic_ti', typeFloatPositif,
                                             unicode_default='0')
    __ti._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1337, 4)
    __ti._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1337, 4)

    ti = property(__ti.value, __ti.set, None, "Temps (en seconde) d'insertion")


    # Attribute tt uses Python identifier tt
    __tt = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'tt'), 'tt',
                                             '__AbsentNamespace0_typeParametrageTrafic_tt', typeFloatPositif,
                                             unicode_default='0')
    __tt._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1342, 4)
    __tt._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1342, 4)

    tt = property(__tt.value, __tt.set, None, 'Temps (en seconde) de travers\xe9e')


    # Attribute depassement uses Python identifier depassement
    __depassement = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'depassement'), 'depassement',
                                                      '__AbsentNamespace0_typeParametrageTrafic_depassement',
                                                      pyxb.binding.datatypes.boolean, unicode_default='true')
    __depassement._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1347, 4)
    __depassement._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1347, 4)

    depassement = property(__depassement.value, __depassement.set, None,
                           'Simulation du d\xe9passement (par passage sur tron\xe7on oppos\xe9)')


    # Attribute traversees uses Python identifier traversees
    __traversees = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'traversees'), 'traversees',
                                                     '__AbsentNamespace0_typeParametrageTrafic_traversees',
                                                     pyxb.binding.datatypes.boolean, unicode_default='true')
    __traversees._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1352, 4)
    __traversees._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1352, 4)

    traversees = property(__traversees.value, __traversees.set, None,
                          "Permet d'activer o\xf9 non la gestion globale des conflits de travers\xe9e au niveau des briques de connexion et de la travers\xe9e des voies interdites ")

    _ElementMap.update({
        __TRONCONS.name(): __TRONCONS,
        __TYPES_DE_VEHICULE.name(): __TYPES_DE_VEHICULE,
        __EXTREMITES.name(): __EXTREMITES,
        __PARKINGS.name(): __PARKINGS,
        __ZONES_DE_TERMINAISON.name(): __ZONES_DE_TERMINAISON,
        __CONNEXIONS_INTERNES.name(): __CONNEXIONS_INTERNES,
        __PARAMETRAGE_CAPTEURS.name(): __PARAMETRAGE_CAPTEURS,
        __CONTROLEURS_DE_FEUX.name(): __CONTROLEURS_DE_FEUX,
        __REGULATIONS.name(): __REGULATIONS
    })
    _AttributeMap.update({
        __id.name(): __id,
        __accbornee.name(): __accbornee,
        __chgtvoie.name(): __chgtvoie,
        __chgtvoie_mandatory_falpha.name(): __chgtvoie_mandatory_falpha,
        __chgtvoie_mandatory_probabilite.name(): __chgtvoie_mandatory_probabilite,
        __chgtvoie_mandatory_mode.name(): __chgtvoie_mandatory_mode,
        __chgtvoie_discr_ordre.name(): __chgtvoie_discr_ordre,
        __coeffrelax.name(): __coeffrelax,
        __chgtvoie_dstfin.name(): __chgtvoie_dstfin,
        __agressivite.name(): __agressivite,
        __chgtvoie_ghost.name(): __chgtvoie_ghost,
        __chgtvoie_ghost_durationMin.name(): __chgtvoie_ghost_durationMin,
        __chgtvoie_ghost_durationMax.name(): __chgtvoie_ghost_durationMax,
        __chgtvoie_ghost_lenghtBevel.name(): __chgtvoie_ghost_lenghtBevel,
        __PeriodeAgregationCapteurs.name(): __PeriodeAgregationCapteurs,
        __Gamma.name(): __Gamma,
        __Mu.name(): __Mu,
        __Beta.name(): __Beta,
        __BetaInt.name(): __BetaInt,
        __pos_cpt_Av.name(): __pos_cpt_Av,
        __ti.name(): __ti,
        __tt.name(): __tt,
        __depassement.name(): __depassement,
        __traversees.name(): __traversees
    })


Namespace.addCategoryObject('typeBinding', 'typeParametrageTrafic', typeParametrageTrafic)


# Complex type typeSimulationElement with content type EMPTY
class typeSimulationElement(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeSimulationElement with content type EMPTY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeSimulationElement')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1541, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeSimulationElement_id',
                                             pyxb.binding.datatypes.string, required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1542, 4)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1542, 4)

    id = property(__id.value, __id.set, None, "Identifiant de l'\xe9l\xe9ment du r\xe9seau associ\xe9")


    # Attribute resolution uses Python identifier resolution
    __resolution = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'resolution'), 'resolution',
                                                     '__AbsentNamespace0_typeSimulationElement_resolution', STD_ANON_17)
    __resolution._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1547, 4)
    __resolution._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1547, 4)

    resolution = property(__resolution.value, __resolution.set, None,
                          "R\xe9solution de l'\xe9l\xe9ment du r\xe9seau associ\xe9")


    # Attribute nb_cell_acoustique uses Python identifier nb_cell_acoustique
    __nb_cell_acoustique = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'nb_cell_acoustique'),
                                                             'nb_cell_acoustique',
                                                             '__AbsentNamespace0_typeSimulationElement_nb_cell_acoustique',
                                                             pyxb.binding.datatypes.nonNegativeInteger)
    __nb_cell_acoustique._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1571, 4)
    __nb_cell_acoustique._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1571, 4)

    nb_cell_acoustique = property(__nb_cell_acoustique.value, __nb_cell_acoustique.set, None,
                                  'Nombre de cellule(s) acoustique(s)')


    # Attribute longueur_cell_acoustique uses Python identifier longueur_cell_acoustique
    __longueur_cell_acoustique = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'longueur_cell_acoustique'), 'longueur_cell_acoustique',
        '__AbsentNamespace0_typeSimulationElement_longueur_cell_acoustique', typeFloatPositif)
    __longueur_cell_acoustique._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1576, 4)
    __longueur_cell_acoustique._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1576, 4)

    longueur_cell_acoustique = property(__longueur_cell_acoustique.value, __longueur_cell_acoustique.set, None,
                                        "Longueur (en m\xe8tre) d\xe9sir\xe9e des cellules acoustiques de l'\xe9l\xe9ment. (pour chaque tron\xe7on / tron\xe7on interne, le nombre de cellules acoustiques sera calcul\xe9e afin d'approcher au mieux la longueur de cellule d\xe9sir\xe9e)")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id.name(): __id,
        __resolution.name(): __resolution,
        __nb_cell_acoustique.name(): __nb_cell_acoustique,
        __longueur_cell_acoustique.name(): __longueur_cell_acoustique
    })


Namespace.addCategoryObject('typeBinding', 'typeSimulationElement', typeSimulationElement)


# Complex type typeTraficTroncon with content type EMPTY
class typeTraficTroncon(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeTraficTroncon with content type EMPTY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeTraficTroncon')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1582, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeTraficTroncon_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1583, 4)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1583, 4)

    id = property(__id.value, __id.set, None, 'Identifiant du tron\xe7on associ\xe9')


    # Attribute agressivite uses Python identifier agressivite
    __agressivite = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'agressivite'), 'agressivite',
                                                      '__AbsentNamespace0_typeTraficTroncon_agressivite',
                                                      pyxb.binding.datatypes.boolean, unicode_default='false')
    __agressivite._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1588, 4)
    __agressivite._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1588, 4)

    agressivite = property(__agressivite.value, __agressivite.set, None,
                           'Indique si les v\xe9hicules positionn\xe9s sur le tron\xe7on peuvent avoir un comportement agressif')


    # Attribute penalisation uses Python identifier penalisation
    __penalisation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'penalisation'),
                                                       'penalisation',
                                                       '__AbsentNamespace0_typeTraficTroncon_penalisation',
                                                       typeFloatPositif, unicode_default='1')
    __penalisation._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1593, 4)
    __penalisation._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1593, 4)

    penalisation = property(__penalisation.value, __penalisation.set, None,
                            "Coefficient de p\xe9nalisation du tron\xe7on pour le caclul d'affectation. Le co\xfbt non p\xe9nalis\xe9 du tron\xe7on est multipli\xe9 par ce coefficient dans les calculs. Un coefficient de 1 (valeur par d\xe9faut) n'a pas d'effet.")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id.name(): __id,
        __agressivite.name(): __agressivite,
        __penalisation.name(): __penalisation
    })


Namespace.addCategoryObject('typeBinding', 'typeTraficTroncon', typeTraficTroncon)


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_129(pyxb.binding.basis.complexTypeDefinition):
    """Description d'une voie rÃ©duite"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1611, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute numvoie uses Python identifier numvoie
    __numvoie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'numvoie'), 'numvoie',
                                                  '__AbsentNamespace0_CTD_ANON_129_numvoie', typeIntStrictPositif,
                                                  required=True)
    __numvoie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1612, 16)
    __numvoie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1612, 16)

    numvoie = property(__numvoie.value, __numvoie.set, None, 'Num\xe9ro de voie r\xe9duite')


    # Attribute exclusion_types_vehicules uses Python identifier exclusion_types_vehicules
    __exclusion_types_vehicules = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'exclusion_types_vehicules'), 'exclusion_types_vehicules',
        '__AbsentNamespace0_CTD_ANON_129_exclusion_types_vehicules', pyxb.binding.datatypes.string)
    __exclusion_types_vehicules._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1617, 16)
    __exclusion_types_vehicules._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1617, 16)

    exclusion_types_vehicules = property(__exclusion_types_vehicules.value, __exclusion_types_vehicules.set, None,
                                         "Liste des identifiants des types de v\xe9hicules pour lesquels la voie r\xe9duite ne s'applique pas")


    # Attribute active uses Python identifier active
    __active = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'active'), 'active',
                                                 '__AbsentNamespace0_CTD_ANON_129_active',
                                                 pyxb.binding.datatypes.boolean, unicode_default='true')
    __active._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1622, 16)
    __active._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1622, 16)

    active = property(__active.value, __active.set, None,
                      'Indique si la voie r\xe9duite est active ou non (utile pour d\xe9sactiver une voie r\xe9duite existante)')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __numvoie.name(): __numvoie,
        __exclusion_types_vehicules.name(): __exclusion_types_vehicules,
        __active.name(): __active
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_130(pyxb.binding.basis.complexTypeDefinition):
    """Description des vitesses rÃ©glementaires du tronÃ§on pour une variante temporelle donnÃ©e"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1642, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element VITESSE_REG_PAR_TYPE uses Python identifier VITESSE_REG_PAR_TYPE
    __VITESSE_REG_PAR_TYPE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'VITESSE_REG_PAR_TYPE'), 'VITESSE_REG_PAR_TYPE',
        '__AbsentNamespace0_CTD_ANON_130_VITESSE_REG_PAR_TYPE', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1644, 18), )

    VITESSE_REG_PAR_TYPE = property(__VITESSE_REG_PAR_TYPE.value, __VITESSE_REG_PAR_TYPE.set, None,
                                    'Description des vitesses r\xe9glementaires du tron\xe7on pour une liste de types de v\xe9hicules donn\xe9e')


    # Attribute duree uses Python identifier duree
    __duree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree'), 'duree',
                                                '__AbsentNamespace0_CTD_ANON_130_duree', typeDuree,
                                                unicode_default='always')
    __duree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1689, 16)
    __duree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1689, 16)

    duree = property(__duree.value, __duree.set, None,
                     'Identifiant de la plage temporelle associ\xe9e, ou dur\xe9e (en seconde) de la variante de vitesse')

    _ElementMap.update({
        __VITESSE_REG_PAR_TYPE.name(): __VITESSE_REG_PAR_TYPE
    })
    _AttributeMap.update({
        __duree.name(): __duree
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_131(pyxb.binding.basis.complexTypeDefinition):
    """Description de al vitesse rÃ©glementaire pour une voie et Ã©ventuellement une portion spaciale donnÃ©e"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1654, 26)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute numvoie uses Python identifier numvoie
    __numvoie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'numvoie'), 'numvoie',
                                                  '__AbsentNamespace0_CTD_ANON_131_numvoie', typeIntStrictPositif)
    __numvoie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1655, 28)
    __numvoie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1655, 28)

    numvoie = property(__numvoie.value, __numvoie.set, None,
                       'Num\xe9ro de voie concern\xe9. Par d\xe9faut, toutes les voies le sont.')


    # Attribute position_debut uses Python identifier position_debut
    __position_debut = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position_debut'),
                                                         'position_debut',
                                                         '__AbsentNamespace0_CTD_ANON_131_position_debut',
                                                         typeFloatPositif, unicode_default='0')
    __position_debut._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1660, 28)
    __position_debut._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1660, 28)

    position_debut = property(__position_debut.value, __position_debut.set, None,
                              'position curviligne \xe0 partir du troncon o\xf9 commence la vitesse r\xe9glementaire')


    # Attribute position_fin uses Python identifier position_fin
    __position_fin = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position_fin'),
                                                       'position_fin', '__AbsentNamespace0_CTD_ANON_131_position_fin',
                                                       typeFloatPositif, unicode_default='INF')
    __position_fin._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1666, 28)
    __position_fin._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1666, 28)

    position_fin = property(__position_fin.value, __position_fin.set, None,
                            'position curviligne \xe0 partir du troncon o\xf9 se termine la vitesse r\xe9glementaire')


    # Attribute vitesse uses Python identifier vitesse
    __vitesse = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'vitesse'), 'vitesse',
                                                  '__AbsentNamespace0_CTD_ANON_131_vitesse', typeFloatStrictPositif,
                                                  required=True)
    __vitesse._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1672, 28)
    __vitesse._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1672, 28)

    vitesse = property(__vitesse.value, __vitesse.set, None, 'Vitesse r\xe9glementaire (en m/s)')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __numvoie.name(): __numvoie,
        __position_debut.name(): __position_debut,
        __position_fin.name(): __position_fin,
        __vitesse.name(): __vitesse
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_132(pyxb.binding.basis.complexTypeDefinition):
    """Temps de traversÃ©e du tronÃ§on prioritaire pour un type de vÃ©hicule"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1728, 26)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id_typevehicule uses Python identifier id_typevehicule
    __id_typevehicule = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_typevehicule'),
                                                          'id_typevehicule',
                                                          '__AbsentNamespace0_CTD_ANON_132_id_typevehicule',
                                                          pyxb.binding.datatypes.string, required=True)
    __id_typevehicule._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1729, 28)
    __id_typevehicule._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1729, 28)

    id_typevehicule = property(__id_typevehicule.value, __id_typevehicule.set, None,
                               'Identifiant du type de v\xe9hicule concern\xe9')


    # Attribute tf uses Python identifier tf
    __tf = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'tf'), 'tf',
                                             '__AbsentNamespace0_CTD_ANON_132_tf', typeFloatStrictPositif,
                                             required=True)
    __tf._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1734, 28)
    __tf._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1734, 28)

    tf = property(__tf.value, __tf.set, None, 'Temps (en seconde) de travers\xe9e')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id_typevehicule.name(): __id_typevehicule,
        __tf.name(): __tf
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_133(pyxb.binding.basis.complexTypeDefinition):
    """DÃ©finition d'une voie rÃ©servÃ©e"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1765, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute num_voie uses Python identifier num_voie
    __num_voie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'num_voie'), 'num_voie',
                                                   '__AbsentNamespace0_CTD_ANON_133_num_voie',
                                                   pyxb.binding.datatypes.positiveInteger, required=True)
    __num_voie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1766, 16)
    __num_voie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1766, 16)

    num_voie = property(__num_voie.value, __num_voie.set, None, 'Num\xe9ro de la voie r\xe9serv\xe9e sur le tron\xe7on')


    # Attribute largeur_voie uses Python identifier largeur_voie
    __largeur_voie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'largeur_voie'),
                                                       'largeur_voie', '__AbsentNamespace0_CTD_ANON_133_largeur_voie',
                                                       typeFloatPositif)
    __largeur_voie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1771, 16)
    __largeur_voie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1771, 16)

    largeur_voie = property(__largeur_voie.value, __largeur_voie.set, None, 'Largeur de la voie r\xe9serv\xe9e')


    # Attribute id_typesvehicules uses Python identifier id_typesvehicules
    __id_typesvehicules = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_typesvehicules'),
                                                            'id_typesvehicules',
                                                            '__AbsentNamespace0_CTD_ANON_133_id_typesvehicules',
                                                            pyxb.binding.datatypes.string, required=True)
    __id_typesvehicules._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1776, 16)
    __id_typesvehicules._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1776, 16)

    id_typesvehicules = property(__id_typesvehicules.value, __id_typesvehicules.set, None,
                                 'Liste des identifiants des types de v\xe9hicule pour lesquels la voie est r\xe9serv\xe9e')


    # Attribute duree uses Python identifier duree
    __duree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree'), 'duree',
                                                '__AbsentNamespace0_CTD_ANON_133_duree', typeDuree,
                                                unicode_default='always')
    __duree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1781, 16)
    __duree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1781, 16)

    duree = property(__duree.value, __duree.set, None,
                     'Identifiant de la plage temporelle associ\xe9e, ou dur\xe9e (en seconde) de la voie r\xe9serv\xe9e. Par d\xe9faut, la voie est r\xe9serv\xe9e pour toute la simulation.')


    # Attribute active uses Python identifier active
    __active = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'active'), 'active',
                                                 '__AbsentNamespace0_CTD_ANON_133_active',
                                                 pyxb.binding.datatypes.boolean, unicode_default='true')
    __active._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1786, 16)
    __active._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1786, 16)

    active = property(__active.value, __active.set, None,
                      'Indique si la voie r\xe9serv\xe9e doit \xeatre activ\xe9e ou d\xe9sactiv\xe9e')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __num_voie.name(): __num_voie,
        __largeur_voie.name(): __largeur_voie,
        __id_typesvehicules.name(): __id_typesvehicules,
        __duree.name(): __duree,
        __active.name(): __active
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_134(pyxb.binding.basis.complexTypeDefinition):
    """Terre-plein prÃ©sent sur le tronÃ§on"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1829, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TERRE_PLEIN_VARIATION uses Python identifier TERRE_PLEIN_VARIATION
    __TERRE_PLEIN_VARIATION = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'TERRE_PLEIN_VARIATION'), 'TERRE_PLEIN_VARIATION',
        '__AbsentNamespace0_CTD_ANON_134_TERRE_PLEIN_VARIATION', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1831, 18), )

    TERRE_PLEIN_VARIATION = property(__TERRE_PLEIN_VARIATION.value, __TERRE_PLEIN_VARIATION.set, None,
                                     'Variation temporelle de la pr\xe9sence du terre-plein')


    # Attribute num_voie uses Python identifier num_voie
    __num_voie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'num_voie'), 'num_voie',
                                                   '__AbsentNamespace0_CTD_ANON_134_num_voie',
                                                   pyxb.binding.datatypes.positiveInteger, required=True)
    __num_voie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1849, 16)
    __num_voie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1849, 16)

    num_voie = property(__num_voie.value, __num_voie.set, None,
                        'Num\xe9ro de la voie \xe0 gauche de laquelle se trouve le terre-plein')


    # Attribute position_debut uses Python identifier position_debut
    __position_debut = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position_debut'),
                                                         'position_debut',
                                                         '__AbsentNamespace0_CTD_ANON_134_position_debut',
                                                         typeFloatPositif, unicode_default='0')
    __position_debut._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1854, 16)
    __position_debut._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1854, 16)

    position_debut = property(__position_debut.value, __position_debut.set, None,
                              'Position curviligne du d\xe9but du terre-plein sur le tron\xe7on (en m)')


    # Attribute position_fin uses Python identifier position_fin
    __position_fin = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position_fin'),
                                                       'position_fin', '__AbsentNamespace0_CTD_ANON_134_position_fin',
                                                       typeFloatPositif, unicode_default='INF')
    __position_fin._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1859, 16)
    __position_fin._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1859, 16)

    position_fin = property(__position_fin.value, __position_fin.set, None,
                            'Position curviligne de la fin du terre-plein sur le tron\xe7on (en m)')

    _ElementMap.update({
        __TERRE_PLEIN_VARIATION.name(): __TERRE_PLEIN_VARIATION
    })
    _AttributeMap.update({
        __num_voie.name(): __num_voie,
        __position_debut.name(): __position_debut,
        __position_fin.name(): __position_fin
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_135(pyxb.binding.basis.complexTypeDefinition):
    """Variation temporelle de la prÃ©sence du terre-plein"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1835, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute duree uses Python identifier duree
    __duree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree'), 'duree',
                                                '__AbsentNamespace0_CTD_ANON_135_duree', typeDuree,
                                                unicode_default='always')
    __duree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1836, 22)
    __duree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1836, 22)

    duree = property(__duree.value, __duree.set, None,
                     'Identifiant de la plage temporelle associ\xe9e, ou dur\xe9e (en seconde) de la pr\xe9sence du terre plein pour cette variation temporelle')


    # Attribute actif uses Python identifier actif
    __actif = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'actif'), 'actif',
                                                '__AbsentNamespace0_CTD_ANON_135_actif', pyxb.binding.datatypes.boolean,
                                                unicode_default='true')
    __actif._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1841, 22)
    __actif._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1841, 22)

    actif = property(__actif.value, __actif.set, None,
                     'Indique si le terre-plein est actif ou non pendant la variation temporelle')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __duree.name(): __duree,
        __actif.name(): __actif
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_136(pyxb.binding.basis.complexTypeDefinition):
    """Zone dans laquelle le dÃ©passement par passage sur la voie de gauche du tronÃ§on opposÃ© est interdit"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1879, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute position_debut uses Python identifier position_debut
    __position_debut = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position_debut'),
                                                         'position_debut',
                                                         '__AbsentNamespace0_CTD_ANON_136_position_debut',
                                                         typeFloatPositif, unicode_default='0')
    __position_debut._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1880, 16)
    __position_debut._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1880, 16)

    position_debut = property(__position_debut.value, __position_debut.set, None,
                              'Position curviligne du d\xe9but de la zone de d\xe9passement autoris\xe9e')


    # Attribute position_fin uses Python identifier position_fin
    __position_fin = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position_fin'),
                                                       'position_fin', '__AbsentNamespace0_CTD_ANON_136_position_fin',
                                                       typeFloatPositif, unicode_default='INF')
    __position_fin._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1885, 16)
    __position_fin._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1885, 16)

    position_fin = property(__position_fin.value, __position_fin.set, None,
                            'Position curviligne de la fin de la zone de d\xe9passement autoris\xe9')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __position_debut.name(): __position_debut,
        __position_fin.name(): __position_fin
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_137(pyxb.binding.basis.complexTypeDefinition):
    """Zone dans laquelle le trafic ne doit pas Ãªtre pris en compte. A exploiter au niveau des outils de post-traitement."""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1905, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute position_debut uses Python identifier position_debut
    __position_debut = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position_debut'),
                                                         'position_debut',
                                                         '__AbsentNamespace0_CTD_ANON_137_position_debut',
                                                         typeFloatPositif, unicode_default='0')
    __position_debut._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1906, 16)
    __position_debut._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1906, 16)

    position_debut = property(__position_debut.value, __position_debut.set, None,
                              "Position curviligne du d\xe9but de la zone d'exclusion")


    # Attribute position_fin uses Python identifier position_fin
    __position_fin = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position_fin'),
                                                       'position_fin', '__AbsentNamespace0_CTD_ANON_137_position_fin',
                                                       typeFloatPositif, unicode_default='INF')
    __position_fin._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1911, 16)
    __position_fin._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1911, 16)

    position_fin = property(__position_fin.value, __position_fin.set, None,
                            "Position curviligne de la fin de la zone d'exclusion")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __position_debut.name(): __position_debut,
        __position_fin.name(): __position_fin
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_138(pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type EMPTY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1928, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute start uses Python identifier start
    __start = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'start'), 'start',
                                                '__AbsentNamespace0_CTD_ANON_138_start', typeFloatPositif,
                                                unicode_default='0')
    __start._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1929, 16)
    __start._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1929, 16)

    start = property(__start.value, __start.set, None,
                     "Gestion des multi-niveaux des \xe9l\xe9ments du r\xe9seau (ponts, tunnels...): position du d\xe9but de la section du tron\xe7on d'application du z-level\nPar d\xe9faut, le z-level est appliqu\xe9 sur tout le tron\xe7on")


    # Attribute end uses Python identifier end
    __end = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'end'), 'end',
                                              '__AbsentNamespace0_CTD_ANON_138_end', typeFloatPositif,
                                              unicode_default='INF')
    __end._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1935, 16)
    __end._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1935, 16)

    end = property(__end.value, __end.set, None,
                   "Gestion des multi-niveaux des \xe9l\xe9ments du r\xe9seau (ponts, tunnels...): position de fin de la section du tron\xe7on d'application du z-level\nPar d\xe9faut, le z-level est appliqu\xe9 sur tout le tron\xe7on")


    # Attribute zlevel uses Python identifier zlevel
    __zlevel = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'zlevel'), 'zlevel',
                                                 '__AbsentNamespace0_CTD_ANON_138_zlevel', pyxb.binding.datatypes.int,
                                                 unicode_default='0')
    __zlevel._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1941, 16)
    __zlevel._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1941, 16)

    zlevel = property(__zlevel.value, __zlevel.set, None,
                      'Gestion des multi-niveaux des \xe9l\xe9ments du r\xe9seau (ponts, tunnels...): valeur du z-level')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __start.name(): __start,
        __end.name(): __end,
        __zlevel.name(): __zlevel
    })


# Complex type typeRepartiteur with content type ELEMENT_ONLY
class typeRepartiteur(typeConnexionInterne):
    """Complex type typeRepartiteur with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeRepartiteur')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2042, 2)
    _ElementMap = typeConnexionInterne._ElementMap.copy()
    _AttributeMap = typeConnexionInterne._AttributeMap.copy()
    # Base type is typeConnexionInterne

    # Element MOUVEMENTS_AUTORISES (MOUVEMENTS_AUTORISES) inherited from typeConnexionInterne

    # Attribute z_level_crossing inherited from typeConnexionInterne

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeRepartiteur_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2045, 8)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2045, 8)

    id = property(__id.value, __id.set, None, 'Identifiant du r\xe9partiteur')


    # Attribute controleur_de_feux uses Python identifier controleur_de_feux
    __controleur_de_feux = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'controleur_de_feux'),
                                                             'controleur_de_feux',
                                                             '__AbsentNamespace0_typeRepartiteur_controleur_de_feux',
                                                             pyxb.binding.datatypes.string)
    __controleur_de_feux._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2050, 8)
    __controleur_de_feux._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2050, 8)

    controleur_de_feux = property(__controleur_de_feux.value, __controleur_de_feux.set, None,
                                  'Identifiant du contr\xf4leur de feux du r\xe9partiteur (il doit \xeatre d\xe9fini dans la liste des contr\xf4leurs de feux)')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id.name(): __id,
        __controleur_de_feux.name(): __controleur_de_feux
    })


Namespace.addCategoryObject('typeBinding', 'typeRepartiteur', typeRepartiteur)


# Complex type typeConvergent with content type ELEMENT_ONLY
class typeConvergent(typeConnexionInterne):
    """Complex type typeConvergent with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeConvergent')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2058, 2)
    _ElementMap = typeConnexionInterne._ElementMap.copy()
    _AttributeMap = typeConnexionInterne._AttributeMap.copy()
    # Base type is typeConnexionInterne

    # Element MOUVEMENTS_AUTORISES (MOUVEMENTS_AUTORISES) inherited from typeConnexionInterne

    # Element TRONCONS_AMONT uses Python identifier TRONCONS_AMONT
    __TRONCONS_AMONT = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRONCONS_AMONT'),
                                                               'TRONCONS_AMONT',
                                                               '__AbsentNamespace0_typeConvergent_TRONCONS_AMONT',
                                                               False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2062, 10), )

    TRONCONS_AMONT = property(__TRONCONS_AMONT.value, __TRONCONS_AMONT.set, None,
                              'Liste des tron\xe7ons amont du convergent')


    # Attribute z_level_crossing inherited from typeConnexionInterne

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeConvergent_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2095, 8)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2095, 8)

    id = property(__id.value, __id.set, None, 'Identifiant du convergent')


    # Attribute id_TAv uses Python identifier id_TAv
    __id_TAv = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_TAv'), 'id_TAv',
                                                 '__AbsentNamespace0_typeConvergent_id_TAv',
                                                 pyxb.binding.datatypes.string, required=True)
    __id_TAv._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2100, 8)
    __id_TAv._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2100, 8)

    id_TAv = property(__id_TAv.value, __id_TAv.set, None, 'Identifiant du tron\xe7on aval')


    # Attribute type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'type'), 'type',
                                               '__AbsentNamespace0_typeConvergent_type', STD_ANON_18,
                                               unicode_default='ponctuel')
    __type._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2105, 8)
    __type._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2105, 8)

    type = property(__type.value, __type.set, None,
                    'Indique le type de convergent \xe0 utiliser (ponctuel, insertion, ...)')


    # Attribute nb_voies_insertion_droite uses Python identifier nb_voies_insertion_droite
    __nb_voies_insertion_droite = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'nb_voies_insertion_droite'), 'nb_voies_insertion_droite',
        '__AbsentNamespace0_typeConvergent_nb_voies_insertion_droite', pyxb.binding.datatypes.int, unicode_default='0')
    __nb_voies_insertion_droite._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2124, 8)
    __nb_voies_insertion_droite._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2124, 8)

    nb_voies_insertion_droite = property(__nb_voies_insertion_droite.value, __nb_voies_insertion_droite.set, None,
                                         "Nombre de voies d'insertion \xe0 droite")


    # Attribute nb_voies_insertion_gauche uses Python identifier nb_voies_insertion_gauche
    __nb_voies_insertion_gauche = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'nb_voies_insertion_gauche'), 'nb_voies_insertion_gauche',
        '__AbsentNamespace0_typeConvergent_nb_voies_insertion_gauche', pyxb.binding.datatypes.int, unicode_default='0')
    __nb_voies_insertion_gauche._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2129, 8)
    __nb_voies_insertion_gauche._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2129, 8)

    nb_voies_insertion_gauche = property(__nb_voies_insertion_gauche.value, __nb_voies_insertion_gauche.set, None,
                                         "Nombre de voies d'insertion \xe0 droite")

    _ElementMap.update({
        __TRONCONS_AMONT.name(): __TRONCONS_AMONT
    })
    _AttributeMap.update({
        __id.name(): __id,
        __id_TAv.name(): __id_TAv,
        __type.name(): __type,
        __nb_voies_insertion_droite.name(): __nb_voies_insertion_droite,
        __nb_voies_insertion_gauche.name(): __nb_voies_insertion_gauche
    })


Namespace.addCategoryObject('typeBinding', 'typeConvergent', typeConvergent)


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_139(pyxb.binding.basis.complexTypeDefinition):
    """Description d'un tronÃ§on amont du convergent"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2072, 18)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_139_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2073, 20)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2073, 20)

    id = property(__id.value, __id.set, None, 'Identifiant du tron\xe7on amont')


    # Attribute priorite uses Python identifier priorite
    __priorite = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'priorite'), 'priorite',
                                                   '__AbsentNamespace0_CTD_ANON_139_priorite',
                                                   pyxb.binding.datatypes.nonNegativeInteger, unicode_default='0')
    __priorite._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2078, 20)
    __priorite._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2078, 20)

    priorite = property(__priorite.value, __priorite.set, None,
                        'Niveau de priorit\xe9 du tron\xe7on (1 priorit\xe9 la plus forte puis plus le niveau augmente, plus la priorit\xe9 diminue, 0 correspond \xe0 une priorit\xe9 non d\xe9finie). Si deux tron\xe7ons poss\xe8dent le m\xeame niveau de priorit\xe9, SymuVia applique la r\xe8gle de priorit\xe9 \xe0 droite')


    # Attribute pos_cpt uses Python identifier pos_cpt
    __pos_cpt = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'pos_cpt'), 'pos_cpt',
                                                  '__AbsentNamespace0_CTD_ANON_139_pos_cpt', typeFloatPositif,
                                                  unicode_default='20')
    __pos_cpt._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2083, 20)
    __pos_cpt._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2083, 20)

    pos_cpt = property(__pos_cpt.value, __pos_cpt.set, None,
                       'Position (en m\xe8tre) du capteur sur le tron\xe7on amont')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id.name(): __id,
        __priorite.name(): __priorite,
        __pos_cpt.name(): __pos_cpt
    })


# Complex type typeGiratoire with content type ELEMENT_ONLY
class typeGiratoire(typeConnexionInterne):
    """Complex type typeGiratoire with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeGiratoire')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2137, 2)
    _ElementMap = typeConnexionInterne._ElementMap.copy()
    _AttributeMap = typeConnexionInterne._AttributeMap.copy()
    # Base type is typeConnexionInterne

    # Element MOUVEMENTS_AUTORISES (MOUVEMENTS_AUTORISES) inherited from typeConnexionInterne

    # Element TRONCONS_INTERNES uses Python identifier TRONCONS_INTERNES
    __TRONCONS_INTERNES = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'TRONCONS_INTERNES'), 'TRONCONS_INTERNES',
        '__AbsentNamespace0_typeGiratoire_TRONCONS_INTERNES', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2141, 10), )

    TRONCONS_INTERNES = property(__TRONCONS_INTERNES.value, __TRONCONS_INTERNES.set, None,
                                 "Liste des tron\xe7ons composant l'anneau du giratoire")


    # Element COEFFICIENTS_INSERTION uses Python identifier COEFFICIENTS_INSERTION
    __COEFFICIENTS_INSERTION = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'COEFFICIENTS_INSERTION'), 'COEFFICIENTS_INSERTION',
        '__AbsentNamespace0_typeGiratoire_COEFFICIENTS_INSERTION', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2198, 10), )

    COEFFICIENTS_INSERTION = property(__COEFFICIENTS_INSERTION.value, __COEFFICIENTS_INSERTION.set, None,
                                      "Liste des coefficients permettant de d\xe9finir manuellement les taux de choix de la voie d'insertion d'un v\xe9hicule sur le giratoire (utile pour le cas de giratoires \xe0 plusieurs voies) en fonction de la voie d'entr\xe9e et du tron\xe7on de sortie")


    # Attribute z_level_crossing inherited from typeConnexionInterne

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeGiratoire_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2236, 8)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2236, 8)

    id = property(__id.value, __id.set, None, 'Identifiant unique du giratoire')


    # Attribute troncons uses Python identifier troncons
    __troncons = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'troncons'), 'troncons',
                                                   '__AbsentNamespace0_typeGiratoire_troncons',
                                                   pyxb.binding.datatypes.string, required=True)
    __troncons._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2241, 8)
    __troncons._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2241, 8)

    troncons = property(__troncons.value, __troncons.set, None,
                        "Liste des tron\xe7ons amont et aval du giratoire (ils doivent \xeatre d\xe9crit dans l'ordre de parcours de l'anneau du giratoire).")


    # Attribute revetement uses Python identifier revetement
    __revetement = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'revetement'), 'revetement',
                                                     '__AbsentNamespace0_typeGiratoire_revetement',
                                                     pyxb.binding.datatypes.string)
    __revetement._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2246, 8)
    __revetement._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2246, 8)

    revetement = property(__revetement.value, __revetement.set, None,
                          "Nom du rev\xeatement \xe0 l'int\xe9rieur du giratoire")


    # Attribute vit_max uses Python identifier vit_max
    __vit_max = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'vit_max'), 'vit_max',
                                                  '__AbsentNamespace0_typeGiratoire_vit_max', typeFloatStrictPositif,
                                                  required=True)
    __vit_max._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2251, 8)
    __vit_max._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2251, 8)

    vit_max = property(__vit_max.value, __vit_max.set, None, "Vitesse maximale sur l'anneau du giratoire (en m/s)")


    # Attribute nb_voie uses Python identifier nb_voie
    __nb_voie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'nb_voie'), 'nb_voie',
                                                  '__AbsentNamespace0_typeGiratoire_nb_voie', typeIntStrictPositif,
                                                  unicode_default='1')
    __nb_voie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2256, 8)
    __nb_voie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2256, 8)

    nb_voie = property(__nb_voie.value, __nb_voie.set, None, "Nombre de voie sur l'anneau")


    # Attribute LargeurVoie uses Python identifier LargeurVoie
    __LargeurVoie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'LargeurVoie'), 'LargeurVoie',
                                                      '__AbsentNamespace0_typeGiratoire_LargeurVoie',
                                                      typeFloatStrictPositif, required=True)
    __LargeurVoie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2261, 8)
    __LargeurVoie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2261, 8)

    LargeurVoie = property(__LargeurVoie.value, __LargeurVoie.set, None, 'Largeur de la voie (en m\xe8tre)')


    # Attribute type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'type'), 'type',
                                               '__AbsentNamespace0_typeGiratoire_type', STD_ANON_19,
                                               unicode_default='U')
    __type._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2266, 8)
    __type._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2266, 8)

    type = property(__type.value, __type.set, None, 'Type de tron\xe7on')

    _ElementMap.update({
        __TRONCONS_INTERNES.name(): __TRONCONS_INTERNES,
        __COEFFICIENTS_INSERTION.name(): __COEFFICIENTS_INSERTION
    })
    _AttributeMap.update({
        __id.name(): __id,
        __troncons.name(): __troncons,
        __revetement.name(): __revetement,
        __vit_max.name(): __vit_max,
        __nb_voie.name(): __nb_voie,
        __LargeurVoie.name(): __LargeurVoie,
        __type.name(): __type
    })


Namespace.addCategoryObject('typeBinding', 'typeGiratoire', typeGiratoire)


# Complex type typeCarrefourAFeux with content type ELEMENT_ONLY
class typeCarrefourAFeux(typeConnexionInterne):
    """Complex type typeCarrefourAFeux with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeCarrefourAFeux')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2293, 2)
    _ElementMap = typeConnexionInterne._ElementMap.copy()
    _AttributeMap = typeConnexionInterne._AttributeMap.copy()
    # Base type is typeConnexionInterne

    # Element MOUVEMENTS_AUTORISES (MOUVEMENTS_AUTORISES) inherited from typeConnexionInterne

    # Element ENTREES_CAF uses Python identifier ENTREES_CAF
    __ENTREES_CAF = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ENTREES_CAF'),
                                                            'ENTREES_CAF',
                                                            '__AbsentNamespace0_typeCarrefourAFeux_ENTREES_CAF', False,
                                                            pyxb.utils.utility.Location(
                                                                '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                2297, 10), )

    ENTREES_CAF = property(__ENTREES_CAF.value, __ENTREES_CAF.set, None,
                           'Liste des entr\xe9es et de ses caract\xe9ristiques du carrefour \xe0 feu')


    # Element SORTIES_CAF uses Python identifier SORTIES_CAF
    __SORTIES_CAF = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SORTIES_CAF'),
                                                            'SORTIES_CAF',
                                                            '__AbsentNamespace0_typeCarrefourAFeux_SORTIES_CAF', False,
                                                            pyxb.utils.utility.Location(
                                                                '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                2480, 10), )

    SORTIES_CAF = property(__SORTIES_CAF.value, __SORTIES_CAF.set, None,
                           "Liste des sorties du CAF dans le cas o\xf9 les convergents de rattachement au sortie ont besoin d'\xeatre pr\xe9cis\xe9s (sinon tous les mouvements se rattachent a l'extr\xe9mit\xe9 aval de la sortie)")


    # Attribute z_level_crossing inherited from typeConnexionInterne

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeCarrefourAFeux_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2549, 8)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2549, 8)

    id = property(__id.value, __id.set, None, 'Identifiant unique du carrefour \xe0 feu')


    # Attribute vit_max uses Python identifier vit_max
    __vit_max = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'vit_max'), 'vit_max',
                                                  '__AbsentNamespace0_typeCarrefourAFeux_vit_max',
                                                  typeFloatStrictPositif, required=True)
    __vit_max._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2554, 8)
    __vit_max._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2554, 8)

    vit_max = property(__vit_max.value, __vit_max.set, None,
                       "Vitesse maximale \xe0 l'int\xe9rieur du carrefour (en m/s)")


    # Attribute controleur_de_feux uses Python identifier controleur_de_feux
    __controleur_de_feux = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'controleur_de_feux'),
                                                             'controleur_de_feux',
                                                             '__AbsentNamespace0_typeCarrefourAFeux_controleur_de_feux',
                                                             pyxb.binding.datatypes.string)
    __controleur_de_feux._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2559, 8)
    __controleur_de_feux._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2559, 8)

    controleur_de_feux = property(__controleur_de_feux.value, __controleur_de_feux.set, None,
                                  'Identifiant du contr\xf4leur de feux du carrefour (il doit \xeatre d\xe9fini dans la liste des contr\xf4leurs de feux)')

    _ElementMap.update({
        __ENTREES_CAF.name(): __ENTREES_CAF,
        __SORTIES_CAF.name(): __SORTIES_CAF
    })
    _AttributeMap.update({
        __id.name(): __id,
        __vit_max.name(): __vit_max,
        __controleur_de_feux.name(): __controleur_de_feux
    })


Namespace.addCategoryObject('typeBinding', 'typeCarrefourAFeux', typeCarrefourAFeux)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_140(pyxb.binding.basis.complexTypeDefinition):
    """Description d'une entrÃ©e du carrefour Ã  feu (une entrÃ©e est dÃ©finie par un tronÃ§on et un numÃ©ro de voie)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2307, 18)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element DIVERGENTS uses Python identifier DIVERGENTS
    __DIVERGENTS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DIVERGENTS'),
                                                           'DIVERGENTS', '__AbsentNamespace0_CTD_ANON_140_DIVERGENTS',
                                                           False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2309, 22), )

    DIVERGENTS = property(__DIVERGENTS.value, __DIVERGENTS.set, None,
                          "Liste des divergents de l'entr\xe9e consid\xe9r\xe9e. Ils sont ordonn\xe9s (du 1er au dernier rencontr\xe9). Si cette liste n'existe pas, l'ensemble des mouvements issus de l'entr\xe9e divergent imm\xe9diatement \xe0 l'extr\xe9mit\xe9 aval du tron\xe7on d'entr\xe9e.")


    # Element MOUVEMENTS uses Python identifier MOUVEMENTS
    __MOUVEMENTS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'MOUVEMENTS'),
                                                           'MOUVEMENTS', '__AbsentNamespace0_CTD_ANON_140_MOUVEMENTS',
                                                           False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2348, 22), )

    MOUVEMENTS = property(__MOUVEMENTS.value, __MOUVEMENTS.set, None,
                          "Liste des mouvements possibles issus de l'entr\xe9e consid\xe9r\xe9")


    # Attribute id_troncon_amont uses Python identifier id_troncon_amont
    __id_troncon_amont = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_troncon_amont'),
                                                           'id_troncon_amont',
                                                           '__AbsentNamespace0_CTD_ANON_140_id_troncon_amont',
                                                           pyxb.binding.datatypes.string, required=True)
    __id_troncon_amont._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2440, 20)
    __id_troncon_amont._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2440, 20)

    id_troncon_amont = property(__id_troncon_amont.value, __id_troncon_amont.set, None,
                                "Identifiant du tron\xe7on amont de l'entr\xe9e consid\xe9r\xe9e")


    # Attribute num_voie_amont uses Python identifier num_voie_amont
    __num_voie_amont = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'num_voie_amont'),
                                                         'num_voie_amont',
                                                         '__AbsentNamespace0_CTD_ANON_140_num_voie_amont',
                                                         typeFloatStrictPositif, unicode_default='1')
    __num_voie_amont._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2445, 20)
    __num_voie_amont._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2445, 20)

    num_voie_amont = property(__num_voie_amont.value, __num_voie_amont.set, None,
                              "Num\xe9ro de voie de l'entr\xe9e consid\xe9r\xe9e")


    # Attribute priorite uses Python identifier priorite
    __priorite = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'priorite'), 'priorite',
                                                   '__AbsentNamespace0_CTD_ANON_140_priorite', STD_ANON_23,
                                                   unicode_default='defaut')
    __priorite._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2451, 20)
    __priorite._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2451, 20)

    priorite = property(__priorite.value, __priorite.set, None, "Type de priorit\xe9 de l'entr\xe9e du carrefour")

    _ElementMap.update({
        __DIVERGENTS.name(): __DIVERGENTS,
        __MOUVEMENTS.name(): __MOUVEMENTS
    })
    _AttributeMap.update({
        __id_troncon_amont.name(): __id_troncon_amont,
        __num_voie_amont.name(): __num_voie_amont,
        __priorite.name(): __priorite
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_141(pyxb.binding.basis.complexTypeDefinition):
    """Description d'un mouvement"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2358, 30)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element POINTS_INTERNES uses Python identifier POINTS_INTERNES
    __POINTS_INTERNES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'POINTS_INTERNES'),
                                                                'POINTS_INTERNES',
                                                                '__AbsentNamespace0_CTD_ANON_141_POINTS_INTERNES',
                                                                False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2360, 34), )

    POINTS_INTERNES = property(__POINTS_INTERNES.value, __POINTS_INTERNES.set, None,
                               "Liste des points internes du mouvement situ\xe9s entre le divergent et le convergent de rattachement \xe0 la sortie (si aucun point n'est d\xe9fini, il se situe \xe0 l'extr\xe9mit\xe9 aval du tron\xe7on d'entr\xe9e du mouvement)")


    # Element POINTS_D_ATTENTE uses Python identifier POINTS_D_ATTENTE
    __POINTS_D_ATTENTE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'POINTS_D_ATTENTE'),
                                                                 'POINTS_D_ATTENTE',
                                                                 '__AbsentNamespace0_CTD_ANON_141_POINTS_D_ATTENTE',
                                                                 False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2366, 34), )

    POINTS_D_ATTENTE = property(__POINTS_D_ATTENTE.value, __POINTS_D_ATTENTE.set, None,
                                "Liste des points d'attente des travers\xe9es du mouvement")


    # Attribute libelle uses Python identifier libelle
    __libelle = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'libelle'), 'libelle',
                                                  '__AbsentNamespace0_CTD_ANON_141_libelle', STD_ANON_22)
    __libelle._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2401, 32)
    __libelle._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2401, 32)

    libelle = property(__libelle.value, __libelle.set, None, 'Libell\xe9 du mouvement')


    # Attribute id_troncon_aval uses Python identifier id_troncon_aval
    __id_troncon_aval = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_troncon_aval'),
                                                          'id_troncon_aval',
                                                          '__AbsentNamespace0_CTD_ANON_141_id_troncon_aval',
                                                          pyxb.binding.datatypes.string, required=True)
    __id_troncon_aval._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2411, 32)
    __id_troncon_aval._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2411, 32)

    id_troncon_aval = property(__id_troncon_aval.value, __id_troncon_aval.set, None,
                               'Identifiant du tron\xe7on aval du mouvement')


    # Attribute num_voie_aval uses Python identifier num_voie_aval
    __num_voie_aval = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'num_voie_aval'),
                                                        'num_voie_aval',
                                                        '__AbsentNamespace0_CTD_ANON_141_num_voie_aval',
                                                        typeFloatStrictPositif, unicode_default='1')
    __num_voie_aval._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2417, 32)
    __num_voie_aval._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2417, 32)

    num_voie_aval = property(__num_voie_aval.value, __num_voie_aval.set, None,
                             'Num\xe9ro de voie de la sortie du mouvement consid\xe9r\xe9')


    # Attribute divergent uses Python identifier divergent
    __divergent = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'divergent'), 'divergent',
                                                    '__AbsentNamespace0_CTD_ANON_141_divergent',
                                                    pyxb.binding.datatypes.string)
    __divergent._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2423, 32)
    __divergent._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2423, 32)

    divergent = property(__divergent.value, __divergent.set, None,
                         "Identifiant du divergent du mouvement (si il n'existe pas le mouvement est rattach\xe9 \xe0 l'extr\xe9mit\xe9 aval du tron\xe7on d'entr\xe9e)\n")


    # Attribute convergent uses Python identifier convergent
    __convergent = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'convergent'), 'convergent',
                                                     '__AbsentNamespace0_CTD_ANON_141_convergent',
                                                     pyxb.binding.datatypes.string)
    __convergent._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2429, 32)
    __convergent._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2429, 32)

    convergent = property(__convergent.value, __convergent.set, None,
                          "Identifiant du convergent du mouvement vers la sortie (si il n'existe pas le mouvement est rattach\xe9 \xe0 l'extr\xe9mit\xe9 amont du tron\xe7on de sortie)")

    _ElementMap.update({
        __POINTS_INTERNES.name(): __POINTS_INTERNES,
        __POINTS_D_ATTENTE.name(): __POINTS_D_ATTENTE
    })
    _AttributeMap.update({
        __libelle.name(): __libelle,
        __id_troncon_aval.name(): __id_troncon_aval,
        __num_voie_aval.name(): __num_voie_aval,
        __divergent.name(): __divergent,
        __convergent.name(): __convergent
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_142(pyxb.binding.basis.complexTypeDefinition):
    """Description d'un point d'attente du mouvement. Lors du calcul des points d'intersection des mouvements pour dÃ©tecter les traversÃ©es non prioritaires, celles-ci seront regroupÃ©es en considÃ©rant leur position par rapport au point d'attente. Ainsi, un point d'attente est utilisÃ© pour les traversÃ©es du mouvement se situant en amont du point jusqu'au prochain point d'attente dÃ©fini ou jusqu'Ã  l'extrÃ©mitÃ© du mouvement"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2377, 42)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute position uses Python identifier position
    __position = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position'), 'position',
                                                   '__AbsentNamespace0_CTD_ANON_142_position', typeFloatStrictPositif,
                                                   required=True)
    __position._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2378, 44)
    __position._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2378, 44)

    position = property(__position.value, __position.set, None,
                        "Position (abscisse curviligne sur le mouvement) du point d'attente")


    # Attribute nb_veh_max uses Python identifier nb_veh_max
    __nb_veh_max = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'nb_veh_max'), 'nb_veh_max',
                                                     '__AbsentNamespace0_CTD_ANON_142_nb_veh_max', STD_ANON_21,
                                                     unicode_default='0')
    __nb_veh_max._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2384, 44)
    __nb_veh_max._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2384, 44)

    nb_veh_max = property(__nb_veh_max.value, __nb_veh_max.set, None,
                          "Nombre maximal de v\xe9hicule en attente pouvant s'accumuler au point d'attente\n(si 0, pas de nombre maximal)")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __position.name(): __position,
        __nb_veh_max.name(): __nb_veh_max
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_143(pyxb.binding.basis.complexTypeDefinition):
    """Description d'une sortie du carrefour Ã  feu (une sortie est dÃ©finie par un tronÃ§on et un numÃ©ro de voie)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2490, 18)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element CONVERGENTS uses Python identifier CONVERGENTS
    __CONVERGENTS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CONVERGENTS'),
                                                            'CONVERGENTS',
                                                            '__AbsentNamespace0_CTD_ANON_143_CONVERGENTS', False,
                                                            pyxb.utils.utility.Location(
                                                                '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                2492, 22), )

    CONVERGENTS = property(__CONVERGENTS.value, __CONVERGENTS.set, None,
                           "Liste des convergents de la sortie. Ils sont ordonn\xe9s \xe0 partir de la fin (du dernier au 1er rencontr\xe9). Si cette liste n'existe pas, l'ensemble des mouvements arrivant sur cette sortie convergent  imm\xe9diatement \xe0 l'extr\xe9mit\xe9 amont du tron\xe7on de sortie.")


    # Attribute id_troncon_aval uses Python identifier id_troncon_aval
    __id_troncon_aval = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_troncon_aval'),
                                                          'id_troncon_aval',
                                                          '__AbsentNamespace0_CTD_ANON_143_id_troncon_aval',
                                                          pyxb.binding.datatypes.string, required=True)
    __id_troncon_aval._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2532, 20)
    __id_troncon_aval._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2532, 20)

    id_troncon_aval = property(__id_troncon_aval.value, __id_troncon_aval.set, None,
                               'Identifiant du tron\xe7on aval de la sortie consid\xe9r\xe9e')


    # Attribute num_voie_aval uses Python identifier num_voie_aval
    __num_voie_aval = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'num_voie_aval'),
                                                        'num_voie_aval',
                                                        '__AbsentNamespace0_CTD_ANON_143_num_voie_aval',
                                                        typeFloatStrictPositif, unicode_default='1')
    __num_voie_aval._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2537, 20)
    __num_voie_aval._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2537, 20)

    num_voie_aval = property(__num_voie_aval.value, __num_voie_aval.set, None,
                             'Num\xe9ro de voie de la sortie consid\xe9r\xe9e')

    _ElementMap.update({
        __CONVERGENTS.name(): __CONVERGENTS
    })
    _AttributeMap.update({
        __id_troncon_aval.name(): __id_troncon_aval,
        __num_voie_aval.name(): __num_voie_aval
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_144(pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type EMPTY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2621, 26)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute duree uses Python identifier duree
    __duree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree'), 'duree',
                                                '__AbsentNamespace0_CTD_ANON_144_duree', typeDuree,
                                                unicode_default='always')
    __duree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2622, 28)
    __duree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2622, 28)

    duree = property(__duree.value, __duree.set, None,
                     'Identifiant de la plage temporelle associ\xe9e, ou dur\xe9e (en seconde) de la variante de la fr\xe9quence')


    # Attribute frequence uses Python identifier frequence
    __frequence = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'frequence'), 'frequence',
                                                    '__AbsentNamespace0_CTD_ANON_144_frequence', typeIntStrictPositif,
                                                    required=True)
    __frequence._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2627, 28)
    __frequence._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2627, 28)

    frequence = property(__frequence.value, __frequence.set, None,
                         'Fr\xe9quence en seconde entre le lancement de 2 v\xe9hicules (\xe0 d\xe9finir uniquement si le type de param\xe9trage est global)')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __duree.name(): __duree,
        __frequence.name(): __frequence
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_145(pyxb.binding.basis.complexTypeDefinition):
    """DÃ©finition d'une variante temporelle de demande pour la ligne considÃ©rÃ©e"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2731, 32)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute duree uses Python identifier duree
    __duree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree'), 'duree',
                                                '__AbsentNamespace0_CTD_ANON_145_duree', typeDuree,
                                                unicode_default='always')
    __duree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2732, 34)
    __duree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2732, 34)

    duree = property(__duree.value, __duree.set, None,
                     "Identifiant de la plage temporelle associ\xe9e, ou dur\xe9e (en seconde) de la variante de la demande pour l'arr\xeat")


    # Attribute demande uses Python identifier demande
    __demande = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'demande'), 'demande',
                                                  '__AbsentNamespace0_CTD_ANON_145_demande', typeFloatPositif,
                                                  required=True)
    __demande._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2737, 34)
    __demande._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2737, 34)

    demande = property(__demande.value, __demande.set, None,
                       "Valeur de demande (en pi\xe9ton / s) pour l'arr\xeat et la ligne s\xe9lectionn\xe9e")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __duree.name(): __duree,
        __demande.name(): __demande
    })


# Complex type typeParametrageCapteurs with content type ELEMENT_ONLY
class typeParametrageCapteurs(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeParametrageCapteurs with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeParametrageCapteurs')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2852, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element CAPTEURS uses Python identifier CAPTEURS
    __CAPTEURS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CAPTEURS'), 'CAPTEURS',
                                                         '__AbsentNamespace0_typeParametrageCapteurs_CAPTEURS', False,
                                                         pyxb.utils.utility.Location(
                                                             '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                             2854, 6), )

    CAPTEURS = property(__CAPTEURS.value, __CAPTEURS.set, None, 'Liste des capteurs du r\xe9seau')


    # Attribute periodeagregation uses Python identifier periodeagregation
    __periodeagregation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'periodeagregation'),
                                                            'periodeagregation',
                                                            '__AbsentNamespace0_typeParametrageCapteurs_periodeagregation',
                                                            typeFloatStrictPositif, required=True)
    __periodeagregation._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2874, 4)
    __periodeagregation._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2874, 4)

    periodeagregation = property(__periodeagregation.value, __periodeagregation.set, None,
                                 "P\xe9riode d'agr\xe9gation (en s) pour les calculs")


    # Attribute t0 uses Python identifier t0
    __t0 = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 't0'), 't0',
                                             '__AbsentNamespace0_typeParametrageCapteurs_t0', typeFloatPositif,
                                             unicode_default='0')
    __t0._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2879, 4)
    __t0._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2879, 4)

    t0 = property(__t0.value, __t0.set, None,
                  "instant (en s) \xe0 partir duquel d\xe9marrer la premi\xe8re p\xe9riode d'acquisition des capteurs")


    # Attribute periodeagregationEdie uses Python identifier periodeagregationEdie
    __periodeagregationEdie = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'periodeagregationEdie'), 'periodeagregationEdie',
        '__AbsentNamespace0_typeParametrageCapteurs_periodeagregationEdie', typeFloatStrictPositif)
    __periodeagregationEdie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2884, 4)
    __periodeagregationEdie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2884, 4)

    periodeagregationEdie = property(__periodeagregationEdie.value, __periodeagregationEdie.set, None,
                                     'P\xe9riode d\'agr\xe9gation \xe0 utiliser pour les capteurs d\'Edie si diff\xe9rente de la p\xe9riode d\'agr\xe9gation "periodeagregation"')


    # Attribute t0Edie uses Python identifier t0Edie
    __t0Edie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 't0Edie'), 't0Edie',
                                                 '__AbsentNamespace0_typeParametrageCapteurs_t0Edie', typeFloatPositif,
                                                 unicode_default='0')
    __t0Edie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2889, 4)
    __t0Edie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2889, 4)

    t0Edie = property(__t0Edie.value, __t0Edie.set, None,
                      "instant (en s) \xe0 partir duquel d\xe9marrer la premi\xe8re p\xe9riode d'acquisition des capteurs d'Edie, si diff\xe9rent du t0 global")


    # Attribute periodeagregationLongitudinale uses Python identifier periodeagregationLongitudinale
    __periodeagregationLongitudinale = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'periodeagregationLongitudinale'), 'periodeagregationLongitudinale',
        '__AbsentNamespace0_typeParametrageCapteurs_periodeagregationLongitudinale', typeFloatStrictPositif)
    __periodeagregationLongitudinale._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2894, 4)
    __periodeagregationLongitudinale._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2894, 4)

    periodeagregationLongitudinale = property(__periodeagregationLongitudinale.value,
                                              __periodeagregationLongitudinale.set, None,
                                              'P\xe9riode d\'agr\xe9gation \xe0 utiliser pour les capteurs longitudinaux si diff\xe9rente de la p\xe9riode d\'agr\xe9gation "periodeagregation"')


    # Attribute t0Longitudinal uses Python identifier t0Longitudinal
    __t0Longitudinal = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 't0Longitudinal'),
                                                         't0Longitudinal',
                                                         '__AbsentNamespace0_typeParametrageCapteurs_t0Longitudinal',
                                                         typeFloatPositif, unicode_default='0')
    __t0Longitudinal._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2899, 4)
    __t0Longitudinal._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2899, 4)

    t0Longitudinal = property(__t0Longitudinal.value, __t0Longitudinal.set, None,
                              "instant (en s) \xe0 partir duquel d\xe9marrer la premi\xe8re p\xe9riode d'acquisition des capteurs longitudinaux, si diff\xe9rent du t0 global")


    # Attribute periodeagregationMFD uses Python identifier periodeagregationMFD
    __periodeagregationMFD = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'periodeagregationMFD'), 'periodeagregationMFD',
        '__AbsentNamespace0_typeParametrageCapteurs_periodeagregationMFD', typeFloatStrictPositif)
    __periodeagregationMFD._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2904, 4)
    __periodeagregationMFD._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2904, 4)

    periodeagregationMFD = property(__periodeagregationMFD.value, __periodeagregationMFD.set, None,
                                    'P\xe9riode d\'agr\xe9gation \xe0 utiliser pour les capteurs MFD si diff\xe9rente de la p\xe9riode d\'agr\xe9gation "periodeagregation"')


    # Attribute t0MFD uses Python identifier t0MFD
    __t0MFD = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 't0MFD'), 't0MFD',
                                                '__AbsentNamespace0_typeParametrageCapteurs_t0MFD', typeFloatPositif,
                                                unicode_default='0')
    __t0MFD._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2909, 4)
    __t0MFD._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2909, 4)

    t0MFD = property(__t0MFD.value, __t0MFD.set, None,
                     "instant (en s) \xe0 partir duquel d\xe9marrer la premi\xe8re p\xe9riode d'acquisition des capteurs MFD, si diff\xe9rent du t0 global")


    # Attribute periodeagregationBlueTooth uses Python identifier periodeagregationBlueTooth
    __periodeagregationBlueTooth = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'periodeagregationBlueTooth'), 'periodeagregationBlueTooth',
        '__AbsentNamespace0_typeParametrageCapteurs_periodeagregationBlueTooth', typeFloatStrictPositif)
    __periodeagregationBlueTooth._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2914, 4)
    __periodeagregationBlueTooth._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2914, 4)

    periodeagregationBlueTooth = property(__periodeagregationBlueTooth.value, __periodeagregationBlueTooth.set, None,
                                          'P\xe9riode d\'agr\xe9gation \xe0 utiliser pour les capteurs BlueTooth si diff\xe9rente de la p\xe9riode d\'agr\xe9gation "periodeagregation"')


    # Attribute t0BlueTooth uses Python identifier t0BlueTooth
    __t0BlueTooth = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 't0BlueTooth'), 't0BlueTooth',
                                                      '__AbsentNamespace0_typeParametrageCapteurs_t0BlueTooth',
                                                      typeFloatPositif, unicode_default='0')
    __t0BlueTooth._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2919, 4)
    __t0BlueTooth._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2919, 4)

    t0BlueTooth = property(__t0BlueTooth.value, __t0BlueTooth.set, None,
                           "instant (en s) \xe0 partir duquel d\xe9marrer la premi\xe8re p\xe9riode d'acquisition des capteurs BlueTooth, si diff\xe9rent du t0 global")

    _ElementMap.update({
        __CAPTEURS.name(): __CAPTEURS
    })
    _AttributeMap.update({
        __periodeagregation.name(): __periodeagregation,
        __t0.name(): __t0,
        __periodeagregationEdie.name(): __periodeagregationEdie,
        __t0Edie.name(): __t0Edie,
        __periodeagregationLongitudinale.name(): __periodeagregationLongitudinale,
        __t0Longitudinal.name(): __t0Longitudinal,
        __periodeagregationMFD.name(): __periodeagregationMFD,
        __t0MFD.name(): __t0MFD,
        __periodeagregationBlueTooth.name(): __periodeagregationBlueTooth,
        __t0BlueTooth.name(): __t0BlueTooth
    })


Namespace.addCategoryObject('typeBinding', 'typeParametrageCapteurs', typeParametrageCapteurs)


# Complex type typeControleurDeFeux with content type ELEMENT_ONLY
class typeControleurDeFeux(pyxb.binding.basis.complexTypeDefinition):
    """Description du type 'CONTROLEUR_DE_FEUX'"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeControleurDeFeux')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2925, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element PLANS_DE_FEUX uses Python identifier PLANS_DE_FEUX
    __PLANS_DE_FEUX = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PLANS_DE_FEUX'),
                                                              'PLANS_DE_FEUX',
                                                              '__AbsentNamespace0_typeControleurDeFeux_PLANS_DE_FEUX',
                                                              False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2930, 6), )

    PLANS_DE_FEUX = property(__PLANS_DE_FEUX.value, __PLANS_DE_FEUX.set, None,
                             "Noeud d'acc\xe8s \xe0 la liste des plans de feux")


    # Element LIGNES_GUIDEES_PRIORITAIRES uses Python identifier LIGNES_GUIDEES_PRIORITAIRES
    __LIGNES_GUIDEES_PRIORITAIRES = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'LIGNES_GUIDEES_PRIORITAIRES'), 'LIGNES_GUIDEES_PRIORITAIRES',
        '__AbsentNamespace0_typeControleurDeFeux_LIGNES_GUIDEES_PRIORITAIRES', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3055, 6), )

    LIGNES_GUIDEES_PRIORITAIRES = property(__LIGNES_GUIDEES_PRIORITAIRES.value, __LIGNES_GUIDEES_PRIORITAIRES.set, None,
                                           "Noeud d'acc\xe8s \xe0 la liste des lignes guid\xe9es prioritaires g\xe9r\xe9es par le contr\xf4leur de feux parent\n")


    # Element POSITION_FEUX uses Python identifier POSITION_FEUX
    __POSITION_FEUX = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'POSITION_FEUX'),
                                                              'POSITION_FEUX',
                                                              '__AbsentNamespace0_typeControleurDeFeux_POSITION_FEUX',
                                                              False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3130, 6), )

    POSITION_FEUX = property(__POSITION_FEUX.value, __POSITION_FEUX.set, None,
                             "Noeud sp\xe9cifique \xe0 l'outils de visualisation Symuplayer permettant de param\xe9trer la position des feux du contr\xf4leur")


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeControleurDeFeux_id', STD_ANON_36, required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3157, 4)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3157, 4)

    id = property(__id.value, __id.set, None, 'Identifiant unique du contr\xf4leur de feu')


    # Attribute duree_vert_min uses Python identifier duree_vert_min
    __duree_vert_min = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree_vert_min'),
                                                         'duree_vert_min',
                                                         '__AbsentNamespace0_typeControleurDeFeux_duree_vert_min',
                                                         STD_ANON_37, unicode_default='6')
    __duree_vert_min._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3167, 4)
    __duree_vert_min._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3167, 4)

    duree_vert_min = property(__duree_vert_min.value, __duree_vert_min.set, None,
                              'Dur\xe9e (en seconde) minimale de vert du contr\xf4leur de feu. Symubruit v\xe9rifie que pour chaque signal actif des s\xe9quences des plans de feux du contr\xf4leur de feux, la dur\xe9e de vert est sup\xe9rieure \xe0 la dur\xe9e minimale du vert du contr\xf4leur (sinon avertissement).\n')


    # Attribute duree_rouge_degagement uses Python identifier duree_rouge_degagement
    __duree_rouge_degagement = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'duree_rouge_degagement'), 'duree_rouge_degagement',
        '__AbsentNamespace0_typeControleurDeFeux_duree_rouge_degagement', STD_ANON_38, unicode_default='5')
    __duree_rouge_degagement._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3178, 4)
    __duree_rouge_degagement._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3178, 4)

    duree_rouge_degagement = property(__duree_rouge_degagement.value, __duree_rouge_degagement.set, None,
                                      "Dur\xe9e en seconde du rouge de d\xe9gagement. Symubruit v\xe9rifie que pour chaque signa actif des s\xe9quences des plans de feux du contr\xf4leur de feux, la dur\xe9e de rouge restante (dur\xe9e de la s\xe9quence - dur\xe9e du vert du signal - retard \xe0 l'allumage du signal) est sup\xe9rieure \xe0 la dur\xe9e du rouge de d\xe9gagement (sinon avertissement).\n")


    # Attribute regulation uses Python identifier regulation
    __regulation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'regulation'), 'regulation',
                                                     '__AbsentNamespace0_typeControleurDeFeux_regulation', STD_ANON_39,
                                                     unicode_default='aucune')
    __regulation._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3189, 4)
    __regulation._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3189, 4)

    regulation = property(__regulation.value, __regulation.set, None,
                          'Type de r\xe9gulation du contr\xf4leur de feux :\n- aucune\n- m\xe9thode des vecteurs')


    # Attribute regulation_periode uses Python identifier regulation_periode
    __regulation_periode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'regulation_periode'),
                                                             'regulation_periode',
                                                             '__AbsentNamespace0_typeControleurDeFeux_regulation_periode',
                                                             typeIntStrictPositif, unicode_default='180')
    __regulation_periode._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3210, 4)
    __regulation_periode._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3210, 4)

    regulation_periode = property(__regulation_periode.value, __regulation_periode.set, None,
                                  "P\xe9riode de r\xe9gulation d'un contr\xf4leur de feux en seconde. Cet attribut est utilis\xe9 uniquement dans le cas d'un contr\xf4leur de feux r\xe9gul\xe9. Au d\xe9but de chaque p\xe9riode, le plan de feux optimal est calcul\xe9 puis appliqu\xe9 durant toute la p\xe9riode de r\xe9gulation suivant.\n")

    _ElementMap.update({
        __PLANS_DE_FEUX.name(): __PLANS_DE_FEUX,
        __LIGNES_GUIDEES_PRIORITAIRES.name(): __LIGNES_GUIDEES_PRIORITAIRES,
        __POSITION_FEUX.name(): __POSITION_FEUX
    })
    _AttributeMap.update({
        __id.name(): __id,
        __duree_vert_min.name(): __duree_vert_min,
        __duree_rouge_degagement.name(): __duree_rouge_degagement,
        __regulation.name(): __regulation,
        __regulation_periode.name(): __regulation_periode
    })


Namespace.addCategoryObject('typeBinding', 'typeControleurDeFeux', typeControleurDeFeux)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_146(pyxb.binding.basis.complexTypeDefinition):
    """Noeud de description d'un plan de feux"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2940, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element SEQUENCES uses Python identifier SEQUENCES
    __SEQUENCES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SEQUENCES'), 'SEQUENCES',
                                                          '__AbsentNamespace0_CTD_ANON_146_SEQUENCES', False,
                                                          pyxb.utils.utility.Location(
                                                              '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                              2942, 18), )

    SEQUENCES = property(__SEQUENCES.value, __SEQUENCES.set, None,
                         "Noeud d'acc\xe8s \xe0 la liste des s\xe9quences du plan de feux")


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_146_id', STD_ANON_33, required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3035, 16)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3035, 16)

    id = property(__id.value, __id.set, None,
                  "Identifiant unique du plan de feux (il permet notamment de lancer son d\xe9roulement dans le cas d'un pilotage ou d'identifier le plan de feux utilis\xe9 lors de la r\xe9gulation)")


    # Attribute debut uses Python identifier debut
    __debut = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'debut'), 'debut',
                                                '__AbsentNamespace0_CTD_ANON_146_debut', pyxb.binding.datatypes.time)
    __debut._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3045, 16)
    __debut._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3045, 16)

    debut = property(__debut.value, __debut.set, None,
                     'Heure exacte du d\xe9but du plan de feux \xe0 pr\xe9ciser uniquement pour un contr\xf4leur de feux non r\xe9gul\xe9 et si plusieurs plans de feux sont d\xe9finis')

    _ElementMap.update({
        __SEQUENCES.name(): __SEQUENCES
    })
    _AttributeMap.update({
        __id.name(): __id,
        __debut.name(): __debut
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_147(pyxb.binding.basis.complexTypeDefinition):
    """Noeud de description d'une sÃ©quence du plan de feux
"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2953, 26)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element SIGNAUX_ACTIFS uses Python identifier SIGNAUX_ACTIFS
    __SIGNAUX_ACTIFS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'SIGNAUX_ACTIFS'),
                                                               'SIGNAUX_ACTIFS',
                                                               '__AbsentNamespace0_CTD_ANON_147_SIGNAUX_ACTIFS', False,
                                                               pyxb.utils.utility.Location(
                                                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                   2955, 30), )

    SIGNAUX_ACTIFS = property(__SIGNAUX_ACTIFS.value, __SIGNAUX_ACTIFS.set, None,
                              "Noeud d'acc\xe8s \xe0 la liste de description des signaux actifs de la s\xe9quence\n")


    # Attribute duree_totale uses Python identifier duree_totale
    __duree_totale = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree_totale'),
                                                       'duree_totale', '__AbsentNamespace0_CTD_ANON_147_duree_totale',
                                                       STD_ANON_32, required=True)
    __duree_totale._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3019, 28)
    __duree_totale._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3019, 28)

    duree_totale = property(__duree_totale.value, __duree_totale.set, None,
                            'Dur\xe9e totale de la s\xe9quence en seconde')

    _ElementMap.update({
        __SIGNAUX_ACTIFS.name(): __SIGNAUX_ACTIFS
    })
    _AttributeMap.update({
        __duree_totale.name(): __duree_totale
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_148(pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type EMPTY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2964, 38)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute duree_retard_allumage uses Python identifier duree_retard_allumage
    __duree_retard_allumage = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'duree_retard_allumage'), 'duree_retard_allumage',
        '__AbsentNamespace0_CTD_ANON_148_duree_retard_allumage', STD_ANON_29, required=True)
    __duree_retard_allumage._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2965, 40)
    __duree_retard_allumage._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2965, 40)

    duree_retard_allumage = property(__duree_retard_allumage.value, __duree_retard_allumage.set, None,
                                     "Dur\xe9e en seconde du retard \xe0 l'allumage  (cette dur\xe9e doit \xeatre telle que la diff\xe9rence entre la dur\xe9e de la s\xe9quence et la somme du temps de vert et du retard \xe0 l'allumage doit \xeatre sup\xe9rieure \xe0 la dur\xe9e de rouge de d\xe9gagement d\xe9finie au niveau du controleur de feux).\n")


    # Attribute duree_vert uses Python identifier duree_vert
    __duree_vert = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree_vert'), 'duree_vert',
                                                     '__AbsentNamespace0_CTD_ANON_148_duree_vert', STD_ANON_30,
                                                     required=True)
    __duree_vert._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2976, 40)
    __duree_vert._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2976, 40)

    duree_vert = property(__duree_vert.value, __duree_vert.set, None,
                          'Dur\xe9e en seconde du temps de vert (cette dur\xe9e doit \xeatre sup\xe9rieure au temps de vert minimale d\xe9fini au niveau du contr\xf4leur de feux).\n')


    # Attribute duree_orange uses Python identifier duree_orange
    __duree_orange = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree_orange'),
                                                       'duree_orange', '__AbsentNamespace0_CTD_ANON_148_duree_orange',
                                                       STD_ANON_31, unicode_default='0')
    __duree_orange._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2987, 40)
    __duree_orange._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2987, 40)

    duree_orange = property(__duree_orange.value, __duree_orange.set, None,
                            "Dur\xe9e en seconde du temps d'orange(cette dur\xe9e peut \xeatre nulle).\n")


    # Attribute troncon_entree uses Python identifier troncon_entree
    __troncon_entree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'troncon_entree'),
                                                         'troncon_entree',
                                                         '__AbsentNamespace0_CTD_ANON_148_troncon_entree',
                                                         pyxb.binding.datatypes.string, required=True)
    __troncon_entree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2999, 40)
    __troncon_entree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2999, 40)

    troncon_entree = property(__troncon_entree.value, __troncon_entree.set, None,
                              "Identifiant unique du tron\xe7on d'entr\xe9e du signal\n")


    # Attribute troncon_sortie uses Python identifier troncon_sortie
    __troncon_sortie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'troncon_sortie'),
                                                         'troncon_sortie',
                                                         '__AbsentNamespace0_CTD_ANON_148_troncon_sortie',
                                                         pyxb.binding.datatypes.string, required=True)
    __troncon_sortie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3006, 40)
    __troncon_sortie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3006, 40)

    troncon_sortie = property(__troncon_sortie.value, __troncon_sortie.set, None,
                              "Identifiant unique du tron\xe7on d'entr\xe9e du signal\n")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __duree_retard_allumage.name(): __duree_retard_allumage,
        __duree_vert.name(): __duree_vert,
        __duree_orange.name(): __duree_orange,
        __troncon_entree.name(): __troncon_entree,
        __troncon_sortie.name(): __troncon_sortie
    })


# Complex type typeCapteurPonctuel with content type EMPTY
class typeCapteurPonctuel(typeCapteur):
    """Capteur de type ponctuel (dÃ©fini par une position ponctuelle sur le tronÃ§on)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeCapteurPonctuel')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3232, 2)
    _ElementMap = typeCapteur._ElementMap.copy()
    _AttributeMap = typeCapteur._AttributeMap.copy()
    # Base type is typeCapteur

    # Attribute id inherited from typeCapteur

    # Attribute troncon inherited from typeCapteur

    # Attribute position uses Python identifier position
    __position = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position'), 'position',
                                                   '__AbsentNamespace0_typeCapteurPonctuel_position', typeFloatPositif,
                                                   required=True)
    __position._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3238, 8)
    __position._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3238, 8)

    position = property(__position.value, __position.set, None,
                        'Position du capteur sur le tron\xe7on (en m ou en % si position_relative vaut true)')


    # Attribute position_relative uses Python identifier position_relative
    __position_relative = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position_relative'),
                                                            'position_relative',
                                                            '__AbsentNamespace0_typeCapteurPonctuel_position_relative',
                                                            pyxb.binding.datatypes.boolean)
    __position_relative._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3243, 8)
    __position_relative._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3243, 8)

    position_relative = property(__position_relative.value, __position_relative.set, None,
                                 "Indique si la position du capteur est exprim\xe9e en pourcentage de la longueur du tron\xe7on plut\xf4t qu'en m\xe8tres")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __position.name(): __position,
        __position_relative.name(): __position_relative
    })


Namespace.addCategoryObject('typeBinding', 'typeCapteurPonctuel', typeCapteurPonctuel)


# Complex type typeCapteurLongitudinal with content type EMPTY
class typeCapteurLongitudinal(typeCapteur):
    """Capteur de type longitudinal (dÃ©fini par une position de dÃ©but et de fin sur le tronÃ§on)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeCapteurLongitudinal')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3251, 2)
    _ElementMap = typeCapteur._ElementMap.copy()
    _AttributeMap = typeCapteur._AttributeMap.copy()
    # Base type is typeCapteur

    # Attribute id inherited from typeCapteur

    # Attribute troncon inherited from typeCapteur

    # Attribute position_debut uses Python identifier position_debut
    __position_debut = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position_debut'),
                                                         'position_debut',
                                                         '__AbsentNamespace0_typeCapteurLongitudinal_position_debut',
                                                         typeFloatPositif, required=True)
    __position_debut._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3257, 8)
    __position_debut._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3257, 8)

    position_debut = property(__position_debut.value, __position_debut.set, None,
                              'Position du d\xe9but du capteur sur le tron\xe7on (en m ou en % si position_relative vaut true)')


    # Attribute position_fin uses Python identifier position_fin
    __position_fin = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position_fin'),
                                                       'position_fin',
                                                       '__AbsentNamespace0_typeCapteurLongitudinal_position_fin',
                                                       typeFloatPositif, unicode_default='INF')
    __position_fin._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3262, 8)
    __position_fin._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3262, 8)

    position_fin = property(__position_fin.value, __position_fin.set, None,
                            'Position de la fin du capteur sur le tron\xe7on (en m ou en % si position_relative vaut true). par d\xe9faut, la fin du capteur est la fin du tron\xe7on.')


    # Attribute position_relative uses Python identifier position_relative
    __position_relative = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position_relative'),
                                                            'position_relative',
                                                            '__AbsentNamespace0_typeCapteurLongitudinal_position_relative',
                                                            pyxb.binding.datatypes.boolean)
    __position_relative._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3267, 8)
    __position_relative._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3267, 8)

    position_relative = property(__position_relative.value, __position_relative.set, None,
                                 "Indique si la position du capteur est exprim\xe9e en pourcentage de la longueur du tron\xe7on plut\xf4t qu'en m\xe8tres")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __position_debut.name(): __position_debut,
        __position_fin.name(): __position_fin,
        __position_relative.name(): __position_relative
    })


Namespace.addCategoryObject('typeBinding', 'typeCapteurLongitudinal', typeCapteurLongitudinal)


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_149(pyxb.binding.basis.complexTypeDefinition):
    """Permet de spÃ©cifier la positione des capteurs ponctuels dÃ©tectant les vÃ©hicules entrants et sortants du noeud (Par dÃ©faut, ces capteurs sont situÃ©s aux extrÃ©mitÃ©s des tronÃ§ons amont et aval, au niveau du noeud)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3317, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute troncon uses Python identifier troncon
    __troncon = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'troncon'), 'troncon',
                                                  '__AbsentNamespace0_CTD_ANON_149_troncon',
                                                  pyxb.binding.datatypes.string, required=True)
    __troncon._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3318, 10)
    __troncon._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3318, 10)

    troncon = property(__troncon.value, __troncon.set, None, 'Tron\xe7on sur lequel est positionn\xe9 le capteur')


    # Attribute position uses Python identifier position
    __position = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position'), 'position',
                                                   '__AbsentNamespace0_CTD_ANON_149_position', typeFloatPositif,
                                                   required=True)
    __position._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3323, 10)
    __position._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3323, 10)

    position = property(__position.value, __position.set, None,
                        'Position du capteur sur le tron\xe7on (en m ou en % si position_relative vaut true)')


    # Attribute position_relative uses Python identifier position_relative
    __position_relative = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position_relative'),
                                                            'position_relative',
                                                            '__AbsentNamespace0_CTD_ANON_149_position_relative',
                                                            pyxb.binding.datatypes.boolean)
    __position_relative._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3328, 10)
    __position_relative._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3328, 10)

    position_relative = property(__position_relative.value, __position_relative.set, None,
                                 "Indique si la position du capteur est exprim\xe9e en pourcentage de la longueur du tron\xe7on plut\xf4t qu'en m\xe8tres")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __troncon.name(): __troncon,
        __position.name(): __position,
        __position_relative.name(): __position_relative
    })


# Complex type typeTraficOrigine with content type ELEMENT_ONLY
class typeTraficOrigine(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeTraficOrigine with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeTraficOrigine')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3347, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element FLUX_GLOBAL uses Python identifier FLUX_GLOBAL
    __FLUX_GLOBAL = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FLUX_GLOBAL'),
                                                            'FLUX_GLOBAL',
                                                            '__AbsentNamespace0_typeTraficOrigine_FLUX_GLOBAL', False,
                                                            pyxb.utils.utility.Location(
                                                                '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                3349, 6), )

    FLUX_GLOBAL = property(__FLUX_GLOBAL.value, __FLUX_GLOBAL.set, None,
                           "Noeud d'acc\xe8s \xe0 la description d'un flux global ayant pour origine l'extr\xe9mit\xe9 courante (pour tous les types de v\xe9hicule)")


    # Element FLUX_TYPEVEHS uses Python identifier FLUX_TYPEVEHS
    __FLUX_TYPEVEHS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FLUX_TYPEVEHS'),
                                                              'FLUX_TYPEVEHS',
                                                              '__AbsentNamespace0_typeTraficOrigine_FLUX_TYPEVEHS',
                                                              False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3354, 6), )

    FLUX_TYPEVEHS = property(__FLUX_TYPEVEHS.value, __FLUX_TYPEVEHS.set, None,
                             "Noeud d'acc\xe8s \xe0 la collection des flux par type de v\xe9hicule pour l'extr\xe9mit\xe9 courante")


    # Element AGRESSIVITES uses Python identifier AGRESSIVITES
    __AGRESSIVITES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'AGRESSIVITES'),
                                                             'AGRESSIVITES',
                                                             '__AbsentNamespace0_typeTraficOrigine_AGRESSIVITES', False,
                                                             pyxb.utils.utility.Location(
                                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                 3379, 6), )

    AGRESSIVITES = property(__AGRESSIVITES.value, __AGRESSIVITES.set, None,
                            "Description du caract\xe8re agressif des v\xe9hicules issus de l'entr\xe9e")


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeTraficOrigine_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3408, 4)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3408, 4)

    id = property(__id.value, __id.set, None, "Identifiant de l'\xe9l\xe9ment")


    # Attribute typeCreationVehicule uses Python identifier typeCreationVehicule
    __typeCreationVehicule = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'typeCreationVehicule'), 'typeCreationVehicule',
        '__AbsentNamespace0_typeTraficOrigine_typeCreationVehicule', STD_ANON_40, unicode_default='demande')
    __typeCreationVehicule._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3413, 4)
    __typeCreationVehicule._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3413, 4)

    typeCreationVehicule = property(__typeCreationVehicule.value, __typeCreationVehicule.set, None,
                                    "Pr\xe9cise le mode de cr\xe9ation de v\xe9hicules (liste de v\xe9hicule avec l'heure d'entr\xe9e sur le r\xe9seau ou demande)")

    _ElementMap.update({
        __FLUX_GLOBAL.name(): __FLUX_GLOBAL,
        __FLUX_TYPEVEHS.name(): __FLUX_TYPEVEHS,
        __AGRESSIVITES.name(): __AGRESSIVITES
    })
    _AttributeMap.update({
        __id.name(): __id,
        __typeCreationVehicule.name(): __typeCreationVehicule
    })


Namespace.addCategoryObject('typeBinding', 'typeTraficOrigine', typeTraficOrigine)


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_150(pyxb.binding.basis.complexTypeDefinition):
    """Description du caractÃ¨re agressif d'une classe de vÃ©hicule pour cette entrÃ©e (par dÃ©faut, le taux de vÃ©hicule agressif d'une classe est 0)
"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3390, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute taux uses Python identifier taux
    __taux = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'taux'), 'taux',
                                               '__AbsentNamespace0_CTD_ANON_150_taux', typeFloat01, required=True)
    __taux._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3391, 16)
    __taux._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3391, 16)

    taux = property(__taux.value, __taux.set, None, 'Taux de v\xe9hicule agressif au sein de la classe \n')


    # Attribute type_veh uses Python identifier type_veh
    __type_veh = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'type_veh'), 'type_veh',
                                                   '__AbsentNamespace0_CTD_ANON_150_type_veh',
                                                   pyxb.binding.datatypes.string, required=True)
    __type_veh._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3397, 16)
    __type_veh._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3397, 16)

    type_veh = property(__type_veh.value, __type_veh.set, None, 'Identifiant de la classe de v\xe9hicule')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __taux.name(): __taux,
        __type_veh.name(): __type_veh
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_151(pyxb.binding.basis.complexTypeDefinition):
    """DÃ©finition d'une crÃ©ation"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3452, 18)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute instant uses Python identifier instant
    __instant = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'instant'), 'instant',
                                                  '__AbsentNamespace0_CTD_ANON_151_instant',
                                                  pyxb.binding.datatypes.float)
    __instant._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3453, 20)
    __instant._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3453, 20)

    instant = property(__instant.value, __instant.set, None, 'Instant de cr\xe9ation du v\xe9hicule')


    # Attribute typeVehicule uses Python identifier typeVehicule
    __typeVehicule = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'typeVehicule'),
                                                       'typeVehicule', '__AbsentNamespace0_CTD_ANON_151_typeVehicule',
                                                       pyxb.binding.datatypes.string)
    __typeVehicule._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3458, 20)
    __typeVehicule._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3458, 20)

    typeVehicule = property(__typeVehicule.value, __typeVehicule.set, None, 'Type du v\xe9hicule \xe0 cr\xe9er')


    # Attribute destination uses Python identifier destination
    __destination = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'destination'), 'destination',
                                                      '__AbsentNamespace0_CTD_ANON_151_destination',
                                                      pyxb.binding.datatypes.string)
    __destination._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3463, 20)
    __destination._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3463, 20)

    destination = property(__destination.value, __destination.set, None,
                           'Destination du v\xe9hicule cr\xe9\xe9 du v\xe9hicule')


    # Attribute num_voie uses Python identifier num_voie
    __num_voie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'num_voie'), 'num_voie',
                                                   '__AbsentNamespace0_CTD_ANON_151_num_voie', typeIntStrictPositif,
                                                   unicode_default='1')
    __num_voie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3468, 20)
    __num_voie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3468, 20)

    num_voie = property(__num_voie.value, __num_voie.set, None, 'Num\xe9ro de voie du v\xe9hicule \xe0 cr\xe9er')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __instant.name(): __instant,
        __typeVehicule.name(): __typeVehicule,
        __destination.name(): __destination,
        __num_voie.name(): __num_voie
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_152(pyxb.binding.basis.complexTypeDefinition):
    """Description d'une variante de la capacitÃ©"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3496, 18)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute duree uses Python identifier duree
    __duree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree'), 'duree',
                                                '__AbsentNamespace0_CTD_ANON_152_duree', typeDuree,
                                                unicode_default='always')
    __duree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3497, 20)
    __duree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3497, 20)

    duree = property(__duree.value, __duree.set, None,
                     'Identifiant de la plage temporelle associ\xe9e, ou dur\xe9e de la variante')


    # Attribute valeur uses Python identifier valeur
    __valeur = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'valeur'), 'valeur',
                                                 '__AbsentNamespace0_CTD_ANON_152_valeur', typeFloatPositif,
                                                 required=True)
    __valeur._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3502, 20)
    __valeur._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3502, 20)

    valeur = property(__valeur.value, __valeur.set, None,
                      "Valeur en veh/sec de la capacit\xe9 de la sortie pour l'ensemble des voies")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __duree.name(): __duree,
        __valeur.name(): __valeur
    })


# Complex type typeParkingParameters with content type ELEMENT_ONLY
class typeParkingParameters(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeParkingParameters with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeParkingParameters')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3516, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TYPE_VEHICULE_INTERDIT uses Python identifier TYPE_VEHICULE_INTERDIT
    __TYPE_VEHICULE_INTERDIT = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'TYPE_VEHICULE_INTERDIT'), 'TYPE_VEHICULE_INTERDIT',
        '__AbsentNamespace0_typeParkingParameters_TYPE_VEHICULE_INTERDIT', True,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3518, 6), )

    TYPE_VEHICULE_INTERDIT = property(__TYPE_VEHICULE_INTERDIT.value, __TYPE_VEHICULE_INTERDIT.set, None,
                                      'Permet la d\xe9finition de types de v\xe9hicules interdits dans le parking')


    # Attribute stock_max uses Python identifier stock_max
    __stock_max = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'stock_max'), 'stock_max',
                                                    '__AbsentNamespace0_typeParkingParameters_stock_max',
                                                    pyxb.binding.datatypes.int, unicode_default='-1')
    __stock_max._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3531, 4)
    __stock_max._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3531, 4)

    stock_max = property(__stock_max.value, __stock_max.set, None,
                         'Stock maximum de v\xe9hicules propos\xe9 par le parking. -1 : pas de limite (par d\xe9faut).')


    # Attribute stock_initial uses Python identifier stock_initial
    __stock_initial = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'stock_initial'),
                                                        'stock_initial',
                                                        '__AbsentNamespace0_typeParkingParameters_stock_initial',
                                                        pyxb.binding.datatypes.nonNegativeInteger, unicode_default='0')
    __stock_initial._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3536, 4)
    __stock_initial._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3536, 4)

    stock_initial = property(__stock_initial.value, __stock_initial.set, None,
                             'Stock initial de v\xe9hiules dans le parking')


    # Attribute inter_temps_sortie uses Python identifier inter_temps_sortie
    __inter_temps_sortie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'inter_temps_sortie'),
                                                             'inter_temps_sortie',
                                                             '__AbsentNamespace0_typeParkingParameters_inter_temps_sortie',
                                                             typeFloatPositif, unicode_default='0')
    __inter_temps_sortie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3541, 4)
    __inter_temps_sortie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3541, 4)

    inter_temps_sortie = property(__inter_temps_sortie.value, __inter_temps_sortie.set, None,
                                  'Temps minimum entre deux sorties de v\xe9hicules')


    # Attribute inter_temps_entree uses Python identifier inter_temps_entree
    __inter_temps_entree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'inter_temps_entree'),
                                                             'inter_temps_entree',
                                                             '__AbsentNamespace0_typeParkingParameters_inter_temps_entree',
                                                             typeFloatPositif, unicode_default='0')
    __inter_temps_entree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3546, 4)
    __inter_temps_entree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3546, 4)

    inter_temps_entree = property(__inter_temps_entree.value, __inter_temps_entree.set, None,
                                  'Temps minimum entre deux entr\xe9es de v\xe9hicules')

    _ElementMap.update({
        __TYPE_VEHICULE_INTERDIT.name(): __TYPE_VEHICULE_INTERDIT
    })
    _AttributeMap.update({
        __stock_max.name(): __stock_max,
        __stock_initial.name(): __stock_initial,
        __inter_temps_sortie.name(): __inter_temps_sortie,
        __inter_temps_entree.name(): __inter_temps_entree
    })


Namespace.addCategoryObject('typeBinding', 'typeParkingParameters', typeParkingParameters)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_153(pyxb.binding.basis.complexTypeDefinition):
    """Description d'une variante de la matrice OD (la somme des coefficients d'affectation pour l'ensemble des destinations dÃ©clarÃ©es doit Ãªtre Ã©gale Ã  1, si une destination n'est pas dÃ©clarÃ©e son coefficient d'affectation est 0 par dÃ©faut)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3637, 18)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element DESTINATION uses Python identifier DESTINATION
    __DESTINATION = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DESTINATION'),
                                                            'DESTINATION',
                                                            '__AbsentNamespace0_CTD_ANON_153_DESTINATION', True,
                                                            pyxb.utils.utility.Location(
                                                                '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                3639, 22), )

    DESTINATION = property(__DESTINATION.value, __DESTINATION.set, None, None)


    # Attribute duree uses Python identifier duree
    __duree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree'), 'duree',
                                                '__AbsentNamespace0_CTD_ANON_153_duree', typeDuree,
                                                unicode_default='always')
    __duree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3654, 20)
    __duree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3654, 20)

    duree = property(__duree.value, __duree.set, None,
                     'Identifiant de la plage temporelle associ\xe9e, ou dur\xe9e (en seconde) de la variante de la matrice OD')

    _ElementMap.update({
        __DESTINATION.name(): __DESTINATION
    })
    _AttributeMap.update({
        __duree.name(): __duree
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_154(pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type EMPTY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3640, 24)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute sortie uses Python identifier sortie
    __sortie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'sortie'), 'sortie',
                                                 '__AbsentNamespace0_CTD_ANON_154_sortie',
                                                 pyxb.binding.datatypes.string, required=True)
    __sortie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3641, 26)
    __sortie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3641, 26)

    sortie = property(__sortie.value, __sortie.set, None, 'Identifiant de la sortie destination')


    # Attribute coeff uses Python identifier coeff
    __coeff = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'coeff'), 'coeff',
                                                '__AbsentNamespace0_CTD_ANON_154_coeff', typeFloat01, required=True)
    __coeff._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3646, 26)
    __coeff._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3646, 26)

    coeff = property(__coeff.value, __coeff.set, None, "Coefficient d'affectation pour la destination consid\xe9r\xe9e")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __sortie.name(): __sortie,
        __coeff.name(): __coeff
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_155(pyxb.binding.basis.complexTypeDefinition):
    """DÃ©finition du coefficient d'affectation associÃ© Ã  une origine"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3731, 18)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_155_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3732, 20)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3732, 20)

    id = property(__id.value, __id.set, None, "Identifiant de l'origine (groupe de parking)")


    # Attribute coeff uses Python identifier coeff
    __coeff = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'coeff'), 'coeff',
                                                '__AbsentNamespace0_CTD_ANON_155_coeff', typeFloat01, required=True)
    __coeff._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3737, 20)
    __coeff._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3737, 20)

    coeff = property(__coeff.value, __coeff.set, None, "Coefficient d'affectation \xe0 l'origine consid\xe9r\xe9e")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id.name(): __id,
        __coeff.name(): __coeff
    })


# Complex type typeRegulation with content type ELEMENT_ONLY
class typeRegulation(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeRegulation with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeRegulation')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3804, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element DETECTEURS uses Python identifier DETECTEURS
    __DETECTEURS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DETECTEURS'),
                                                           'DETECTEURS', '__AbsentNamespace0_typeRegulation_DETECTEURS',
                                                           False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3806, 6), )

    DETECTEURS = property(__DETECTEURS.value, __DETECTEURS.set, None,
                          'Ensemble des d\xe9tecteurs associ\xe9s \xe0 la brique de r\xe9gulation')


    # Element DECLENCHEURS uses Python identifier DECLENCHEURS
    __DECLENCHEURS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DECLENCHEURS'),
                                                             'DECLENCHEURS',
                                                             '__AbsentNamespace0_typeRegulation_DECLENCHEURS', False,
                                                             pyxb.utils.utility.Location(
                                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                 3844, 6), )

    DECLENCHEURS = property(__DECLENCHEURS.value, __DECLENCHEURS.set, None,
                            'Ensemble des d\xe9clencheurs associ\xe9s \xe0 la brique de r\xe9gulation')


    # Element ACTIONS uses Python identifier ACTIONS
    __ACTIONS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ACTIONS'), 'ACTIONS',
                                                        '__AbsentNamespace0_typeRegulation_ACTIONS', False,
                                                        pyxb.utils.utility.Location(
                                                            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                            3882, 6), )

    ACTIONS = property(__ACTIONS.value, __ACTIONS.set, None,
                       'Ensemble des actions associ\xe9es \xe0 la brique de r\xe9gulation')


    # Element RESTITUTIONS uses Python identifier RESTITUTIONS
    __RESTITUTIONS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RESTITUTIONS'),
                                                             'RESTITUTIONS',
                                                             '__AbsentNamespace0_typeRegulation_RESTITUTIONS', False,
                                                             pyxb.utils.utility.Location(
                                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                 3920, 6), )

    RESTITUTIONS = property(__RESTITUTIONS.value, __RESTITUTIONS.set, None,
                            'Ensemble des d\xe9finitions de restitution dans le fichier de sortie pour la brique de r\xe9gulation')


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeRegulation_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3954, 4)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3954, 4)

    id = property(__id.value, __id.set, None, 'Identifiant de la brique de r\xe9gulation')


    # Attribute taux_respect_consigne uses Python identifier taux_respect_consigne
    __taux_respect_consigne = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'taux_respect_consigne'), 'taux_respect_consigne',
        '__AbsentNamespace0_typeRegulation_taux_respect_consigne', typeFloat01, unicode_default='1')
    __taux_respect_consigne._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3959, 4)
    __taux_respect_consigne._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3959, 4)

    taux_respect_consigne = property(__taux_respect_consigne.value, __taux_respect_consigne.set, None,
                                     'Taux de respect de la consigne')

    _ElementMap.update({
        __DETECTEURS.name(): __DETECTEURS,
        __DECLENCHEURS.name(): __DECLENCHEURS,
        __ACTIONS.name(): __ACTIONS,
        __RESTITUTIONS.name(): __RESTITUTIONS
    })
    _AttributeMap.update({
        __id.name(): __id,
        __taux_respect_consigne.name(): __taux_respect_consigne
    })


Namespace.addCategoryObject('typeBinding', 'typeRegulation', typeRegulation)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_156(pyxb.binding.basis.complexTypeDefinition):
    """Ensemble des plages temporelles dÃ©finies pour l'ensemble de la ou des simulations, dont l'ID peut Ãªtre utilisÃ© pour renseigner la plage de validitÃ© des variantes temporelles (attributs "duree" de certains Ã©lÃ©ments)"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3975, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element PLAGE_TEMPORELLE uses Python identifier PLAGE_TEMPORELLE
    __PLAGE_TEMPORELLE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PLAGE_TEMPORELLE'),
                                                                 'PLAGE_TEMPORELLE',
                                                                 '__AbsentNamespace0_CTD_ANON_156_PLAGE_TEMPORELLE',
                                                                 True, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3977, 14), )

    PLAGE_TEMPORELLE = property(__PLAGE_TEMPORELLE.value, __PLAGE_TEMPORELLE.set, None,
                                'Plage temporelle pouvant \xeatre utilis\xe9e en mode "horaire" pour renseigner la plage de validit\xe9 des variantes temporelles (attributs "duree" de certains \xe9l\xe9ments)')


    # Attribute type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'type'), 'type',
                                               '__AbsentNamespace0_CTD_ANON_156_type', STD_ANON_43,
                                               unicode_default='profil')
    __type._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4000, 12)
    __type._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4000, 12)

    type = property(__type.value, __type.set, None,
                    "Type de d\xe9finition des variations temporelles ('profil' ou 'horaire')")


    # Attribute debut uses Python identifier debut
    __debut = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'debut'), 'debut',
                                                '__AbsentNamespace0_CTD_ANON_156_debut', pyxb.binding.datatypes.time)
    __debut._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4019, 12)
    __debut._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4019, 12)

    debut = property(__debut.value, __debut.set, None,
                     "Heure de d\xe9marrage des premi\xe8res variantes temporelles en mode 'profil'")

    _ElementMap.update({
        __PLAGE_TEMPORELLE.name(): __PLAGE_TEMPORELLE
    })
    _AttributeMap.update({
        __type.name(): __type,
        __debut.name(): __debut
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_157(pyxb.binding.basis.complexTypeDefinition):
    """Description d'un vÃ©hicule prÃ©sent sur le rÃ©seau Ã  l'instant 0"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4348, 34)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_157_id',
                                             pyxb.binding.datatypes.positiveInteger, required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4349, 36)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4349, 36)

    id = property(__id.value, __id.set, None, 'Identifiant du v\xe9hicule')


    # Attribute type_veh uses Python identifier type_veh
    __type_veh = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'type_veh'), 'type_veh',
                                                   '__AbsentNamespace0_CTD_ANON_157_type_veh',
                                                   pyxb.binding.datatypes.string, required=True)
    __type_veh._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4355, 36)
    __type_veh._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4355, 36)

    type_veh = property(__type_veh.value, __type_veh.set, None, 'Identifiant de la classe de v\xe9hicule')


    # Attribute tron uses Python identifier tron
    __tron = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'tron'), 'tron',
                                               '__AbsentNamespace0_CTD_ANON_157_tron', pyxb.binding.datatypes.string,
                                               required=True)
    __tron._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4360, 36)
    __tron._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4360, 36)

    tron = property(__tron.value, __tron.set, None,
                    "Tron\xe7on sur lequel se trouve le v\xe9hicule (il peut ne pas \xeatre d\xe9fini au niveau de la liste des tron\xe7ons notamment dans le cas o\xf9 le v\xe9hicule est positionn\xe9 sur un tron\xe7on interne d'une brique. La v\xe9rification de l'existence du tron\xe7on sera effectu\xe9e apr\xe8s l'initialisation compl\xe8te du r\xe9seau par SymuVia. Si le tron\xe7on n'existe pas, le v\xe9hicule ne sera pas cr\xe9\xe9.\n\t\t\t\t\t\t\t\t")


    # Attribute voie uses Python identifier voie
    __voie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'voie'), 'voie',
                                               '__AbsentNamespace0_CTD_ANON_157_voie', typeIntStrictPositif,
                                               unicode_default='1')
    __voie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4366, 36)
    __voie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4366, 36)

    voie = property(__voie.value, __voie.set, None,
                    "Num\xe9ro de voie sur laquelle se trouve le v\xe9hicule (la v\xe9rification de l'existence de la voie sera effectu\xe9e apr\xe8s l'initialisation compl\xe8te du r\xe9seau par SymuVia. Si le tron\xe7on n'existe pas, le v\xe9hicule ne sera pas cr\xe9\xe9.\n\t\t\t\t\t\t\t\t")


    # Attribute dst uses Python identifier dst
    __dst = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'dst'), 'dst',
                                              '__AbsentNamespace0_CTD_ANON_157_dst', pyxb.binding.datatypes.float,
                                              required=True)
    __dst._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4373, 36)
    __dst._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4373, 36)

    dst = property(__dst.value, __dst.set, None,
                   "Position curviligne du v\xe9hicule sur le tron\xe7on \xe0 l'instant 0 (la v\xe9rification de la valeur de la position sera effectu\xe9e apr\xe8s l'initialisation compl\xe8te du r\xe9seau par SymuVia. Si la position est erron\xe9e, le v\xe9hicule ne sera pas cr\xe9\xe9.\n\t\t\t\t\t\t\t\t")


    # Attribute vit uses Python identifier vit
    __vit = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'vit'), 'vit',
                                              '__AbsentNamespace0_CTD_ANON_157_vit', typeFloatPositif, required=True)
    __vit._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4379, 36)
    __vit._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4379, 36)

    vit = property(__vit.value, __vit.set, None, "Vitesse du v\xe9hicule \xe0 l'instant 0\n\t\t\t\t\t\t\t\t")


    # Attribute acc uses Python identifier acc
    __acc = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'acc'), 'acc',
                                              '__AbsentNamespace0_CTD_ANON_157_acc', pyxb.binding.datatypes.float,
                                              required=True)
    __acc._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4385, 36)
    __acc._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4385, 36)

    acc = property(__acc.value, __acc.set, None, "Acc\xe9l\xe9ration du v\xe9hicule \xe0 l'instant 0\n\t\t\t\t\t\t\t\t")


    # Attribute destination uses Python identifier destination
    __destination = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'destination'), 'destination',
                                                      '__AbsentNamespace0_CTD_ANON_157_destination',
                                                      pyxb.binding.datatypes.string)
    __destination._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4391, 36)
    __destination._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4391, 36)

    destination = property(__destination.value, __destination.set, None,
                           "Destination du v\xe9hicule (identifiant de la sortie). Cet attribut doit \xeatre obligatoirement pr\xe9sent dans le cas d'une simulation avec un flux de type 'destination' ou 'itineraire'.\n\t\t\t\t\t\t\t\t")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id.name(): __id,
        __type_veh.name(): __type_veh,
        __tron.name(): __tron,
        __voie.name(): __voie,
        __dst.name(): __dst,
        __vit.name(): __vit,
        __acc.name(): __acc,
        __destination.name(): __destination
    })


# Complex type typeITINERAIRE with content type ELEMENT_ONLY
class typeITINERAIRE(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeITINERAIRE with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeITINERAIRE')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4861, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element TRONCONS_ uses Python identifier TRONCONS
    __TRONCONS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRONCONS_'), 'TRONCONS',
                                                         '__AbsentNamespace0_typeITINERAIRE_TRONCONS', False,
                                                         pyxb.utils.utility.Location(
                                                             '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                             4863, 6), )

    TRONCONS = property(__TRONCONS.value, __TRONCONS.set, None, "Liste des tron\xe7ons constituant l'itin\xe9raire")


    # Attribute coeffAffectation uses Python identifier coeffAffectation
    __coeffAffectation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'coeffAffectation'),
                                                           'coeffAffectation',
                                                           '__AbsentNamespace0_typeITINERAIRE_coeffAffectation',
                                                           typeFloat01, required=True)
    __coeffAffectation._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4882, 4)
    __coeffAffectation._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4882, 4)

    coeffAffectation = property(__coeffAffectation.value, __coeffAffectation.set, None,
                                "Coefficient d'affectation des vahicules \xe0 cet itin\xe9raire. La somme des coefficients des itin\xe9raires doit \xeatre \xe9gale \xe0 1.")


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeITINERAIRE_id', pyxb.binding.datatypes.string)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4887, 4)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4887, 4)

    id = property(__id.value, __id.set, None,
                  "Identifiant de l'itin\xe9raire d\xe9fini au niveau du noeud RESEAU/ROUTES. Si cet identifiant n'est pas d\xe9fini, l'utilisateur doit list\xe9 les tron\xe7ons de l'itin\xe9raire au niveau du noeud enfant TRONCONS_")

    _ElementMap.update({
        __TRONCONS.name(): __TRONCONS
    })
    _AttributeMap.update({
        __coeffAffectation.name(): __coeffAffectation,
        __id.name(): __id
    })


Namespace.addCategoryObject('typeBinding', 'typeITINERAIRE', typeITINERAIRE)


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_158(pyxb.binding.basis.complexTypeDefinition):
    """Description d'une variante temporelle de demande de l'extrÃ©mitÃ© courante"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4905, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute niveau uses Python identifier niveau
    __niveau = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'niveau'), 'niveau',
                                                 '__AbsentNamespace0_CTD_ANON_158_niveau', typeFloatPositif)
    __niveau._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4906, 16)
    __niveau._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4906, 16)

    niveau = property(__niveau.value, __niveau.set, None, 'Niveau de la demande en veh/s')


    # Attribute duree uses Python identifier duree
    __duree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree'), 'duree',
                                                '__AbsentNamespace0_CTD_ANON_158_duree', typeDuree,
                                                unicode_default='always')
    __duree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4911, 16)
    __duree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4911, 16)

    duree = property(__duree.value, __duree.set, None, 'Dur\xe9e de la variante temporelle\n')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __niveau.name(): __niveau,
        __duree.name(): __duree
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_159(pyxb.binding.basis.complexTypeDefinition):
    """Description de la variante temporelle de la rÃ©partition vers les destinations"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4932, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element DESTINATION uses Python identifier DESTINATION
    __DESTINATION = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'DESTINATION'),
                                                            'DESTINATION',
                                                            '__AbsentNamespace0_CTD_ANON_159_DESTINATION', True,
                                                            pyxb.utils.utility.Location(
                                                                '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                4934, 18), )

    DESTINATION = property(__DESTINATION.value, __DESTINATION.set, None,
                           "Description d'une destination de l'extr\xe9mit\xe9 courante\n")


    # Attribute duree uses Python identifier duree
    __duree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree'), 'duree',
                                                '__AbsentNamespace0_CTD_ANON_159_duree', typeDuree,
                                                unicode_default='always')
    __duree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4987, 16)
    __duree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4987, 16)

    duree = property(__duree.value, __duree.set, None, 'Dur\xe9e de la variante temporelle')

    _ElementMap.update({
        __DESTINATION.name(): __DESTINATION
    })
    _AttributeMap.update({
        __duree.name(): __duree
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_160(pyxb.binding.basis.complexTypeDefinition):
    """Description d'une destination de l'extrÃ©mitÃ© courante
"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4939, 20)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element ROUTE uses Python identifier ROUTE
    __ROUTE = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ROUTE'), 'ROUTE',
                                                      '__AbsentNamespace0_CTD_ANON_160_ROUTE', True,
                                                      pyxb.utils.utility.Location(
                                                          '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                          4944, 24), )

    ROUTE = property(__ROUTE.value, __ROUTE.set, None, None)


    # Attribute sortie uses Python identifier sortie
    __sortie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'sortie'), 'sortie',
                                                 '__AbsentNamespace0_CTD_ANON_160_sortie',
                                                 pyxb.binding.datatypes.string, required=True)
    __sortie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4947, 22)
    __sortie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4947, 22)

    sortie = property(__sortie.value, __sortie.set, None, 'Identifiant de la sortie destination')


    # Attribute coeffOD uses Python identifier coeffOD
    __coeffOD = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'coeffOD'), 'coeffOD',
                                                  '__AbsentNamespace0_CTD_ANON_160_coeffOD', typeFloat01, required=True)
    __coeffOD._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4952, 22)
    __coeffOD._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4952, 22)

    coeffOD = property(__coeffOD.value, __coeffOD.set, None,
                       "Coefficient de la matrice OD pour l'origine (extr\xe9lit\xe9 courante) et la destination consid\xe9r\xe9e")


    # Attribute affectation_teta_logit uses Python identifier affectation_teta_logit
    __affectation_teta_logit = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_teta_logit'), 'affectation_teta_logit',
        '__AbsentNamespace0_CTD_ANON_160_affectation_teta_logit', typeFloatStrictPositif)
    __affectation_teta_logit._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4957, 22)
    __affectation_teta_logit._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4957, 22)

    affectation_teta_logit = property(__affectation_teta_logit.value, __affectation_teta_logit.set, None,
                                      "Param\xe8tre teta du mod\xe8le logit de l'affectation sp\xe9cifique pour ce couple OD")


    # Attribute nombre_pluscourtchemin uses Python identifier nombre_pluscourtchemin
    __nombre_pluscourtchemin = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'nombre_pluscourtchemin'), 'nombre_pluscourtchemin',
        '__AbsentNamespace0_CTD_ANON_160_nombre_pluscourtchemin', typeIntStrictPositif)
    __nombre_pluscourtchemin._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4963, 22)
    __nombre_pluscourtchemin._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4963, 22)

    nombre_pluscourtchemin = property(__nombre_pluscourtchemin.value, __nombre_pluscourtchemin.set, None,
                                      "Nombre de plus court chemin \xe0 consid\xe9rer dans le cas d'un comportment de flux de type 'itineraire' pour ce couple OD")


    # Attribute affectation_commonality_alpha uses Python identifier affectation_commonality_alpha
    __affectation_commonality_alpha = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_commonality_alpha'), 'affectation_commonality_alpha',
        '__AbsentNamespace0_CTD_ANON_160_affectation_commonality_alpha', pyxb.binding.datatypes.float)
    __affectation_commonality_alpha._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4969, 22)
    __affectation_commonality_alpha._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4969, 22)

    affectation_commonality_alpha = property(__affectation_commonality_alpha.value, __affectation_commonality_alpha.set,
                                             None,
                                             "Valeur maximum du commonality factor admissible pour les itin\xe9raires calcul\xe9s par le module d'affectation pour ce couple OD")


    # Attribute affectation_commonality_beta uses Python identifier affectation_commonality_beta
    __affectation_commonality_beta = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_commonality_beta'), 'affectation_commonality_beta',
        '__AbsentNamespace0_CTD_ANON_160_affectation_commonality_beta', typeFloat01)
    __affectation_commonality_beta._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4974, 22)
    __affectation_commonality_beta._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4974, 22)

    affectation_commonality_beta = property(__affectation_commonality_beta.value, __affectation_commonality_beta.set,
                                            None,
                                            'Valeur du param\xe8tre beta pour le calcul du commonality factor pour ce couple OD')


    # Attribute affectation_commonality_gamma uses Python identifier affectation_commonality_gamma
    __affectation_commonality_gamma = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_commonality_gamma'), 'affectation_commonality_gamma',
        '__AbsentNamespace0_CTD_ANON_160_affectation_commonality_gamma', typeFloat01)
    __affectation_commonality_gamma._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4979, 22)
    __affectation_commonality_gamma._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4979, 22)

    affectation_commonality_gamma = property(__affectation_commonality_gamma.value, __affectation_commonality_gamma.set,
                                             None,
                                             'Valeur du param\xe8tre gamma pour le calcul du commonality factor pour ce couple OD')

    _ElementMap.update({
        __ROUTE.name(): __ROUTE
    })
    _AttributeMap.update({
        __sortie.name(): __sortie,
        __coeffOD.name(): __coeffOD,
        __affectation_teta_logit.name(): __affectation_teta_logit,
        __nombre_pluscourtchemin.name(): __nombre_pluscourtchemin,
        __affectation_commonality_alpha.name(): __affectation_commonality_alpha,
        __affectation_commonality_beta.name(): __affectation_commonality_beta,
        __affectation_commonality_gamma.name(): __affectation_commonality_gamma
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_161(pyxb.binding.basis.complexTypeDefinition):
    """Description d'une variante temporelle de la rÃ©partition par voie du flux provenant de l'extrÃ©mitÃ© (origine) courante"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               5007, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute duree uses Python identifier duree
    __duree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree'), 'duree',
                                                '__AbsentNamespace0_CTD_ANON_161_duree', typeDuree,
                                                unicode_default='always')
    __duree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 5008, 16)
    __duree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 5008, 16)

    duree = property(__duree.value, __duree.set, None, 'Dur\xe9e de la variante temporelle')


    # Attribute coeffs uses Python identifier coeffs
    __coeffs = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'coeffs'), 'coeffs',
                                                 '__AbsentNamespace0_CTD_ANON_161_coeffs',
                                                 pyxb.binding.datatypes.anySimpleType, unicode_default='always')
    __coeffs._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 5013, 16)
    __coeffs._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 5013, 16)

    coeffs = property(__coeffs.value, __coeffs.set, None,
                      "Liste ordonn\xe9e des coefficients de r\xe9partition sur les voies du tron\xe7on amont de l'extr\xe9mit\xe9 courante")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __duree.name(): __duree,
        __coeffs.name(): __coeffs
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_162(pyxb.binding.basis.complexTypeDefinition):
    """
                  Description d'un point interne du tronÃ§on
                """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               102, 8)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute coordonnees uses Python identifier coordonnees
    __coordonnees = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'coordonnees'), 'coordonnees',
                                                      '__AbsentNamespace0_CTD_ANON_162_coordonnees', typeCoordonnees,
                                                      required=True)
    __coordonnees._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 103, 10)
    __coordonnees._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 103, 10)

    coordonnees = property(__coordonnees.value, __coordonnees.set, None,
                           'Coordonn\xe9es g\xe9ographiques du point interne')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __coordonnees.name(): __coordonnees
    })


# Complex type typeParametrageSimulation with content type ELEMENT_ONLY
class typeParametrageSimulation(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeParametrageSimulation with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeParametrageSimulation')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               493, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element RESTITUTION uses Python identifier RESTITUTION
    __RESTITUTION = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'RESTITUTION'),
                                                            'RESTITUTION',
                                                            '__AbsentNamespace0_typeParametrageSimulation_RESTITUTION',
                                                            False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 495, 6), )

    RESTITUTION = property(__RESTITUTION.value, __RESTITUTION.set, None,
                           "Noeud regroupant l'ensemble des options de modulation du contenu des fichiers de sortie")


    # Element ELEMENTS uses Python identifier ELEMENTS
    __ELEMENTS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ELEMENTS'), 'ELEMENTS',
                                                         '__AbsentNamespace0_typeParametrageSimulation_ELEMENTS', False,
                                                         pyxb.utils.utility.Location(
                                                             '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                             607, 6), )

    ELEMENTS = property(__ELEMENTS.value, __ELEMENTS.set, None,
                        'Ensemble des \xe9l\xe9ments du r\xe9seau pour lesquels sont d\xe9finis des param\xe8tres de simulation sp\xe9cifiques')


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeParametrageSimulation_id',
                                             pyxb.binding.datatypes.ID, required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 622, 4)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 622, 4)

    id = property(__id.value, __id.set, None, 'Identifiant de la section SIMULATION')


    # Attribute pasdetemps uses Python identifier pasdetemps
    __pasdetemps = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'pasdetemps'), 'pasdetemps',
                                                     '__AbsentNamespace0_typeParametrageSimulation_pasdetemps',
                                                     typeFloatStrictPositif, required=True)
    __pasdetemps._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 627, 4)
    __pasdetemps._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 627, 4)

    pasdetemps = property(__pasdetemps.value, __pasdetemps.set, None, 'Pas de temps de simulation')


    # Attribute debut uses Python identifier debut
    __debut = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'debut'), 'debut',
                                                '__AbsentNamespace0_typeParametrageSimulation_debut',
                                                pyxb.binding.datatypes.time, required=True)
    __debut._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 632, 4)
    __debut._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 632, 4)

    debut = property(__debut.value, __debut.set, None, 'Heure de d\xe9but de la simulation (Heures:Minutes:Secondes)')


    # Attribute fin uses Python identifier fin
    __fin = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'fin'), 'fin',
                                              '__AbsentNamespace0_typeParametrageSimulation_fin',
                                              pyxb.binding.datatypes.time, required=True)
    __fin._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 637, 4)
    __fin._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 637, 4)

    fin = property(__fin.value, __fin.set, None, 'Heure de fin de la simulation (Heures:Minutes:Secondes)')


    # Attribute simulation_trafic uses Python identifier simulation_trafic
    __simulation_trafic = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'simulation_trafic'),
                                                            'simulation_trafic',
                                                            '__AbsentNamespace0_typeParametrageSimulation_simulation_trafic',
                                                            pyxb.binding.datatypes.boolean, unicode_default='true')
    __simulation_trafic._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 642, 4)
    __simulation_trafic._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 642, 4)

    simulation_trafic = property(__simulation_trafic.value, __simulation_trafic.set, None,
                                 'Indique si la simulation du trafic doit avoir lieu')


    # Attribute simulation_acoustique uses Python identifier simulation_acoustique
    __simulation_acoustique = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'simulation_acoustique'), 'simulation_acoustique',
        '__AbsentNamespace0_typeParametrageSimulation_simulation_acoustique', pyxb.binding.datatypes.boolean,
        unicode_default='false')
    __simulation_acoustique._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 647, 4)
    __simulation_acoustique._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 647, 4)

    simulation_acoustique = property(__simulation_acoustique.value, __simulation_acoustique.set, None,
                                     'Indique si la simulation des \xe9missions acoustiques doit avoir lieu')


    # Attribute simulation_atmospherique uses Python identifier simulation_atmospherique
    __simulation_atmospherique = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'simulation_atmospherique'), 'simulation_atmospherique',
        '__AbsentNamespace0_typeParametrageSimulation_simulation_atmospherique', pyxb.binding.datatypes.boolean,
        unicode_default='false')
    __simulation_atmospherique._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 652, 4)
    __simulation_atmospherique._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 652, 4)

    simulation_atmospherique = property(__simulation_atmospherique.value, __simulation_atmospherique.set, None,
                                        'Indique si la simulation des \xe9missions atmosph\xe9riques doit avoir lieu')


    # Attribute type_sortieacoustique uses Python identifier type_sortieacoustique
    __type_sortieacoustique = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'type_sortieacoustique'), 'type_sortieacoustique',
        '__AbsentNamespace0_typeParametrageSimulation_type_sortieacoustique', STD_ANON_3, unicode_default='C')
    __type_sortieacoustique._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 657, 4)
    __type_sortieacoustique._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 657, 4)

    type_sortieacoustique = property(__type_sortieacoustique.value, __type_sortieacoustique.set, None,
                                     'Type de sortie acoustique')


    # Attribute loipoursuite uses Python identifier loipoursuite
    __loipoursuite = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'loipoursuite'),
                                                       'loipoursuite',
                                                       '__AbsentNamespace0_typeParametrageSimulation_loipoursuite',
                                                       STD_ANON_4, unicode_default='estimee')
    __loipoursuite._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 676, 4)
    __loipoursuite._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 676, 4)

    loipoursuite = property(__loipoursuite.value, __loipoursuite.set, None, 'Indique la loi de poursuite utilis\xe9e')


    # Attribute comportementflux uses Python identifier comportementflux
    __comportementflux = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'comportementflux'),
                                                           'comportementflux',
                                                           '__AbsentNamespace0_typeParametrageSimulation_comportementflux',
                                                           STD_ANON_5, required=True)
    __comportementflux._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 695, 4)
    __comportementflux._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 695, 4)

    comportementflux = property(__comportementflux.value, __comportementflux.set, None, 'Comportement du flux')


    # Attribute nombre_pluscourtchemin uses Python identifier nombre_pluscourtchemin
    __nombre_pluscourtchemin = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'nombre_pluscourtchemin'), 'nombre_pluscourtchemin',
        '__AbsentNamespace0_typeParametrageSimulation_nombre_pluscourtchemin', typeIntStrictPositif,
        unicode_default='1')
    __nombre_pluscourtchemin._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 719, 4)
    __nombre_pluscourtchemin._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 719, 4)

    nombre_pluscourtchemin = property(__nombre_pluscourtchemin.value, __nombre_pluscourtchemin.set, None,
                                      "Nombre de plus court chemin \xe0 consid\xe9rer dans le cas d'un comportment de flux de type 'itineraire'")


    # Attribute offre_aval_convergent_deltaN uses Python identifier offre_aval_convergent_deltaN
    __offre_aval_convergent_deltaN = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'offre_aval_convergent_deltaN'), 'offre_aval_convergent_deltaN',
        '__AbsentNamespace0_typeParametrageSimulation_offre_aval_convergent_deltaN', pyxb.binding.datatypes.boolean,
        unicode_default='false')
    __offre_aval_convergent_deltaN._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 725, 4)
    __offre_aval_convergent_deltaN._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 725, 4)

    offre_aval_convergent_deltaN = property(__offre_aval_convergent_deltaN.value, __offre_aval_convergent_deltaN.set,
                                            None,
                                            "Indique si l'offre en aval des convergents du r\xe9seau est calcul\xe9 \xe0 l'aide de la quantit\xe9 deltaN ou non ")


    # Attribute calcul_tq_convergent uses Python identifier calcul_tq_convergent
    __calcul_tq_convergent = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'calcul_tq_convergent'), 'calcul_tq_convergent',
        '__AbsentNamespace0_typeParametrageSimulation_calcul_tq_convergent', pyxb.binding.datatypes.boolean,
        unicode_default='false')
    __calcul_tq_convergent._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 731, 4)
    __calcul_tq_convergent._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 731, 4)

    calcul_tq_convergent = property(__calcul_tq_convergent.value, __calcul_tq_convergent.set, None,
                                    "Indique si le calcul d'insertion du convergent prend en compte tq")


    # Attribute date uses Python identifier date
    __date = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'date'), 'date',
                                               '__AbsentNamespace0_typeParametrageSimulation_date',
                                               pyxb.binding.datatypes.date)
    __date._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 736, 4)
    __date._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 736, 4)

    date = property(__date.value, __date.set, None, 'Date de la simulation')


    # Attribute titre uses Python identifier titre
    __titre = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'titre'), 'titre',
                                                '__AbsentNamespace0_typeParametrageSimulation_titre', typeString256)
    __titre._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 741, 4)
    __titre._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 741, 4)

    titre = property(__titre.value, __titre.set, None, 'Titre de la simulation')


    # Attribute proc_deceleration uses Python identifier proc_deceleration
    __proc_deceleration = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'proc_deceleration'),
                                                            'proc_deceleration',
                                                            '__AbsentNamespace0_typeParametrageSimulation_proc_deceleration',
                                                            pyxb.binding.datatypes.boolean, unicode_default='0')
    __proc_deceleration._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 746, 4)
    __proc_deceleration._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 746, 4)

    proc_deceleration = property(__proc_deceleration.value, __proc_deceleration.set, None,
                                 'Indique si la proc\xe9dure de d\xe9c\xe9l\xe9ration doit \xeatre lanc\xe9e \xe0 la fin du calcul')


    # Attribute proc_dec_taux uses Python identifier proc_dec_taux
    __proc_dec_taux = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'proc_dec_taux'),
                                                        'proc_dec_taux',
                                                        '__AbsentNamespace0_typeParametrageSimulation_proc_dec_taux',
                                                        typeFloatStrictPositif, unicode_default='3')
    __proc_dec_taux._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 751, 4)
    __proc_dec_taux._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 751, 4)

    proc_dec_taux = property(__proc_dec_taux.value, __proc_dec_taux.set, None,
                             'Valeur du taux de d\xe9c\xe9l\xe9ration \xe0 prendre en compte dans la proc\xe9dure de d\xe9c\xe9l\xe9ration')


    # Attribute seed uses Python identifier seed
    __seed = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'seed'), 'seed',
                                               '__AbsentNamespace0_typeParametrageSimulation_seed',
                                               pyxb.binding.datatypes.unsignedInt, unicode_default='0')
    __seed._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 756, 4)
    __seed._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 756, 4)

    seed = property(__seed.value, __seed.set, None,
                    "Graine du g\xe9n\xe9rateur al\xe9atoire (deux ex\xe9cutions avec le m\xeame seed donnent des r\xe9sultats identiques).\nLa valeur par d\xe9faut 0 signifie que le 'seed' est \xe9valu\xe9 par le logiciel.")


    # Attribute affectation uses Python identifier affectation
    __affectation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'affectation'), 'affectation',
                                                      '__AbsentNamespace0_typeParametrageSimulation_affectation',
                                                      STD_ANON_6, unicode_default='statique')
    __affectation._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 762, 4)
    __affectation._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 762, 4)

    affectation = property(__affectation.value, __affectation.set, None,
                           "Type d'affectation dans le cas d'un comportement de flux 'itineraire'")


    # Attribute periode_affectation uses Python identifier periode_affectation
    __periode_affectation = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'periode_affectation'),
                                                              'periode_affectation',
                                                              '__AbsentNamespace0_typeParametrageSimulation_periode_affectation',
                                                              typeIntStrictPositif, unicode_default='900')
    __periode_affectation._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 773, 4)
    __periode_affectation._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 773, 4)

    periode_affectation = property(__periode_affectation.value, __periode_affectation.set, None,
                                   "P\xe9riode d'affectation dans le cas d'un comportement de flux de type 'affectation_calculee'. Elle est saisie sous la forme d'un coefficient multiplicateur entier du pas de temps. Afin d'estimer au mieux les temps de parcours de chaque tron\xe7on, la p\xe9riode doit \xeatre suffisamment grande pour que plusieurs v\xe9hicules aient le temps de parcourir enti\xe8rement le tron\xe7on.")


    # Attribute affectation_equilibre uses Python identifier affectation_equilibre
    __affectation_equilibre = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_equilibre'), 'affectation_equilibre',
        '__AbsentNamespace0_typeParametrageSimulation_affectation_equilibre', STD_ANON_7, unicode_default='NE')
    __affectation_equilibre._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 779, 4)
    __affectation_equilibre._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 779, 4)

    affectation_equilibre = property(__affectation_equilibre.value, __affectation_equilibre.set, None,
                                     "Param\xe9trage de la gestion de l'\xe9quilibre d'affectation : sans recherche d'\xe9quilibre (NE), recherche d'\xe9quilibre sans m\xe9moire (ENM), recherche d'\xe9quilibre par la m\xe9thode des moyennes successives(EMS) ")


    # Attribute affectation_type_temps_de_parcours uses Python identifier affectation_type_temps_de_parcours
    __affectation_type_temps_de_parcours = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_type_temps_de_parcours'), 'affectation_type_temps_de_parcours',
        '__AbsentNamespace0_typeParametrageSimulation_affectation_type_temps_de_parcours', STD_ANON_8,
        unicode_default='R')
    __affectation_type_temps_de_parcours._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 803, 4)
    __affectation_type_temps_de_parcours._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 803, 4)

    affectation_type_temps_de_parcours = property(__affectation_type_temps_de_parcours.value,
                                                  __affectation_type_temps_de_parcours.set, None,
                                                  'Type de calcul du temps de parcours : r\xe9alis\xe9 (R) ou pr\xe9dictif (P)')


    # Attribute affectation_variation_temps_de_parcours uses Python identifier affectation_variation_temps_de_parcours
    __affectation_variation_temps_de_parcours = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_variation_temps_de_parcours'),
        'affectation_variation_temps_de_parcours',
        '__AbsentNamespace0_typeParametrageSimulation_affectation_variation_temps_de_parcours', typeFloat01,
        unicode_default='1')
    __affectation_variation_temps_de_parcours._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 827, 4)
    __affectation_variation_temps_de_parcours._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 827, 4)

    affectation_variation_temps_de_parcours = property(__affectation_variation_temps_de_parcours.value,
                                                       __affectation_variation_temps_de_parcours.set, None,
                                                       "Variation minimale du temps de parcours d'un tron\xe7on entra\xeenant le calcul des coefficients d'affectation des connexions en amont du tron\xe7on")


    # Attribute affectation_nb_connexion_amont uses Python identifier affectation_nb_connexion_amont
    __affectation_nb_connexion_amont = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_nb_connexion_amont'), 'affectation_nb_connexion_amont',
        '__AbsentNamespace0_typeParametrageSimulation_affectation_nb_connexion_amont', typeIntStrictPositif,
        unicode_default='1')
    __affectation_nb_connexion_amont._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 833, 4)
    __affectation_nb_connexion_amont._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 833, 4)

    affectation_nb_connexion_amont = property(__affectation_nb_connexion_amont.value,
                                              __affectation_nb_connexion_amont.set, None,
                                              "Nombre de niveau \xe0 remonter \xe0 partir d'un tron\xe7on lors du calcul des coefficients d'affectation suite \xe0 une variation importante du temps de parcours du tron\xe7on")


    # Attribute affectation_teta_logit uses Python identifier affectation_teta_logit
    __affectation_teta_logit = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_teta_logit'), 'affectation_teta_logit',
        '__AbsentNamespace0_typeParametrageSimulation_affectation_teta_logit', typeFloatStrictPositif,
        unicode_default='0.01')
    __affectation_teta_logit._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 839, 4)
    __affectation_teta_logit._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 839, 4)

    affectation_teta_logit = property(__affectation_teta_logit.value, __affectation_teta_logit.set, None,
                                      "Param\xe8tre teta du mod\xe8le logit de l'affectation")


    # Attribute affectation_mode uses Python identifier affectation_mode
    __affectation_mode = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'affectation_mode'),
                                                           'affectation_mode',
                                                           '__AbsentNamespace0_typeParametrageSimulation_affectation_mode',
                                                           STD_ANON_9, unicode_default='logit')
    __affectation_mode._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 845, 4)
    __affectation_mode._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 845, 4)

    affectation_mode = property(__affectation_mode.value, __affectation_mode.set, None,
                                "Module d'affectation : mode d'affectation")


    # Attribute affectation_seuil_convergence uses Python identifier affectation_seuil_convergence
    __affectation_seuil_convergence = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_seuil_convergence'), 'affectation_seuil_convergence',
        '__AbsentNamespace0_typeParametrageSimulation_affectation_seuil_convergence', typeFloat01,
        unicode_default='0.1')
    __affectation_seuil_convergence._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 864, 4)
    __affectation_seuil_convergence._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 864, 4)

    affectation_seuil_convergence = property(__affectation_seuil_convergence.value, __affectation_seuil_convergence.set,
                                             None,
                                             "Module d'affectation : seuil de convergence sur l'ensemble du r\xe9seau \xe0 atteindre lors d'une recherche d'\xe9quilibre")


    # Attribute affectation_nb_it_max uses Python identifier affectation_nb_it_max
    __affectation_nb_it_max = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_nb_it_max'), 'affectation_nb_it_max',
        '__AbsentNamespace0_typeParametrageSimulation_affectation_nb_it_max', typeIntStrictPositif,
        unicode_default='100')
    __affectation_nb_it_max._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 869, 4)
    __affectation_nb_it_max._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 869, 4)

    affectation_nb_it_max = property(__affectation_nb_it_max.value, __affectation_nb_it_max.set, None,
                                     "Module d'affectation : nombre maximal d'it\xe9ration \xe0 r\xe9aliser lors d'une recherche d'\xe9quilibre (si le seuil de convergence n'est pas atteind). Si le nombre maximal est atteind, les coefficients d'affectation calcul\xe9s au cours de la derni\xe8re it\xe9ration sont appliqu\xe9s\n")


    # Attribute affectation_calculKSP uses Python identifier affectation_calculKSP
    __affectation_calculKSP = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_calculKSP'), 'affectation_calculKSP',
        '__AbsentNamespace0_typeParametrageSimulation_affectation_calculKSP', STD_ANON_10, unicode_default='Dijkstra')
    __affectation_calculKSP._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 875, 4)
    __affectation_calculKSP._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 875, 4)

    affectation_calculKSP = property(__affectation_calculKSP.value, __affectation_calculKSP.set, None,
                                     'Indique le mode de calcul des k plus courts chemins')


    # Attribute affectation_seuil_tempsdeparcours uses Python identifier affectation_seuil_tempsdeparcours
    __affectation_seuil_tempsdeparcours = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_seuil_tempsdeparcours'), 'affectation_seuil_tempsdeparcours',
        '__AbsentNamespace0_typeParametrageSimulation_affectation_seuil_tempsdeparcours', typeFloat01,
        unicode_default='0.1')
    __affectation_seuil_tempsdeparcours._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 894, 4)
    __affectation_seuil_tempsdeparcours._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 894, 4)

    affectation_seuil_tempsdeparcours = property(__affectation_seuil_tempsdeparcours.value,
                                                 __affectation_seuil_tempsdeparcours.set, None,
                                                 "Seuil maximal d'\xe9cart des temps de parcours r\xe9alis\xe9s et pr\xe9dits pour consid\xe9rer un tron\xe7on comme correctement affect\xe9")


    # Attribute affectation_poids_max uses Python identifier affectation_poids_max
    __affectation_poids_max = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_poids_max'), 'affectation_poids_max',
        '__AbsentNamespace0_typeParametrageSimulation_affectation_poids_max', typeFloatStrictPositif,
        unicode_default='9999')
    __affectation_poids_max._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 899, 4)
    __affectation_poids_max._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 899, 4)

    affectation_poids_max = property(__affectation_poids_max.value, __affectation_poids_max.set, None,
                                     "Poids maximum avec lequel est initialis\xe9 le poids de chaque connection pour l'application de l'algorithme Dijkstra de recherche des plus courts chemins. \nAttention, une valeur trop \xe9lev\xe9e d\xe9grade les performances de l'algorithme notamment dans le cas o\xf9 il n'existe pas d'itin\xe9raire pour un couple origine-destination \xe0 cause de mouvements non autoris\xe9s (la m\xe9thode de recheche d'itin\xe9raires utilise une p\xe9nalisation des arcs afin de parcourir tout le r\xe9seau, et pour sortir de l'algo, le poids maximum doit \xeatre atteind). Une valeur trop basse peut avoir pour cons\xe9quence de ne pas calculer certains itin\xe9raires (sortie pr\xe9matur\xe9e de l'algorithme).")


    # Attribute resolution uses Python identifier resolution
    __resolution = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'resolution'), 'resolution',
                                                     '__AbsentNamespace0_typeParametrageSimulation_resolution',
                                                     STD_ANON_11, unicode_default='H')
    __resolution._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 905, 4)
    __resolution._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 905, 4)

    resolution = property(__resolution.value, __resolution.set, None,
                          'R\xe9solution par d\xe9faut des \xe9l\xe9ments du r\xe9seau associ\xe9')


    # Attribute nb_cell_acoustique uses Python identifier nb_cell_acoustique
    __nb_cell_acoustique = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'nb_cell_acoustique'),
                                                             'nb_cell_acoustique',
                                                             '__AbsentNamespace0_typeParametrageSimulation_nb_cell_acoustique',
                                                             pyxb.binding.datatypes.nonNegativeInteger,
                                                             unicode_default='0')
    __nb_cell_acoustique._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 929, 4)
    __nb_cell_acoustique._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 929, 4)

    nb_cell_acoustique = property(__nb_cell_acoustique.value, __nb_cell_acoustique.set, None,
                                  'Nombre de cellule(s) acoustique(s) par d\xe9faut des \xe9l\xe9ments du r\xe9seau')


    # Attribute longueur_cell_acoustique uses Python identifier longueur_cell_acoustique
    __longueur_cell_acoustique = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'longueur_cell_acoustique'), 'longueur_cell_acoustique',
        '__AbsentNamespace0_typeParametrageSimulation_longueur_cell_acoustique', typeFloatPositif, unicode_default='0')
    __longueur_cell_acoustique._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 934, 4)
    __longueur_cell_acoustique._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 934, 4)

    longueur_cell_acoustique = property(__longueur_cell_acoustique.value, __longueur_cell_acoustique.set, None,
                                        "Longueur (en m\xe8tre) d\xe9sir\xe9e des cellules acoustiques par d\xe9faut des \xe9l\xe9ments du r\xe9seau. (pour chaque tron\xe7on / tron\xe7on interne, le nombre de cellules acoustiques sera calcul\xe9e afin d'approcher au mieux la longueur de cellule d\xe9sir\xe9e)")


    # Attribute simulation_sirane uses Python identifier simulation_sirane
    __simulation_sirane = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'simulation_sirane'),
                                                            'simulation_sirane',
                                                            '__AbsentNamespace0_typeParametrageSimulation_simulation_sirane',
                                                            pyxb.binding.datatypes.boolean, unicode_default='false')
    __simulation_sirane._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 939, 4)
    __simulation_sirane._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 939, 4)

    simulation_sirane = property(__simulation_sirane.value, __simulation_sirane.set, None,
                                 'Indique si le calcul des donn\xe9es n\xe9cessaires \xe0 Sirane (agr\xe9gation du temps pass\xe9 par les v\xe9hicules dans chaque plage de vitesse) est demand\xe9.')


    # Attribute nb_cell_sirane uses Python identifier nb_cell_sirane
    __nb_cell_sirane = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'nb_cell_sirane'),
                                                         'nb_cell_sirane',
                                                         '__AbsentNamespace0_typeParametrageSimulation_nb_cell_sirane',
                                                         pyxb.binding.datatypes.positiveInteger, unicode_default='3')
    __nb_cell_sirane._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 944, 4)
    __nb_cell_sirane._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 944, 4)

    nb_cell_sirane = property(__nb_cell_sirane.value, __nb_cell_sirane.set, None,
                              'Nombre de cellules \xe0 cr\xe9er par tron\xe7on pour le calcul des donn\xe9es n\xe9cessaires \xe0 Sirane')


    # Attribute min_longueur_cell_sirane uses Python identifier min_longueur_cell_sirane
    __min_longueur_cell_sirane = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'min_longueur_cell_sirane'), 'min_longueur_cell_sirane',
        '__AbsentNamespace0_typeParametrageSimulation_min_longueur_cell_sirane', typeFloatPositif, unicode_default='10')
    __min_longueur_cell_sirane._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 949, 4)
    __min_longueur_cell_sirane._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 949, 4)

    min_longueur_cell_sirane = property(__min_longueur_cell_sirane.value, __min_longueur_cell_sirane.set, None,
                                        "Longueur minimum (en m\xe8tres) d'une cellule pour le calcul des donn\xe9es n\xe9cessaires \xe0 Sirane")


    # Attribute periode_agregation_sirane uses Python identifier periode_agregation_sirane
    __periode_agregation_sirane = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'periode_agregation_sirane'), 'periode_agregation_sirane',
        '__AbsentNamespace0_typeParametrageSimulation_periode_agregation_sirane', typeFloatStrictPositif,
        unicode_default='300')
    __periode_agregation_sirane._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 954, 4)
    __periode_agregation_sirane._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 954, 4)

    periode_agregation_sirane = property(__periode_agregation_sirane.value, __periode_agregation_sirane.set, None,
                                         "P\xe9riode d'agr\xe9gation (en secondes) pour le calcul des donn\xe9es n\xe9cessaires \xe0 Sirane")


    # Attribute mode_zone_origine uses Python identifier mode_zone_origine
    __mode_zone_origine = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'mode_zone_origine'),
                                                            'mode_zone_origine',
                                                            '__AbsentNamespace0_typeParametrageSimulation_mode_zone_origine',
                                                            STD_ANON_12, unicode_default='surfacique')
    __mode_zone_origine._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 959, 4)
    __mode_zone_origine._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 959, 4)

    mode_zone_origine = property(__mode_zone_origine.value, __mode_zone_origine.set, None,
                                 'Mode de gestion de la cr\xe9ation des v\xe9hicules au d\xe9part des zones de terminaison')


    # Attribute mode_zone_destination uses Python identifier mode_zone_destination
    __mode_zone_destination = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'mode_zone_destination'), 'mode_zone_destination',
        '__AbsentNamespace0_typeParametrageSimulation_mode_zone_destination', STD_ANON_13, unicode_default='surfacique')
    __mode_zone_destination._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 978, 4)
    __mode_zone_destination._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 978, 4)

    mode_zone_destination = property(__mode_zone_destination.value, __mode_zone_destination.set, None,
                                     "Mode de gestion des v\xe9hicules \xe0 l'arriv\xe9e aux zones de terminaison")


    # Attribute affectation_reroutage uses Python identifier affectation_reroutage
    __affectation_reroutage = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_reroutage'), 'affectation_reroutage',
        '__AbsentNamespace0_typeParametrageSimulation_affectation_reroutage', pyxb.binding.datatypes.boolean,
        unicode_default='false')
    __affectation_reroutage._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 997, 4)
    __affectation_reroutage._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 997, 4)

    affectation_reroutage = property(__affectation_reroutage.value, __affectation_reroutage.set, None,
                                     "Permet d'activer ou non la reaffectation dynamique des v\xe9hicules d\xe9j\xe0 pr\xe9sents sur le r\xe9seau (ou en attente aux entr\xe9es)")


    # Attribute affectation_reroutage_dstmax uses Python identifier affectation_reroutage_dstmax
    __affectation_reroutage_dstmax = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_reroutage_dstmax'), 'affectation_reroutage_dstmax',
        '__AbsentNamespace0_typeParametrageSimulation_affectation_reroutage_dstmax', typeFloatPositif,
        unicode_default='0')
    __affectation_reroutage_dstmax._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1002, 4)
    __affectation_reroutage_dstmax._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1002, 4)

    affectation_reroutage_dstmax = property(__affectation_reroutage_dstmax.value, __affectation_reroutage_dstmax.set,
                                            None,
                                            "Permet d'indiquer une distance minimale avant le point de choix pour la r\xe9affectation dynamique d'un v\xe9hicule (si cette distance avant le point de choix est d\xe9pass\xe9e, la reaffectation dynamique ne prendra pas en compte les itin\xe9raires dont le prochain tron\xe7on est diff\xe9rent du tron\xe7on pr\xe9c\xe9demment choisi apr\xe8s le point de choix)")


    # Attribute affectation_wardrop_tolerance uses Python identifier affectation_wardrop_tolerance
    __affectation_wardrop_tolerance = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_wardrop_tolerance'), 'affectation_wardrop_tolerance',
        '__AbsentNamespace0_typeParametrageSimulation_affectation_wardrop_tolerance', typeFloatPositif,
        unicode_default='0.01')
    __affectation_wardrop_tolerance._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1007, 4)
    __affectation_wardrop_tolerance._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1007, 4)

    affectation_wardrop_tolerance = property(__affectation_wardrop_tolerance.value, __affectation_wardrop_tolerance.set,
                                             None,
                                             'En mode wardrop, pourcentage utilis\xe9 pour d\xe9terminer les plus courts chemins retenus : ceux dont le co\xfbt est strictement inf\xe9rieur \xe0 (cout minimum) * (1 + affectation_wardrop_tolerance)')


    # Attribute affectation_alpha uses Python identifier affectation_alpha
    __affectation_alpha = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'affectation_alpha'),
                                                            'affectation_alpha',
                                                            '__AbsentNamespace0_typeParametrageSimulation_affectation_alpha',
                                                            typeFloatStrictPositif, unicode_default='0.05')
    __affectation_alpha._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1012, 4)
    __affectation_alpha._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1012, 4)

    affectation_alpha = property(__affectation_alpha.value, __affectation_alpha.set, None,
                                 'Pourcentage de p\xe9nalisation pour Dijkstra')


    # Attribute affectation_beta uses Python identifier affectation_beta
    __affectation_beta = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'affectation_beta'),
                                                           'affectation_beta',
                                                           '__AbsentNamespace0_typeParametrageSimulation_affectation_beta',
                                                           typeFloatStrictPositif, unicode_default='20')
    __affectation_beta._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1017, 4)
    __affectation_beta._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1017, 4)

    affectation_beta = property(__affectation_beta.value, __affectation_beta.set, None,
                                'Facteur multiplicatif de limitation du cout non p\xe9nalis\xe9')


    # Attribute affectation_gamma uses Python identifier affectation_gamma
    __affectation_gamma = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'affectation_gamma'),
                                                            'affectation_gamma',
                                                            '__AbsentNamespace0_typeParametrageSimulation_affectation_gamma',
                                                            typeFloatStrictPositif, unicode_default='20')
    __affectation_gamma._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1022, 4)
    __affectation_gamma._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1022, 4)

    affectation_gamma = property(__affectation_gamma.value, __affectation_gamma.set, None,
                                 'Facteur multiplicatif de limitation du cout p\xe9nalis\xe9')


    # Attribute affectation_commonality_filter uses Python identifier affectation_commonality_filter
    __affectation_commonality_filter = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_commonality_filter'), 'affectation_commonality_filter',
        '__AbsentNamespace0_typeParametrageSimulation_affectation_commonality_filter', pyxb.binding.datatypes.boolean,
        unicode_default='false')
    __affectation_commonality_filter._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1027, 4)
    __affectation_commonality_filter._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1027, 4)

    affectation_commonality_filter = property(__affectation_commonality_filter.value,
                                              __affectation_commonality_filter.set, None,
                                              'Active ou non le filtre des itin\xe9raires calcul\xe9s en fonction du commonality factor')


    # Attribute affectation_commonality_alpha uses Python identifier affectation_commonality_alpha
    __affectation_commonality_alpha = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_commonality_alpha'), 'affectation_commonality_alpha',
        '__AbsentNamespace0_typeParametrageSimulation_affectation_commonality_alpha', pyxb.binding.datatypes.float,
        unicode_default='0')
    __affectation_commonality_alpha._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1032, 4)
    __affectation_commonality_alpha._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1032, 4)

    affectation_commonality_alpha = property(__affectation_commonality_alpha.value, __affectation_commonality_alpha.set,
                                             None,
                                             "Valeur maximum du commonality factor admissible pour les itin\xe9raires calcul\xe9s par le module d'affectation")


    # Attribute affectation_commonality_beta uses Python identifier affectation_commonality_beta
    __affectation_commonality_beta = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_commonality_beta'), 'affectation_commonality_beta',
        '__AbsentNamespace0_typeParametrageSimulation_affectation_commonality_beta', typeFloat01, unicode_default='0.5')
    __affectation_commonality_beta._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1037, 4)
    __affectation_commonality_beta._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1037, 4)

    affectation_commonality_beta = property(__affectation_commonality_beta.value, __affectation_commonality_beta.set,
                                            None, 'Valeur du param\xe8tre beta pour le calcul du commonality factor')


    # Attribute affectation_commonality_gamma uses Python identifier affectation_commonality_gamma
    __affectation_commonality_gamma = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'affectation_commonality_gamma'), 'affectation_commonality_gamma',
        '__AbsentNamespace0_typeParametrageSimulation_affectation_commonality_gamma', typeFloat01, unicode_default='1')
    __affectation_commonality_gamma._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1042, 4)
    __affectation_commonality_gamma._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1042, 4)

    affectation_commonality_gamma = property(__affectation_commonality_gamma.value, __affectation_commonality_gamma.set,
                                             None, 'Valeur du param\xe8tre gamma pour le calcul du commonality factor')


    # Attribute EPSGinput uses Python identifier EPSGinput
    __EPSGinput = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'EPSGinput'), 'EPSGinput',
                                                    '__AbsentNamespace0_typeParametrageSimulation_EPSGinput',
                                                    pyxb.binding.datatypes.int, unicode_default='0')
    __EPSGinput._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1047, 4)
    __EPSGinput._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1047, 4)

    EPSGinput = property(__EPSGinput.value, __EPSGinput.set, None,
                         "Code EPSG du syst\xe8mes de coordonn\xe9es g\xe9or\xe9f\xe9renc\xe9es des donn\xe9es d'entr\xe9e\n(WGS84: 4326;\nLambert 93: 2154)\nSi ce code n'est pas d\xe9fini (ainsi que le code de restitution - attribut EPSGoutput), la restitution des r\xe9sultats s'effectuera sans transformation.\n")

    _ElementMap.update({
        __RESTITUTION.name(): __RESTITUTION,
        __ELEMENTS.name(): __ELEMENTS
    })
    _AttributeMap.update({
        __id.name(): __id,
        __pasdetemps.name(): __pasdetemps,
        __debut.name(): __debut,
        __fin.name(): __fin,
        __simulation_trafic.name(): __simulation_trafic,
        __simulation_acoustique.name(): __simulation_acoustique,
        __simulation_atmospherique.name(): __simulation_atmospherique,
        __type_sortieacoustique.name(): __type_sortieacoustique,
        __loipoursuite.name(): __loipoursuite,
        __comportementflux.name(): __comportementflux,
        __nombre_pluscourtchemin.name(): __nombre_pluscourtchemin,
        __offre_aval_convergent_deltaN.name(): __offre_aval_convergent_deltaN,
        __calcul_tq_convergent.name(): __calcul_tq_convergent,
        __date.name(): __date,
        __titre.name(): __titre,
        __proc_deceleration.name(): __proc_deceleration,
        __proc_dec_taux.name(): __proc_dec_taux,
        __seed.name(): __seed,
        __affectation.name(): __affectation,
        __periode_affectation.name(): __periode_affectation,
        __affectation_equilibre.name(): __affectation_equilibre,
        __affectation_type_temps_de_parcours.name(): __affectation_type_temps_de_parcours,
        __affectation_variation_temps_de_parcours.name(): __affectation_variation_temps_de_parcours,
        __affectation_nb_connexion_amont.name(): __affectation_nb_connexion_amont,
        __affectation_teta_logit.name(): __affectation_teta_logit,
        __affectation_mode.name(): __affectation_mode,
        __affectation_seuil_convergence.name(): __affectation_seuil_convergence,
        __affectation_nb_it_max.name(): __affectation_nb_it_max,
        __affectation_calculKSP.name(): __affectation_calculKSP,
        __affectation_seuil_tempsdeparcours.name(): __affectation_seuil_tempsdeparcours,
        __affectation_poids_max.name(): __affectation_poids_max,
        __resolution.name(): __resolution,
        __nb_cell_acoustique.name(): __nb_cell_acoustique,
        __longueur_cell_acoustique.name(): __longueur_cell_acoustique,
        __simulation_sirane.name(): __simulation_sirane,
        __nb_cell_sirane.name(): __nb_cell_sirane,
        __min_longueur_cell_sirane.name(): __min_longueur_cell_sirane,
        __periode_agregation_sirane.name(): __periode_agregation_sirane,
        __mode_zone_origine.name(): __mode_zone_origine,
        __mode_zone_destination.name(): __mode_zone_destination,
        __affectation_reroutage.name(): __affectation_reroutage,
        __affectation_reroutage_dstmax.name(): __affectation_reroutage_dstmax,
        __affectation_wardrop_tolerance.name(): __affectation_wardrop_tolerance,
        __affectation_alpha.name(): __affectation_alpha,
        __affectation_beta.name(): __affectation_beta,
        __affectation_gamma.name(): __affectation_gamma,
        __affectation_commonality_filter.name(): __affectation_commonality_filter,
        __affectation_commonality_alpha.name(): __affectation_commonality_alpha,
        __affectation_commonality_beta.name(): __affectation_commonality_beta,
        __affectation_commonality_gamma.name(): __affectation_commonality_gamma,
        __EPSGinput.name(): __EPSGinput
    })


Namespace.addCategoryObject('typeBinding', 'typeParametrageSimulation', typeParametrageSimulation)


# Complex type typeTypeDeVehicule with content type ELEMENT_ONLY
class typeTypeDeVehicule(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeTypeDeVehicule with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeTypeDeVehicule')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1358, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element ACCELERATION_PLAGES uses Python identifier ACCELERATION_PLAGES
    __ACCELERATION_PLAGES = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'ACCELERATION_PLAGES'), 'ACCELERATION_PLAGES',
        '__AbsentNamespace0_typeTypeDeVehicule_ACCELERATION_PLAGES', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1360, 6), )

    ACCELERATION_PLAGES = property(__ACCELERATION_PLAGES.value, __ACCELERATION_PLAGES.set, None,
                                   'Liste ordonn\xe9e des plages de l\'acc\xe9l\xe9ration en fonction de la vitesse dans le cas d\'une acc\xe9l\xe9ration non constante (ce noeud n\'est pas lu dans le cas o\xf9 la simulation a pour caract\xe9ristique "acc\xe9l\xe9ration non born\xe9e")')


    # Element SOURCES_ACOUSTIQUES uses Python identifier SOURCES_ACOUSTIQUES
    __SOURCES_ACOUSTIQUES = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'SOURCES_ACOUSTIQUES'), 'SOURCES_ACOUSTIQUES',
        '__AbsentNamespace0_typeTypeDeVehicule_SOURCES_ACOUSTIQUES', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1386, 6), )

    SOURCES_ACOUSTIQUES = property(__SOURCES_ACOUSTIQUES.value, __SOURCES_ACOUSTIQUES.set, None,
                                   'Liste des sources acoustiques du v\xe9hicule')


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeTypeDeVehicule_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1413, 4)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1413, 4)

    id = property(__id.value, __id.set, None, 'Identifiant du type de v\xe9hicule')


    # Attribute w uses Python identifier w
    __w = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'w'), 'w',
                                            '__AbsentNamespace0_typeTypeDeVehicule_w', typeFloatNegatif, required=True)
    __w._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1418, 4)
    __w._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1418, 4)

    w = property(__w.value, __w.set, None,
                 "W (en m/s, n\xe9gatif par convention) d'un v\xe9hicule de ce type. Si les attributs 'w_dispersion', 'w_min' et 'w_max' sont \xe9galement d\xe9finis, lors de la cr\xe9ation d'un v\xe9hicule de type, la valeur W sera calcul\xe9e \xe0 l'aide d'une distribution normale de moyenne 'w' et de dispersion 'w' (la plage [w_min, w_max] permet d'exclure les valeurs tir\xe9es en dehors de cette plage), sinon 'w' est la valeur constante de W des v\xe9hicules de ce type.")


    # Attribute w_dispersion uses Python identifier w_dispersion
    __w_dispersion = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'w_dispersion'),
                                                       'w_dispersion',
                                                       '__AbsentNamespace0_typeTypeDeVehicule_w_dispersion',
                                                       typeVitesses)
    __w_dispersion._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1423, 4)
    __w_dispersion._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1423, 4)

    w_dispersion = property(__w_dispersion.value, __w_dispersion.set, None,
                            "Valeur de dispersion de W dans le cas d'une distribution normale pour chaque v\xe9hicule cr\xe9\xe9. ATTENTION : la valeur doit \xeatre positive puisque c'est une dispersion")


    # Attribute w_min uses Python identifier w_min
    __w_min = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'w_min'), 'w_min',
                                                '__AbsentNamespace0_typeTypeDeVehicule_w_min', typeFloatNegatif)
    __w_min._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1428, 4)
    __w_min._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1428, 4)

    w_min = property(__w_min.value, __w_min.set, None,
                     'Borne inf\xe9rieure des valeurs issues de la distribution normale de W (si une valeur tir\xe9e est strictement inf\xe9rieure \xe0 cette borne, le tirage est r\xe9it\xe9r\xe9), cette valeur est n\xe9gative comme W')


    # Attribute w_max uses Python identifier w_max
    __w_max = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'w_max'), 'w_max',
                                                '__AbsentNamespace0_typeTypeDeVehicule_w_max', typeFloatNegatif)
    __w_max._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1433, 4)
    __w_max._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1433, 4)

    w_max = property(__w_max.value, __w_max.set, None,
                     'Borne sup\xe9rieure des valeurs issues de la distribution normale de W (si une valeur tir\xe9e est strictement sup\xe9rieure \xe0 cette borne, le tirage est r\xe9it\xe9r\xe9), cette valeur est n\xe9gative comme W')


    # Attribute kx uses Python identifier kx
    __kx = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'kx'), 'kx',
                                             '__AbsentNamespace0_typeTypeDeVehicule_kx', typeFloatStrictPositif,
                                             required=True)
    __kx._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1438, 4)
    __kx._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1438, 4)

    kx = property(__kx.value, __kx.set, None,
                  "Concentration max par voie (en veh/m). Si les attributs 'inv_kx_dispersion', 'kx_min' et 'kx_max' sont \xe9galement d\xe9finis, lors de la cr\xe9ation d'un v\xe9hicule de type, la concentration sera calcul\xe9e comme l'inverse d'une valeur issue d'une distribution normale de moyenne '1/kx' et de dispersion 'inv_kx_dispersion' (la plage [kx_min, kx_max] permet d'exclure les valeurs tir\xe9es en dehors de cette plage), sinon 'kx' est la concentration constante des v\xe9hicules de ce type.")


    # Attribute inv_kx_dispersion uses Python identifier inv_kx_dispersion
    __inv_kx_dispersion = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'inv_kx_dispersion'),
                                                            'inv_kx_dispersion',
                                                            '__AbsentNamespace0_typeTypeDeVehicule_inv_kx_dispersion',
                                                            typeFloatStrictPositif)
    __inv_kx_dispersion._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1443, 4)
    __inv_kx_dispersion._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1443, 4)

    inv_kx_dispersion = property(__inv_kx_dispersion.value, __inv_kx_dispersion.set, None,
                                 "Valeur de dispersion de l'inverse de la concentration dans le cas d'une distribution normale pour chaque v\xe9hicule cr\xe9\xe9")


    # Attribute kx_min uses Python identifier kx_min
    __kx_min = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'kx_min'), 'kx_min',
                                                 '__AbsentNamespace0_typeTypeDeVehicule_kx_min', typeFloatStrictPositif)
    __kx_min._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1448, 4)
    __kx_min._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1448, 4)

    kx_min = property(__kx_min.value, __kx_min.set, None,
                      'Borne inf\xe9rieure de concentration des inserves des valeurs issues de la distribution normale (si une valeur tir\xe9e est strictement inf\xe9rieure \xe0 cette borne, le tirage est r\xe9it\xe9r\xe9)')


    # Attribute kx_max uses Python identifier kx_max
    __kx_max = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'kx_max'), 'kx_max',
                                                 '__AbsentNamespace0_typeTypeDeVehicule_kx_max', typeFloatStrictPositif)
    __kx_max._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1453, 4)
    __kx_max._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1453, 4)

    kx_max = property(__kx_max.value, __kx_max.set, None,
                      'Borne sup\xe9rieure de concentration des inverses des valeurs issues de la distribution normale (si une valeur tir\xe9e est strictement sup\xe9rieure \xe0 cette borne, le tirage est r\xe9it\xe9r\xe9)')


    # Attribute vx uses Python identifier vx
    __vx = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'vx'), 'vx',
                                             '__AbsentNamespace0_typeTypeDeVehicule_vx', typeVitesses, required=True)
    __vx._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1458, 4)
    __vx._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1458, 4)

    vx = property(__vx.value, __vx.set, None,
                  "Vitesse libre (en m/s) d'un v\xe9hicule de ce type. Si les attributs 'vx_dispersion', 'vx_min' et 'vx_max' sont \xe9galement d\xe9finis, lors de la cr\xe9ation d'un v\xe9hicule de type, la vitesse libre sera calcul\xe9e \xe0 l'aide d'une distribution normale de moyenne 'vx' et de dispersion 'vx_dispersion' (la plage [vx_min, vx_max] permet d'exclure les valeurs tir\xe9es en dehors de cette plage), sinon 'vx' est la vitesse libre constante des v\xe9hicules de ce type.")


    # Attribute vx_dispersion uses Python identifier vx_dispersion
    __vx_dispersion = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'vx_dispersion'),
                                                        'vx_dispersion',
                                                        '__AbsentNamespace0_typeTypeDeVehicule_vx_dispersion',
                                                        typeVitesses)
    __vx_dispersion._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1463, 4)
    __vx_dispersion._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1463, 4)

    vx_dispersion = property(__vx_dispersion.value, __vx_dispersion.set, None,
                             "Valeur de dispersion de la vitesse libre dans le cas d'une distribution normale pour chaque v\xe9hicule cr\xe9\xe9")


    # Attribute vx_min uses Python identifier vx_min
    __vx_min = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'vx_min'), 'vx_min',
                                                 '__AbsentNamespace0_typeTypeDeVehicule_vx_min', typeVitesses)
    __vx_min._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1468, 4)
    __vx_min._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1468, 4)

    vx_min = property(__vx_min.value, __vx_min.set, None,
                      'Borne inf\xe9rieure des valeurs issues de la distribution normale de la vitesse libre (si une valeur tir\xe9e est strictement inf\xe9rieure \xe0 cette borne, le tirage est r\xe9it\xe9r\xe9)')


    # Attribute vx_max uses Python identifier vx_max
    __vx_max = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'vx_max'), 'vx_max',
                                                 '__AbsentNamespace0_typeTypeDeVehicule_vx_max', typeVitesses)
    __vx_max._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1473, 4)
    __vx_max._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1473, 4)

    vx_max = property(__vx_max.value, __vx_max.set, None,
                      'Borne sup\xe9rieure des valeurs issues de la distribution normale de la vitesse libre (si une valeur tir\xe9e est strictement sup\xe9rieure \xe0 cette borne, le tirage est r\xe9it\xe9r\xe9)')


    # Attribute ax uses Python identifier ax
    __ax = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'ax'), 'ax',
                                             '__AbsentNamespace0_typeTypeDeVehicule_ax', typeFloatStrictPositif,
                                             unicode_default='0.5')
    __ax._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1478, 4)
    __ax._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1478, 4)

    ax = property(__ax.value, __ax.set, None,
                  'Acc\xe9l\xe9ration maximale (en m/s2) dans le cas d\'une acc\xe9l\xe9ration constante quelle que soit la vitesse (cet attribut n\'est pas utilis\xe9 dans le cas o\xf9 la simulation a pour caract\xe9ristique "acc\xe9l\xe9ration non born\xe9e"')


    # Attribute deceleration uses Python identifier deceleration
    __deceleration = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'deceleration'),
                                                       'deceleration',
                                                       '__AbsentNamespace0_typeTypeDeVehicule_deceleration',
                                                       typeFloatStrictPositif)
    __deceleration._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1483, 4)
    __deceleration._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1483, 4)

    deceleration = property(__deceleration.value, __deceleration.set, None,
                            "D\xe9c\xe9l\xe9ration (en m/s2) du v\xe9hicule.\nPour un v\xe9hicule autre qu'un VGP, la d\xe9c\xe9l\xe9ration est mod\xe9lis\xe9e uniquement pour le premier v\xe9hicule \xe0 l'approche d'un feu rouge (ou orange). Pour un VGP, la d\xe9c\xe9l\xe9ration est mod\xe9lis\xe9e lors de la l'approche d'une feu rouge et d'un arr\xeat.\n")


    # Attribute deceleration_ecart_type uses Python identifier deceleration_ecart_type
    __deceleration_ecart_type = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'deceleration_ecart_type'), 'deceleration_ecart_type',
        '__AbsentNamespace0_typeTypeDeVehicule_deceleration_ecart_type', typeFloatPositif, unicode_default='0')
    __deceleration_ecart_type._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1490, 4)
    __deceleration_ecart_type._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1490, 4)

    deceleration_ecart_type = property(__deceleration_ecart_type.value, __deceleration_ecart_type.set, None,
                                       "Ecart type de de la d\xe9c\xe9l\xe9ration \xe0 un feu pour la d\xe9c\xe9l\xe9ration stochastique. Si la valeur est 0 (d\xe9faut) alors la d\xe9c\xe9l\xe9ration n'est pas stochastique.")


    # Attribute espacement_arret uses Python identifier espacement_arret
    __espacement_arret = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'espacement_arret'),
                                                           'espacement_arret',
                                                           '__AbsentNamespace0_typeTypeDeVehicule_espacement_arret',
                                                           typeFloatStrictPositif, unicode_default='1')
    __espacement_arret._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1495, 4)
    __espacement_arret._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1495, 4)

    espacement_arret = property(__espacement_arret.value, __espacement_arret.set, None,
                                "Longueur en m\xe8tre de l'espace vide laiss\xe9 par 2 v\xe9hicules successifs \xe0 l'arr\xeat (utilis\xe9 uniqement pour l'algorithme de travers\xe9e)")


    # Attribute agressivite uses Python identifier agressivite
    __agressivite = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'agressivite'), 'agressivite',
                                                      '__AbsentNamespace0_typeTypeDeVehicule_agressivite', typeFloat01,
                                                      unicode_default='1')
    __agressivite._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1500, 4)
    __agressivite._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1500, 4)

    agressivite = property(__agressivite.value, __agressivite.set, None,
                           "Valeur d'agressivit\xe9 du type de v\xe9hicule (limite inf\xe9rieure du delta N du v\xe9hicule avant adaptation de sa vitesse par rapport \xe0 son leader)")


    # Attribute pi_rabattement uses Python identifier pi_rabattement
    __pi_rabattement = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'pi_rabattement'),
                                                         'pi_rabattement',
                                                         '__AbsentNamespace0_typeTypeDeVehicule_pi_rabattement',
                                                         typeFloat01, unicode_default='0.2')
    __pi_rabattement._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1505, 4)
    __pi_rabattement._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1505, 4)

    pi_rabattement = property(__pi_rabattement.value, __pi_rabattement.set, None,
                              "Valeur de Pi dans le cas d'un rabattement vers la voie la plus \xe0 droite des v\xe9hicules ")


    # Attribute chgtvoie_tau uses Python identifier chgtvoie_tau
    __chgtvoie_tau = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'chgtvoie_tau'),
                                                       'chgtvoie_tau',
                                                       '__AbsentNamespace0_typeTypeDeVehicule_chgtvoie_tau',
                                                       typeFloatStrictPositif, unicode_default='4')
    __chgtvoie_tau._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1510, 4)
    __chgtvoie_tau._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1510, 4)

    chgtvoie_tau = property(__chgtvoie_tau.value, __chgtvoie_tau.set, None,
                            'Caract\xe9ristique Tau du changement de voie')


    # Attribute vitesse_laterale uses Python identifier vitesse_laterale
    __vitesse_laterale = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'vitesse_laterale'),
                                                           'vitesse_laterale',
                                                           '__AbsentNamespace0_typeTypeDeVehicule_vitesse_laterale',
                                                           typeFloatStrictPositif, unicode_default='10')
    __vitesse_laterale._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1515, 4)
    __vitesse_laterale._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1515, 4)

    vitesse_laterale = property(__vitesse_laterale.value, __vitesse_laterale.set, None,
                                "Vitesse de d\xe9placement lat\xe9rale (pour travers\xe9e de voies dans l'axe permendiculaire au tron\xe7on, en m/s)")


    # Attribute depassement_tau uses Python identifier depassement_tau
    __depassement_tau = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'depassement_tau'),
                                                          'depassement_tau',
                                                          '__AbsentNamespace0_typeTypeDeVehicule_depassement_tau',
                                                          pyxb.binding.datatypes.float, unicode_default='0.1')
    __depassement_tau._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1520, 4)
    __depassement_tau._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1520, 4)

    depassement_tau = property(__depassement_tau.value, __depassement_tau.set, None,
                               'Caract\xe9ristique Tau du d\xe9passement sur tron\xe7on oppos\xe9')


    # Attribute largeur uses Python identifier largeur
    __largeur = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'largeur'), 'largeur',
                                                  '__AbsentNamespace0_typeTypeDeVehicule_largeur',
                                                  typeFloatStrictPositif)
    __largeur._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1525, 4)
    __largeur._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1525, 4)

    largeur = property(__largeur.value, __largeur.set, None,
                       'largeur du v\xe9hicule. Utilis\xe9 pour la repr\xe9sentation des v\xe9hicules dans SymuPlayer.')


    # Attribute montee_descente_simultanee uses Python identifier montee_descente_simultanee
    __montee_descente_simultanee = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'montee_descente_simultanee'), 'montee_descente_simultanee',
        '__AbsentNamespace0_typeTypeDeVehicule_montee_descente_simultanee', pyxb.binding.datatypes.boolean,
        unicode_default='false')
    __montee_descente_simultanee._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1530, 4)
    __montee_descente_simultanee._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1530, 4)

    montee_descente_simultanee = property(__montee_descente_simultanee.value, __montee_descente_simultanee.set, None,
                                          'Indique si la mont\xe9e et la descente du v\xe9hicule sont possible en simultan\xe9 (utilis\xe9 pour les v\xe9hicules de type bus)')


    # Attribute temps_montee_individuelle uses Python identifier temps_montee_individuelle
    __temps_montee_individuelle = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'temps_montee_individuelle'), 'temps_montee_individuelle',
        '__AbsentNamespace0_typeTypeDeVehicule_temps_montee_individuelle', pyxb.binding.datatypes.nonNegativeInteger,
        unicode_default='1')
    __temps_montee_individuelle._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1535, 4)
    __temps_montee_individuelle._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1535, 4)

    temps_montee_individuelle = property(__temps_montee_individuelle.value, __temps_montee_individuelle.set, None,
                                         'Temps de mont\xe9e individuelle dans le bus (en s). Permet de calculer dynamiquement le temps des arr\xeats')

    _ElementMap.update({
        __ACCELERATION_PLAGES.name(): __ACCELERATION_PLAGES,
        __SOURCES_ACOUSTIQUES.name(): __SOURCES_ACOUSTIQUES
    })
    _AttributeMap.update({
        __id.name(): __id,
        __w.name(): __w,
        __w_dispersion.name(): __w_dispersion,
        __w_min.name(): __w_min,
        __w_max.name(): __w_max,
        __kx.name(): __kx,
        __inv_kx_dispersion.name(): __inv_kx_dispersion,
        __kx_min.name(): __kx_min,
        __kx_max.name(): __kx_max,
        __vx.name(): __vx,
        __vx_dispersion.name(): __vx_dispersion,
        __vx_min.name(): __vx_min,
        __vx_max.name(): __vx_max,
        __ax.name(): __ax,
        __deceleration.name(): __deceleration,
        __deceleration_ecart_type.name(): __deceleration_ecart_type,
        __espacement_arret.name(): __espacement_arret,
        __agressivite.name(): __agressivite,
        __pi_rabattement.name(): __pi_rabattement,
        __chgtvoie_tau.name(): __chgtvoie_tau,
        __vitesse_laterale.name(): __vitesse_laterale,
        __depassement_tau.name(): __depassement_tau,
        __largeur.name(): __largeur,
        __montee_descente_simultanee.name(): __montee_descente_simultanee,
        __temps_montee_individuelle.name(): __temps_montee_individuelle
    })


Namespace.addCategoryObject('typeBinding', 'typeTypeDeVehicule', typeTypeDeVehicule)


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_163(pyxb.binding.basis.complexTypeDefinition):
    """Description d'une plage d'accÃ©lÃ©ration"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1370, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute ax uses Python identifier ax
    __ax = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'ax'), 'ax',
                                             '__AbsentNamespace0_CTD_ANON_163_ax', typeFloatStrictPositif,
                                             required=True)
    __ax._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1371, 16)
    __ax._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1371, 16)

    ax = property(__ax.value, __ax.set, None, 'Acc\xe9l\xe9ration en m/s2')


    # Attribute vit_sup uses Python identifier vit_sup
    __vit_sup = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'vit_sup'), 'vit_sup',
                                                  '__AbsentNamespace0_CTD_ANON_163_vit_sup', typeVitMax, required=True)
    __vit_sup._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1376, 16)
    __vit_sup._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1376, 16)

    vit_sup = property(__vit_sup.value, __vit_sup.set, None,
                       "Vitesse (en m/s) de la borne sup\xe9rieure de validit\xe9 de l'acc\xe9l\xe9ration")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __ax.name(): __ax,
        __vit_sup.name(): __vit_sup
    })


# Complex type typeTroncon with content type ELEMENT_ONLY
class typeTroncon(pyxb.binding.basis.complexTypeDefinition):
    """Complex type typeTroncon with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeTroncon')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1599, 2)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element VOIES_REDUITES uses Python identifier VOIES_REDUITES
    __VOIES_REDUITES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VOIES_REDUITES'),
                                                               'VOIES_REDUITES',
                                                               '__AbsentNamespace0_typeTroncon_VOIES_REDUITES', False,
                                                               pyxb.utils.utility.Location(
                                                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                   1601, 6), )

    VOIES_REDUITES = property(__VOIES_REDUITES.value, __VOIES_REDUITES.set, None,
                              'Liste des voies r\xe9duites pour les tron\xe7ons microscopiques(Symubruit force le changement de voie avant la fin du tron\xe7on pour de telles voies)')


    # Element VITESSES_REG uses Python identifier VITESSES_REG
    __VITESSES_REG = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VITESSES_REG'),
                                                             'VITESSES_REG',
                                                             '__AbsentNamespace0_typeTroncon_VITESSES_REG', False,
                                                             pyxb.utils.utility.Location(
                                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                 1632, 6), )

    VITESSES_REG = property(__VITESSES_REG.value, __VITESSES_REG.set, None,
                            "Liste des vitesses r\xe9glementaires sp\xe9cifiques \xe0 un type de v\xe9hicule (\xe0 d\xe9finir uniquement dans le cas d'un tron\xe7on microscopique et lorsque la vitesse r\xe9glementaire n'est pas commune \xe0 tous les types de v\xe9hicules)")


    # Element POINTS_INTERNES uses Python identifier POINTS_INTERNES
    __POINTS_INTERNES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'POINTS_INTERNES'),
                                                                'POINTS_INTERNES',
                                                                '__AbsentNamespace0_typeTroncon_POINTS_INTERNES', False,
                                                                pyxb.utils.utility.Location(
                                                                    '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                    1699, 6), )

    POINTS_INTERNES = property(__POINTS_INTERNES.value, __POINTS_INTERNES.set, None,
                               "\n            Description de la liste des points internes d\xe9crivant le tron\xe7on (ils doivent \xeatre d\xe9finis de l'amont vers l'aval)\n          ")


    # Element TRAVERSEES uses Python identifier TRAVERSEES
    __TRAVERSEES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRAVERSEES'),
                                                           'TRAVERSEES', '__AbsentNamespace0_typeTroncon_TRAVERSEES',
                                                           False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1706, 6), )

    TRAVERSEES = property(__TRAVERSEES.value, __TRAVERSEES.set, None,
                          'Liste des travers\xe9es prioritaires pour les tron\xe7ons microscopiques')


    # Element VOIES_RESERVEES uses Python identifier VOIES_RESERVEES
    __VOIES_RESERVEES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VOIES_RESERVEES'),
                                                                'VOIES_RESERVEES',
                                                                '__AbsentNamespace0_typeTroncon_VOIES_RESERVEES', False,
                                                                pyxb.utils.utility.Location(
                                                                    '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                    1755, 6), )

    VOIES_RESERVEES = property(__VOIES_RESERVEES.value, __VOIES_RESERVEES.set, None,
                               'D\xe9finition des voies r\xe9serv\xe9es sur ce tron\xe7on')


    # Element VOIES_INTERDITES uses Python identifier VOIES_INTERDITES
    __VOIES_INTERDITES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'VOIES_INTERDITES'),
                                                                 'VOIES_INTERDITES',
                                                                 '__AbsentNamespace0_typeTroncon_VOIES_INTERDITES',
                                                                 False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1796, 6), )

    VOIES_INTERDITES = property(__VOIES_INTERDITES.value, __VOIES_INTERDITES.set, None,
                                'D\xe9finition des voies interdites sur le tron\xe7on')


    # Element TERRE_PLEINS uses Python identifier TERRE_PLEINS
    __TERRE_PLEINS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TERRE_PLEINS'),
                                                             'TERRE_PLEINS',
                                                             '__AbsentNamespace0_typeTroncon_TERRE_PLEINS', False,
                                                             pyxb.utils.utility.Location(
                                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                 1819, 6), )

    TERRE_PLEINS = property(__TERRE_PLEINS.value, __TERRE_PLEINS.set, None,
                            'Ensemble des terre-pleins pr\xe9sents sur le tron\xe7on')


    # Element ZONES_DEPASSEMENT_INTERDIT uses Python identifier ZONES_DEPASSEMENT_INTERDIT
    __ZONES_DEPASSEMENT_INTERDIT = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'ZONES_DEPASSEMENT_INTERDIT'), 'ZONES_DEPASSEMENT_INTERDIT',
        '__AbsentNamespace0_typeTroncon_ZONES_DEPASSEMENT_INTERDIT', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1869, 6), )

    ZONES_DEPASSEMENT_INTERDIT = property(__ZONES_DEPASSEMENT_INTERDIT.value, __ZONES_DEPASSEMENT_INTERDIT.set, None,
                                          'Ensemble des zones dans lesquelles le d\xe9passement par passage sur la voie de gauche du tron\xe7on oppos\xe9 est interdit ')


    # Element ZONES_EXCLUSION uses Python identifier ZONES_EXCLUSION
    __ZONES_EXCLUSION = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ZONES_EXCLUSION'),
                                                                'ZONES_EXCLUSION',
                                                                '__AbsentNamespace0_typeTroncon_ZONES_EXCLUSION', False,
                                                                pyxb.utils.utility.Location(
                                                                    '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                    1895, 6), )

    ZONES_EXCLUSION = property(__ZONES_EXCLUSION.value, __ZONES_EXCLUSION.set, None,
                               'Ensemble des zones dans lesquelles le trafic ne doit pas \xeatre pris en compte. A exploiter au niveau des outils de post-traitement.')


    # Element Z_LEVEL_CROSSINGS uses Python identifier Z_LEVEL_CROSSINGS
    __Z_LEVEL_CROSSINGS = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'Z_LEVEL_CROSSINGS'), 'Z_LEVEL_CROSSINGS',
        '__AbsentNamespace0_typeTroncon_Z_LEVEL_CROSSINGS', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1921, 6), )

    Z_LEVEL_CROSSINGS = property(__Z_LEVEL_CROSSINGS.value, __Z_LEVEL_CROSSINGS.set, None,
                                 'D\xe9finition des portions du tron\xe7on pour lesquellse on d\xe9finit un zLevel particulier')


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeTroncon_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1952, 4)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1952, 4)

    id = property(__id.value, __id.set, None, 'Identifiant du tron\xe7on')


    # Attribute nom_axe uses Python identifier nom_axe
    __nom_axe = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'nom_axe'), 'nom_axe',
                                                  '__AbsentNamespace0_typeTroncon_nom_axe',
                                                  pyxb.binding.datatypes.string)
    __nom_axe._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1957, 4)
    __nom_axe._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1957, 4)

    nom_axe = property(__nom_axe.value, __nom_axe.set, None, "Nom de l'axe dont le tron\xe7on fait partie")


    # Attribute id_eltamont uses Python identifier id_eltamont
    __id_eltamont = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_eltamont'), 'id_eltamont',
                                                      '__AbsentNamespace0_typeTroncon_id_eltamont',
                                                      pyxb.binding.datatypes.string, required=True)
    __id_eltamont._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1962, 4)
    __id_eltamont._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1962, 4)

    id_eltamont = property(__id_eltamont.value, __id_eltamont.set, None, "Identifiant de l'\xe9l\xe9ment amont")


    # Attribute id_eltaval uses Python identifier id_eltaval
    __id_eltaval = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_eltaval'), 'id_eltaval',
                                                     '__AbsentNamespace0_typeTroncon_id_eltaval',
                                                     pyxb.binding.datatypes.string, required=True)
    __id_eltaval._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1967, 4)
    __id_eltaval._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1967, 4)

    id_eltaval = property(__id_eltaval.value, __id_eltaval.set, None, "Identifiant de l'\xe9l\xe9ment aval")


    # Attribute extremite_amont uses Python identifier extremite_amont
    __extremite_amont = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'extremite_amont'),
                                                          'extremite_amont',
                                                          '__AbsentNamespace0_typeTroncon_extremite_amont',
                                                          typeCoordonnees, required=True)
    __extremite_amont._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1972, 4)
    __extremite_amont._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1972, 4)

    extremite_amont = property(__extremite_amont.value, __extremite_amont.set, None,
                               "Coordonn\xe9es de l'extr\xe9mit\xe9 amont du tron\xe7on")


    # Attribute extremite_aval uses Python identifier extremite_aval
    __extremite_aval = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'extremite_aval'),
                                                         'extremite_aval',
                                                         '__AbsentNamespace0_typeTroncon_extremite_aval',
                                                         typeCoordonnees, required=True)
    __extremite_aval._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1977, 4)
    __extremite_aval._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1977, 4)

    extremite_aval = property(__extremite_aval.value, __extremite_aval.set, None,
                              "Coordonn\xe9es de l'extr\xe9mit\xe9 aval du tron\xe7on")


    # Attribute longueur uses Python identifier longueur
    __longueur = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'longueur'), 'longueur',
                                                   '__AbsentNamespace0_typeTroncon_longueur', typeFloatPositif,
                                                   unicode_default='0')
    __longueur._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1982, 4)
    __longueur._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1982, 4)

    longueur = property(__longueur.value, __longueur.set, None,
                        "Longueur en m\xe8tre du tron\xe7on dans le cas d'un tron\xe7on curviligne")


    # Attribute revetement uses Python identifier revetement
    __revetement = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'revetement'), 'revetement',
                                                     '__AbsentNamespace0_typeTroncon_revetement',
                                                     pyxb.binding.datatypes.string)
    __revetement._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1987, 4)
    __revetement._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1987, 4)

    revetement = property(__revetement.value, __revetement.set, None,
                          'Nom du rev\xeatement (notion utilis\xe9e uniquement lors du calcul acoustique). ')


    # Attribute nb_voie uses Python identifier nb_voie
    __nb_voie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'nb_voie'), 'nb_voie',
                                                  '__AbsentNamespace0_typeTroncon_nb_voie', typeIntStrictPositif,
                                                  unicode_default='1')
    __nb_voie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1992, 4)
    __nb_voie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1992, 4)

    nb_voie = property(__nb_voie.value, __nb_voie.set, None, 'Nombre de voie du tron\xe7on')


    # Attribute largeur_voie uses Python identifier largeur_voie
    __largeur_voie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'largeur_voie'),
                                                       'largeur_voie', '__AbsentNamespace0_typeTroncon_largeur_voie',
                                                       typeFloatStrictPositif, required=True)
    __largeur_voie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1997, 4)
    __largeur_voie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1997, 4)

    largeur_voie = property(__largeur_voie.value, __largeur_voie.set, None, "Largeur d'une voie (en m)")


    # Attribute vit_reg uses Python identifier vit_reg
    __vit_reg = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'vit_reg'), 'vit_reg',
                                                  '__AbsentNamespace0_typeTroncon_vit_reg', typeFloatStrictPositif)
    __vit_reg._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2002, 4)
    __vit_reg._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2002, 4)

    vit_reg = property(__vit_reg.value, __vit_reg.set, None,
                       "Vitesse r\xe9glementaire du tron\xe7on (en m/s) (dans le cas d'un tron\xe7on macroscopique, cette vitesse est unique et d\xe9finie pour le type de v\xe9hicule de base, dans le cas d'un tron\xe7on microscopique, elle sera utilis\xe9e pour les types de v\xe9hicule dont la vitesse r\xe9glementaire n'est pas sp\xe9cifi\xe9e dans la liste VITESSES_REG) ")


    # Attribute chgt_voie_droite uses Python identifier chgt_voie_droite
    __chgt_voie_droite = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'chgt_voie_droite'),
                                                           'chgt_voie_droite',
                                                           '__AbsentNamespace0_typeTroncon_chgt_voie_droite',
                                                           pyxb.binding.datatypes.boolean, unicode_default='true')
    __chgt_voie_droite._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2007, 4)
    __chgt_voie_droite._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2007, 4)

    chgt_voie_droite = property(__chgt_voie_droite.value, __chgt_voie_droite.set, None,
                                'Indique si le changement de voie vers la voie la plus \xe0 droite est autoris\xe9 (oui par d\xe9faut)')


    # Attribute chgtvoie_dstfin uses Python identifier chgtvoie_dstfin
    __chgtvoie_dstfin = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'chgtvoie_dstfin'),
                                                          'chgtvoie_dstfin',
                                                          '__AbsentNamespace0_typeTroncon_chgtvoie_dstfin',
                                                          pyxb.binding.datatypes.float)
    __chgtvoie_dstfin._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2012, 4)
    __chgtvoie_dstfin._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2012, 4)

    chgtvoie_dstfin = property(__chgtvoie_dstfin.value, __chgtvoie_dstfin.set, None,
                               "Distance avant la fin du tron\xe7on pour forcer un changement de voie d'un v\xe9hicule si il ne se trouve pas sur la bonne voie pour prendre la prochaine direction (en m\xe8tres)")


    # Attribute id_troncon_oppose uses Python identifier id_troncon_oppose
    __id_troncon_oppose = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_troncon_oppose'),
                                                            'id_troncon_oppose',
                                                            '__AbsentNamespace0_typeTroncon_id_troncon_oppose',
                                                            pyxb.binding.datatypes.string)
    __id_troncon_oppose._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2017, 4)
    __id_troncon_oppose._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2017, 4)

    id_troncon_oppose = property(__id_troncon_oppose.value, __id_troncon_oppose.set, None,
                                 'Identifiant du tron\xe7on oppos\xe9 associ\xe9')


    # Attribute exclusion_types_vehicules uses Python identifier exclusion_types_vehicules
    __exclusion_types_vehicules = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'exclusion_types_vehicules'), 'exclusion_types_vehicules',
        '__AbsentNamespace0_typeTroncon_exclusion_types_vehicules', pyxb.binding.datatypes.string)
    __exclusion_types_vehicules._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2022, 4)
    __exclusion_types_vehicules._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2022, 4)

    exclusion_types_vehicules = property(__exclusion_types_vehicules.value, __exclusion_types_vehicules.set, None,
                                         'Liste des identifiants des types de v\xe9hicule pour lesquels le tron\xe7on est interdit')

    _ElementMap.update({
        __VOIES_REDUITES.name(): __VOIES_REDUITES,
        __VITESSES_REG.name(): __VITESSES_REG,
        __POINTS_INTERNES.name(): __POINTS_INTERNES,
        __TRAVERSEES.name(): __TRAVERSEES,
        __VOIES_RESERVEES.name(): __VOIES_RESERVEES,
        __VOIES_INTERDITES.name(): __VOIES_INTERDITES,
        __TERRE_PLEINS.name(): __TERRE_PLEINS,
        __ZONES_DEPASSEMENT_INTERDIT.name(): __ZONES_DEPASSEMENT_INTERDIT,
        __ZONES_EXCLUSION.name(): __ZONES_EXCLUSION,
        __Z_LEVEL_CROSSINGS.name(): __Z_LEVEL_CROSSINGS
    })
    _AttributeMap.update({
        __id.name(): __id,
        __nom_axe.name(): __nom_axe,
        __id_eltamont.name(): __id_eltamont,
        __id_eltaval.name(): __id_eltaval,
        __extremite_amont.name(): __extremite_amont,
        __extremite_aval.name(): __extremite_aval,
        __longueur.name(): __longueur,
        __revetement.name(): __revetement,
        __nb_voie.name(): __nb_voie,
        __largeur_voie.name(): __largeur_voie,
        __vit_reg.name(): __vit_reg,
        __chgt_voie_droite.name(): __chgt_voie_droite,
        __chgtvoie_dstfin.name(): __chgtvoie_dstfin,
        __id_troncon_oppose.name(): __id_troncon_oppose,
        __exclusion_types_vehicules.name(): __exclusion_types_vehicules
    })


Namespace.addCategoryObject('typeBinding', 'typeTroncon', typeTroncon)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_164(pyxb.binding.basis.complexTypeDefinition):
    """CaractÃ©ristiques d'un tronÃ§on de l'anneau du giratoire"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2151, 18)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element POINTS_INTERNES uses Python identifier POINTS_INTERNES
    __POINTS_INTERNES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'POINTS_INTERNES'),
                                                                'POINTS_INTERNES',
                                                                '__AbsentNamespace0_CTD_ANON_164_POINTS_INTERNES',
                                                                False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2153, 22), )

    POINTS_INTERNES = property(__POINTS_INTERNES.value, __POINTS_INTERNES.set, None,
                               '\n\t\t\t\t\t\t\tListe des points internes du tron\xe7on\n\t\t\t\t\t\t')


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_164_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2162, 20)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2162, 20)

    id = property(__id.value, __id.set, None, 'Identifiant du tron\xe7on interne')


    # Attribute troncon_amont uses Python identifier troncon_amont
    __troncon_amont = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'troncon_amont'),
                                                        'troncon_amont',
                                                        '__AbsentNamespace0_CTD_ANON_164_troncon_amont',
                                                        pyxb.binding.datatypes.string, required=True)
    __troncon_amont._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2167, 20)
    __troncon_amont._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2167, 20)

    troncon_amont = property(__troncon_amont.value, __troncon_amont.set, None,
                             "Identifiant du tron\xe7on d\xe9finissant l'extr\xe9mit\xe9 amont")


    # Attribute troncon_aval uses Python identifier troncon_aval
    __troncon_aval = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'troncon_aval'),
                                                       'troncon_aval', '__AbsentNamespace0_CTD_ANON_164_troncon_aval',
                                                       pyxb.binding.datatypes.string, required=True)
    __troncon_aval._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2172, 20)
    __troncon_aval._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2172, 20)

    troncon_aval = property(__troncon_aval.value, __troncon_aval.set, None,
                            "Identifiant du tron\xe7on d\xe9finissant l'extr\xe9mit\xe9 aval")


    # Attribute longueur uses Python identifier longueur
    __longueur = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'longueur'), 'longueur',
                                                   '__AbsentNamespace0_CTD_ANON_164_longueur', typeFloatPositif,
                                                   unicode_default='0')
    __longueur._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2177, 20)
    __longueur._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2177, 20)

    longueur = property(__longueur.value, __longueur.set, None,
                        "Longueur en m\xe8tre du tron\xe7on interne dans le cas d'un tron\xe7on curviligne")


    # Attribute extremite_amont uses Python identifier extremite_amont
    __extremite_amont = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'extremite_amont'),
                                                          'extremite_amont',
                                                          '__AbsentNamespace0_CTD_ANON_164_extremite_amont',
                                                          typeCoordonnees, required=True)
    __extremite_amont._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2183, 20)
    __extremite_amont._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2183, 20)

    extremite_amont = property(__extremite_amont.value, __extremite_amont.set, None,
                               "Coordonn\xe9es de l'extr\xe9mit\xe9 amont du tron\xe7on interne")


    # Attribute extremite_aval uses Python identifier extremite_aval
    __extremite_aval = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'extremite_aval'),
                                                         'extremite_aval',
                                                         '__AbsentNamespace0_CTD_ANON_164_extremite_aval',
                                                         typeCoordonnees, required=True)
    __extremite_aval._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2188, 20)
    __extremite_aval._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2188, 20)

    extremite_aval = property(__extremite_aval.value, __extremite_aval.set, None,
                              "Coordonn\xe9es de l'extr\xe9mit\xe9 aval du tron\xe7on interne")

    _ElementMap.update({
        __POINTS_INTERNES.name(): __POINTS_INTERNES
    })
    _AttributeMap.update({
        __id.name(): __id,
        __troncon_amont.name(): __troncon_amont,
        __troncon_aval.name(): __troncon_aval,
        __longueur.name(): __longueur,
        __extremite_amont.name(): __extremite_amont,
        __extremite_aval.name(): __extremite_aval
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_165(pyxb.binding.basis.complexTypeDefinition):
    """Description d'un divergent d'une branche d'entrÃ©e"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2319, 30)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element POINTS_INTERNES uses Python identifier POINTS_INTERNES
    __POINTS_INTERNES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'POINTS_INTERNES'),
                                                                'POINTS_INTERNES',
                                                                '__AbsentNamespace0_CTD_ANON_165_POINTS_INTERNES',
                                                                False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2321, 34), )

    POINTS_INTERNES = property(__POINTS_INTERNES.value, __POINTS_INTERNES.set, None,
                               "Liste des points internes se situant entre le pr\xe9c\xe9dent divergent d\xe9fini et celui-ci (si c'est le premier divergent d\xe9fini, c'est entre l'extr\xe9mit\xe9 aval du tron\xe7on d'entr\xe9e et celui-ci)")


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_165_id', STD_ANON_20, required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2328, 32)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2328, 32)

    id = property(__id.value, __id.set, None,
                  "Identifiant du divergent (celui-ci va permettre pour chaque mouvement d'identifier son point de divergence sur la branche principale de l'entr\xe9e)")


    # Attribute coord uses Python identifier coord
    __coord = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'coord'), 'coord',
                                                '__AbsentNamespace0_CTD_ANON_165_coord', typeCoordonnees, required=True)
    __coord._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2338, 32)
    __coord._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2338, 32)

    coord = property(__coord.value, __coord.set, None, 'Coordonn\xe9es du point de divergence')

    _ElementMap.update({
        __POINTS_INTERNES.name(): __POINTS_INTERNES
    })
    _AttributeMap.update({
        __id.name(): __id,
        __coord.name(): __coord
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_166(pyxb.binding.basis.complexTypeDefinition):
    """Description d'un divergent d'un tronÃ§on d'entrÃ©e"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2502, 30)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element POINTS_INTERNES uses Python identifier POINTS_INTERNES
    __POINTS_INTERNES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'POINTS_INTERNES'),
                                                                'POINTS_INTERNES',
                                                                '__AbsentNamespace0_CTD_ANON_166_POINTS_INTERNES',
                                                                False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2504, 34), )

    POINTS_INTERNES = property(__POINTS_INTERNES.value, __POINTS_INTERNES.set, None,
                               "Liste des points internes se situant entre le pr\xe9c\xe9dent convergent d\xe9fini et celui-ci (si c'est le premier convergent d\xe9fini, c'est entre l'extr\xe9mit\xe9 amont du tron\xe7on de sortie et celui-ci)")


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_166_id', STD_ANON_24, required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2511, 32)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2511, 32)

    id = property(__id.value, __id.set, None,
                  "Identifiant du convergent (celui-ci va permettre pour chaque mouvement d'identifier son point de divergence sur la branche principale de l'entr\xe9e)")


    # Attribute coord uses Python identifier coord
    __coord = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'coord'), 'coord',
                                                '__AbsentNamespace0_CTD_ANON_166_coord', typeCoordonnees, required=True)
    __coord._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2521, 32)
    __coord._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2521, 32)

    coord = property(__coord.value, __coord.set, None, 'Coordonn\xe9es du point de convergence')

    _ElementMap.update({
        __POINTS_INTERNES.name(): __POINTS_INTERNES
    })
    _AttributeMap.update({
        __id.name(): __id,
        __coord.name(): __coord
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_167(pyxb.binding.basis.complexTypeDefinition):
    """Description d'un arrÃªt"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2713, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element PARAMETRAGE_MONTEE uses Python identifier PARAMETRAGE_MONTEE
    __PARAMETRAGE_MONTEE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'PARAMETRAGE_MONTEE'), 'PARAMETRAGE_MONTEE',
        '__AbsentNamespace0_CTD_ANON_167_PARAMETRAGE_MONTEE', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2715, 18), )

    PARAMETRAGE_MONTEE = property(__PARAMETRAGE_MONTEE.value, __PARAMETRAGE_MONTEE.set, None,
                                  "Liste des variantes temporelles de d\xe9finition du profil des demandes pour l'arr\xeat")


    # Element PARAMETRAGE_DESCENTE uses Python identifier PARAMETRAGE_DESCENTE
    __PARAMETRAGE_DESCENTE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'PARAMETRAGE_DESCENTE'), 'PARAMETRAGE_DESCENTE',
        '__AbsentNamespace0_CTD_ANON_167_PARAMETRAGE_DESCENTE', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2762, 18), )

    PARAMETRAGE_DESCENTE = property(__PARAMETRAGE_DESCENTE.value, __PARAMETRAGE_DESCENTE.set, None,
                                    "D\xe9finition des param\xe8tres de descente des bus pour l'arr\xeat consid\xe9r\xe9")


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_167_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2790, 16)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2790, 16)

    id = property(__id.value, __id.set, None, "Identifiant de l'arr\xeat")


    # Attribute troncon uses Python identifier troncon
    __troncon = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'troncon'), 'troncon',
                                                  '__AbsentNamespace0_CTD_ANON_167_troncon',
                                                  pyxb.binding.datatypes.string, required=True)
    __troncon._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2795, 16)
    __troncon._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2795, 16)

    troncon = property(__troncon.value, __troncon.set, None, "Tron\xe7on sur lequel est positionn\xe9 l'arr\xeat")


    # Attribute position uses Python identifier position
    __position = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position'), 'position',
                                                   '__AbsentNamespace0_CTD_ANON_167_position', typeFloatPositif,
                                                   required=True)
    __position._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2800, 16)
    __position._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2800, 16)

    position = property(__position.value, __position.set, None,
                        "Position de l'arr\xeat sur le tron\xe7on (en m ou en % de la longueur du tron\xe7on si position_relative vaut true)")


    # Attribute position_relative uses Python identifier position_relative
    __position_relative = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'position_relative'),
                                                            'position_relative',
                                                            '__AbsentNamespace0_CTD_ANON_167_position_relative',
                                                            pyxb.binding.datatypes.boolean, unicode_default='false')
    __position_relative._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2805, 16)
    __position_relative._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2805, 16)

    position_relative = property(__position_relative.value, __position_relative.set, None,
                                 "Indique que la position de l'arr\xeat est exprim\xe9e en pourcentage de la longueur du tron\xe7on sur lequel est positionn\xe9 l'arr\xeat.")


    # Attribute dureearret uses Python identifier dureearret
    __dureearret = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'dureearret'), 'dureearret',
                                                     '__AbsentNamespace0_CTD_ANON_167_dureearret',
                                                     pyxb.binding.datatypes.nonNegativeInteger)
    __dureearret._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2811, 16)
    __dureearret._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2811, 16)

    dureearret = property(__dureearret.value, __dureearret.set, None,
                          "Dur\xe9e de l'arr\xeat (en s) dans le cas d'un param\xe9trage de type global")


    # Attribute pleinevoie uses Python identifier pleinevoie
    __pleinevoie = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'pleinevoie'), 'pleinevoie',
                                                     '__AbsentNamespace0_CTD_ANON_167_pleinevoie',
                                                     pyxb.binding.datatypes.boolean, unicode_default='true')
    __pleinevoie._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2816, 16)
    __pleinevoie._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2816, 16)

    pleinevoie = property(__pleinevoie.value, __pleinevoie.set, None,
                          "Indique si le v\xe9hicule guid\xe9 s'arr\xeate sur la voie ou en dehors ")


    # Attribute lignes uses Python identifier lignes
    __lignes = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'lignes'), 'lignes',
                                                 '__AbsentNamespace0_CTD_ANON_167_lignes', STD_ANON_48, required=True)
    __lignes._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2821, 16)
    __lignes._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2821, 16)

    lignes = property(__lignes.value, __lignes.set, None,
                      "Liste des lignes de transport guid\xe9e s'arr\xeatant \xe0 cet arr\xeat")


    # Attribute num_voies uses Python identifier num_voies
    __num_voies = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'num_voies'), 'num_voies',
                                                    '__AbsentNamespace0_CTD_ANON_167_num_voies', STD_ANON_49)
    __num_voies._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2833, 16)
    __num_voies._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2833, 16)

    num_voies = property(__num_voies.value, __num_voies.set, None,
                         'Liste des num\xe9ros de voie sur lesquelles se trouve l\'arr\xeat pour chacune des lignes concern\xe9es par l\'arr\xeat. Le nombre de num\xe9ros de voie doit \xeatre \xe9gal au nombre de lignes passant par cet arr\xeat et d\xe9finies dans l\'attribut "lignes"')

    _ElementMap.update({
        __PARAMETRAGE_MONTEE.name(): __PARAMETRAGE_MONTEE,
        __PARAMETRAGE_DESCENTE.name(): __PARAMETRAGE_DESCENTE
    })
    _AttributeMap.update({
        __id.name(): __id,
        __troncon.name(): __troncon,
        __position.name(): __position,
        __position_relative.name(): __position_relative,
        __dureearret.name(): __dureearret,
        __pleinevoie.name(): __pleinevoie,
        __lignes.name(): __lignes,
        __num_voies.name(): __num_voies
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_168(pyxb.binding.basis.complexTypeDefinition):
    """"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3066, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute lignes uses Python identifier lignes
    __lignes = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'lignes'), 'lignes',
                                                 '__AbsentNamespace0_CTD_ANON_168_lignes', STD_ANON_50, required=True)
    __lignes._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3067, 16)
    __lignes._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3067, 16)

    lignes = property(__lignes.value, __lignes.set, None,
                      'Liste des lignes de transport guid\xe9es circulant sur cette ligne prioritaire')


    # Attribute troncon_capteur_amont uses Python identifier troncon_capteur_amont
    __troncon_capteur_amont = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'troncon_capteur_amont'), 'troncon_capteur_amont',
        '__AbsentNamespace0_CTD_ANON_168_troncon_capteur_amont', pyxb.binding.datatypes.string, required=True)
    __troncon_capteur_amont._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3079, 16)
    __troncon_capteur_amont._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3079, 16)

    troncon_capteur_amont = property(__troncon_capteur_amont.value, __troncon_capteur_amont.set, None,
                                     "Identifiant du tron\xe7on sur lequel se trouve le capteur amont de la ligne prioritaire (ce capteur permet de d\xe9tecter l'arriv\xe9e d'un v\xe9hicule prioritaire au contr\xf4leur de feux)")


    # Attribute position_capteur_amont uses Python identifier position_capteur_amont
    __position_capteur_amont = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'position_capteur_amont'), 'position_capteur_amont',
        '__AbsentNamespace0_CTD_ANON_168_position_capteur_amont', typeFloatPositif, required=True)
    __position_capteur_amont._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3084, 16)
    __position_capteur_amont._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3084, 16)

    position_capteur_amont = property(__position_capteur_amont.value, __position_capteur_amont.set, None,
                                      "Position \xe0 laquelle se trouve le capteur amont de la ligne prioritaire (ce capteur permet de d\xe9tecter l'arriv\xe9e d'un v\xe9hicule prioritaire au contr\xf4leur de feux)")


    # Attribute troncon_capteur_aval uses Python identifier troncon_capteur_aval
    __troncon_capteur_aval = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'troncon_capteur_aval'), 'troncon_capteur_aval',
        '__AbsentNamespace0_CTD_ANON_168_troncon_capteur_aval', pyxb.binding.datatypes.string, required=True)
    __troncon_capteur_aval._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3089, 16)
    __troncon_capteur_aval._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3089, 16)

    troncon_capteur_aval = property(__troncon_capteur_aval.value, __troncon_capteur_aval.set, None,
                                    'Identifiant du tron\xe7on sur lequel se trouve le capteur aval de la ligne prioritaire (ce capteur permet de d\xe9tecter la sortie du v\xe9hicule prioritaire du contr\xf4leur de feux)')


    # Attribute position_capteur_aval uses Python identifier position_capteur_aval
    __position_capteur_aval = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'position_capteur_aval'), 'position_capteur_aval',
        '__AbsentNamespace0_CTD_ANON_168_position_capteur_aval', typeFloatPositif, required=True)
    __position_capteur_aval._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3094, 16)
    __position_capteur_aval._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3094, 16)

    position_capteur_aval = property(__position_capteur_aval.value, __position_capteur_aval.set, None,
                                     'Position \xe0 laquelle se trouve le capteur amont de la ligne prioritaire (ce capteur permet de d\xe9tecter la sortie du v\xe9hicule prioritaire du contr\xf4leur de feux)')


    # Attribute troncon_entree_zone uses Python identifier troncon_entree_zone
    __troncon_entree_zone = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'troncon_entree_zone'),
                                                              'troncon_entree_zone',
                                                              '__AbsentNamespace0_CTD_ANON_168_troncon_entree_zone',
                                                              pyxb.binding.datatypes.string, required=True)
    __troncon_entree_zone._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3099, 16)
    __troncon_entree_zone._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3099, 16)

    troncon_entree_zone = property(__troncon_entree_zone.value, __troncon_entree_zone.set, None,
                                   "Identifiant du tron\xe7on permettant de d\xe9finir l'entr\xe9e de la zone du contr\xf4leur de feux")


    # Attribute position_entree_zone uses Python identifier position_entree_zone
    __position_entree_zone = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'position_entree_zone'), 'position_entree_zone',
        '__AbsentNamespace0_CTD_ANON_168_position_entree_zone', typeFloatPositif, required=True)
    __position_entree_zone._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3104, 16)
    __position_entree_zone._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3104, 16)

    position_entree_zone = property(__position_entree_zone.value, __position_entree_zone.set, None,
                                    'Position \xe0 laquelle se trouve le capteur amont de la ligne prioritaire (ce capteur permet de d\xe9tecter la sortie du v\xe9hicule prioritaire du contr\xf4leur de feux)')


    # Attribute priorite_totale uses Python identifier priorite_totale
    __priorite_totale = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'priorite_totale'),
                                                          'priorite_totale',
                                                          '__AbsentNamespace0_CTD_ANON_168_priorite_totale',
                                                          pyxb.binding.datatypes.boolean, unicode_default='true')
    __priorite_totale._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3109, 16)
    __priorite_totale._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3109, 16)

    priorite_totale = property(__priorite_totale.value, __priorite_totale.set, None,
                               'Indique si la priorit\xe9 des v\xe9hicules guid\xe9s d cette ligne est totale (ou partag\xe9e)')


    # Attribute sequence_partagee uses Python identifier sequence_partagee
    __sequence_partagee = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'sequence_partagee'),
                                                            'sequence_partagee',
                                                            '__AbsentNamespace0_CTD_ANON_168_sequence_partagee',
                                                            STD_ANON_35, unicode_default='1')
    __sequence_partagee._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3114, 16)
    __sequence_partagee._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3114, 16)

    sequence_partagee = property(__sequence_partagee.value, __sequence_partagee.set, None,
                                 "Num\xe9ro d'odre de la s\xe9quence partag\xe9e dans le cas d'une ligne guid\xe9e prioritaire partag\xe9e\n")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __lignes.name(): __lignes,
        __troncon_capteur_amont.name(): __troncon_capteur_amont,
        __position_capteur_amont.name(): __position_capteur_amont,
        __troncon_capteur_aval.name(): __troncon_capteur_aval,
        __position_capteur_aval.name(): __position_capteur_aval,
        __troncon_entree_zone.name(): __troncon_entree_zone,
        __position_entree_zone.name(): __position_entree_zone,
        __priorite_totale.name(): __priorite_totale,
        __sequence_partagee.name(): __sequence_partagee
    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_169(pyxb.binding.basis.complexTypeDefinition):
    """Description de la position d'un feu pour une entrÃ©e du contrÃ´leur"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3140, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute troncon_entree uses Python identifier troncon_entree
    __troncon_entree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'troncon_entree'),
                                                         'troncon_entree',
                                                         '__AbsentNamespace0_CTD_ANON_169_troncon_entree',
                                                         pyxb.binding.datatypes.string, required=True)
    __troncon_entree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3141, 16)
    __troncon_entree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3141, 16)

    troncon_entree = property(__troncon_entree.value, __troncon_entree.set, None,
                              "Identifiant du tron\xe7on d'entr\xe9e du feu")


    # Attribute coord uses Python identifier coord
    __coord = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'coord'), 'coord',
                                                '__AbsentNamespace0_CTD_ANON_169_coord', typeCoordonnees, required=True)
    __coord._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3146, 16)
    __coord._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3146, 16)

    coord = property(__coord.value, __coord.set, None, 'Coordonn\xe9es du feu')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __troncon_entree.name(): __troncon_entree,
        __coord.name(): __coord
    })


# Complex type typeTraficOriginePonctuelle with content type ELEMENT_ONLY
class typeTraficOriginePonctuelle(typeTraficOrigine):
    """Complex type typeTraficOriginePonctuelle with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = True
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeTraficOriginePonctuelle')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3438, 2)
    _ElementMap = typeTraficOrigine._ElementMap.copy()
    _AttributeMap = typeTraficOrigine._AttributeMap.copy()
    # Base type is typeTraficOrigine

    # Element FLUX_GLOBAL (FLUX_GLOBAL) inherited from typeTraficOrigine

    # Element FLUX_TYPEVEHS (FLUX_TYPEVEHS) inherited from typeTraficOrigine

    # Element AGRESSIVITES (AGRESSIVITES) inherited from typeTraficOrigine

    # Element CREATION_VEHICULES uses Python identifier CREATION_VEHICULES
    __CREATION_VEHICULES = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'CREATION_VEHICULES'), 'CREATION_VEHICULES',
        '__AbsentNamespace0_typeTraficOriginePonctuelle_CREATION_VEHICULES', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3442, 10), )

    CREATION_VEHICULES = property(__CREATION_VEHICULES.value, __CREATION_VEHICULES.set, None,
                                  'Liste des v\xe9hicules \xe0 cr\xe9er')


    # Attribute id inherited from typeTraficOrigine

    # Attribute typeCreationVehicule inherited from typeTraficOrigine
    _ElementMap.update({
        __CREATION_VEHICULES.name(): __CREATION_VEHICULES
    })
    _AttributeMap.update({

    })


Namespace.addCategoryObject('typeBinding', 'typeTraficOriginePonctuelle', typeTraficOriginePonctuelle)


# Complex type typeParkingZone with content type ELEMENT_ONLY
class typeParkingZone(typeParkingParameters):
    """Complex type typeParkingZone with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeParkingZone')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3561, 2)
    _ElementMap = typeParkingParameters._ElementMap.copy()
    _AttributeMap = typeParkingParameters._AttributeMap.copy()
    # Base type is typeParkingParameters

    # Element TYPE_VEHICULE_INTERDIT (TYPE_VEHICULE_INTERDIT) inherited from typeParkingParameters

    # Attribute stock_max inherited from typeParkingParameters

    # Attribute stock_initial inherited from typeParkingParameters

    # Attribute inter_temps_sortie inherited from typeParkingParameters

    # Attribute inter_temps_entree inherited from typeParkingParameters

    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_typeParkingZone_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3564, 8)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3564, 8)

    id = property(__id.value, __id.set, None, 'identifiant du parking de zone')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id.name(): __id
    })


Namespace.addCategoryObject('typeBinding', 'typeParkingZone', typeParkingZone)


# Complex type typeTraficZone with content type ELEMENT_ONLY
class typeTraficZone(typeTraficOrigine):
    """Complex type typeTraficZone with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeTraficZone')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3572, 2)
    _ElementMap = typeTraficOrigine._ElementMap.copy()
    _AttributeMap = typeTraficOrigine._AttributeMap.copy()
    # Base type is typeTraficOrigine

    # Element FLUX_GLOBAL (FLUX_GLOBAL) inherited from typeTraficOrigine

    # Element FLUX_TYPEVEHS (FLUX_TYPEVEHS) inherited from typeTraficOrigine

    # Element AGRESSIVITES (AGRESSIVITES) inherited from typeTraficOrigine

    # Element TRONCONS uses Python identifier TRONCONS
    __TRONCONS = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'TRONCONS'), 'TRONCONS',
                                                         '__AbsentNamespace0_typeTraficZone_TRONCONS', False,
                                                         pyxb.utils.utility.Location(
                                                             '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                             3576, 10), )

    TRONCONS = property(__TRONCONS.value, __TRONCONS.set, None, 'Liste des tron\xe7ons d\xe9finissant la zone')


    # Element GROUPE_PARKING uses Python identifier GROUPE_PARKING
    __GROUPE_PARKING = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'GROUPE_PARKING'),
                                                               'GROUPE_PARKING',
                                                               '__AbsentNamespace0_typeTraficZone_GROUPE_PARKING', True,
                                                               pyxb.utils.utility.Location(
                                                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                                   3608, 10), )

    GROUPE_PARKING = property(__GROUPE_PARKING.value, __GROUPE_PARKING.set, None,
                              'Liste des parkings compris dans la zone')


    # Element MATRICES_OD_INTERNES uses Python identifier MATRICES_OD_INTERNES
    __MATRICES_OD_INTERNES = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'MATRICES_OD_INTERNES'), 'MATRICES_OD_INTERNES',
        '__AbsentNamespace0_typeTraficZone_MATRICES_OD_INTERNES', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3627, 10), )

    MATRICES_OD_INTERNES = property(__MATRICES_OD_INTERNES.value, __MATRICES_OD_INTERNES.set, None,
                                    'Liste des variantes temporelles de la matrice OD interne \xe0 la zone de terminaison')


    # Element CREATION_VEHICULES uses Python identifier CREATION_VEHICULES
    __CREATION_VEHICULES = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'CREATION_VEHICULES'), 'CREATION_VEHICULES',
        '__AbsentNamespace0_typeTraficZone_CREATION_VEHICULES', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3664, 10), )

    CREATION_VEHICULES = property(__CREATION_VEHICULES.value, __CREATION_VEHICULES.set, None,
                                  'Liste des v\xe9hicules \xe0 cr\xe9er')


    # Element REPARTITIONS_TYPEVEHICULE uses Python identifier REPARTITIONS_TYPEVEHICULE
    __REPARTITIONS_TYPEVEHICULE = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'REPARTITIONS_TYPEVEHICULE'), 'REPARTITIONS_TYPEVEHICULE',
        '__AbsentNamespace0_typeTraficZone_REPARTITIONS_TYPEVEHICULE', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3695, 10), )

    REPARTITIONS_TYPEVEHICULE = property(__REPARTITIONS_TYPEVEHICULE.value, __REPARTITIONS_TYPEVEHICULE.set, None,
                                         'Liste des variantes des r\xe9partitions des types de v\xe9hicule')


    # Element REPARTITION_ORIGINES uses Python identifier REPARTITION_ORIGINES
    __REPARTITION_ORIGINES = pyxb.binding.content.ElementDeclaration(
        pyxb.namespace.ExpandedName(None, 'REPARTITION_ORIGINES'), 'REPARTITION_ORIGINES',
        '__AbsentNamespace0_typeTraficZone_REPARTITION_ORIGINES', False,
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3721, 10), )

    REPARTITION_ORIGINES = property(__REPARTITION_ORIGINES.value, __REPARTITION_ORIGINES.set, None,
                                    "Liste des coefficients de r\xe9partition de la demande sur les diff\xe9rents \xe9l\xe9ments de la zone d'origine (groupes de parkings et tron\xe7ons avec stationnement)")


    # Attribute id inherited from typeTraficOrigine

    # Attribute typeCreationVehicule inherited from typeTraficOrigine

    # Attribute t0 uses Python identifier t0
    __t0 = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 't0'), 't0',
                                             '__AbsentNamespace0_typeTraficZone_t0', typeFloatPositif, required=True)
    __t0._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3748, 8)
    __t0._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3748, 8)

    t0 = property(__t0.value, __t0.set, None, 'Temps moyen de circulation en zone vide (en secondes)')


    # Attribute alpha uses Python identifier alpha
    __alpha = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'alpha'), 'alpha',
                                                '__AbsentNamespace0_typeTraficZone_alpha', typeFloatPositif,
                                                required=True)
    __alpha._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3753, 8)
    __alpha._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3753, 8)

    alpha = property(__alpha.value, __alpha.set, None,
                     'Temps suppl\xe9mentaire de parcours en zone par v\xe9hicule pr\xe9sent dans celle-ci (s / veh)')


    # Attribute beta uses Python identifier beta
    __beta = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'beta'), 'beta',
                                               '__AbsentNamespace0_typeTraficZone_beta', typeFloatPositif,
                                               required=True)
    __beta._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3758, 8)
    __beta._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3758, 8)

    beta = property(__beta.value, __beta.set, None,
                    'Coefficient multiplicatif suppl\xe9mentaire appliqu\xe9 \xe0 alpha dans le mode surfacique')


    # Attribute mode_zone_origine uses Python identifier mode_zone_origine
    __mode_zone_origine = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'mode_zone_origine'),
                                                            'mode_zone_origine',
                                                            '__AbsentNamespace0_typeTraficZone_mode_zone_origine',
                                                            STD_ANON_41)
    __mode_zone_origine._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3763, 8)
    __mode_zone_origine._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3763, 8)

    mode_zone_origine = property(__mode_zone_origine.value, __mode_zone_origine.set, None,
                                 'Mode de gestion de la cr\xe9ation des v\xe9hicules au d\xe9part de cette zone de terminaison')


    # Attribute mode_zone_destination uses Python identifier mode_zone_destination
    __mode_zone_destination = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'mode_zone_destination'), 'mode_zone_destination',
        '__AbsentNamespace0_typeTraficZone_mode_zone_destination', STD_ANON_42)
    __mode_zone_destination._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3782, 8)
    __mode_zone_destination._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3782, 8)

    mode_zone_destination = property(__mode_zone_destination.value, __mode_zone_destination.set, None,
                                     "Mode de gestion des v\xe9hicules \xe0 l'arriv\xe9e \xe0 cette zone de destination")

    _ElementMap.update({
        __TRONCONS.name(): __TRONCONS,
        __GROUPE_PARKING.name(): __GROUPE_PARKING,
        __MATRICES_OD_INTERNES.name(): __MATRICES_OD_INTERNES,
        __CREATION_VEHICULES.name(): __CREATION_VEHICULES,
        __REPARTITIONS_TYPEVEHICULE.name(): __REPARTITIONS_TYPEVEHICULE,
        __REPARTITION_ORIGINES.name(): __REPARTITION_ORIGINES
    })
    _AttributeMap.update({
        __t0.name(): __t0,
        __alpha.name(): __alpha,
        __beta.name(): __beta,
        __mode_zone_origine.name(): __mode_zone_origine,
        __mode_zone_destination.name(): __mode_zone_destination
    })


Namespace.addCategoryObject('typeBinding', 'typeTraficZone', typeTraficZone)


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_170(typeParametrageTrafic):
    """ParamÃ©trage du trafic"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4055, 16)
    _ElementMap = typeParametrageTrafic._ElementMap.copy()
    _AttributeMap = typeParametrageTrafic._AttributeMap.copy()
    # Base type is typeParametrageTrafic

    # Element TRONCONS (TRONCONS) inherited from typeParametrageTrafic

    # Element TYPES_DE_VEHICULE (TYPES_DE_VEHICULE) inherited from typeParametrageTrafic

    # Element EXTREMITES (EXTREMITES) inherited from typeParametrageTrafic

    # Element PARKINGS (PARKINGS) inherited from typeParametrageTrafic

    # Element ZONES_DE_TERMINAISON (ZONES_DE_TERMINAISON) inherited from typeParametrageTrafic

    # Element CONNEXIONS_INTERNES (CONNEXIONS_INTERNES) inherited from typeParametrageTrafic

    # Element PARAMETRAGE_CAPTEURS (PARAMETRAGE_CAPTEURS) inherited from typeParametrageTrafic

    # Element CONTROLEURS_DE_FEUX (CONTROLEURS_DE_FEUX) inherited from typeParametrageTrafic

    # Element REGULATIONS (REGULATIONS) inherited from typeParametrageTrafic

    # Attribute id inherited from typeParametrageTrafic

    # Attribute accbornee inherited from typeParametrageTrafic

    # Attribute chgtvoie inherited from typeParametrageTrafic

    # Attribute chgtvoie_mandatory_falpha inherited from typeParametrageTrafic

    # Attribute chgtvoie_mandatory_probabilite inherited from typeParametrageTrafic

    # Attribute chgtvoie_mandatory_mode inherited from typeParametrageTrafic

    # Attribute chgtvoie_discr_ordre inherited from typeParametrageTrafic

    # Attribute coeffrelax inherited from typeParametrageTrafic

    # Attribute chgtvoie_dstfin inherited from typeParametrageTrafic

    # Attribute agressivite inherited from typeParametrageTrafic

    # Attribute chgtvoie_ghost inherited from typeParametrageTrafic

    # Attribute chgtvoie_ghost_durationMin inherited from typeParametrageTrafic

    # Attribute chgtvoie_ghost_durationMax inherited from typeParametrageTrafic

    # Attribute chgtvoie_ghost_lenghtBevel inherited from typeParametrageTrafic

    # Attribute PeriodeAgregationCapteurs inherited from typeParametrageTrafic

    # Attribute Gamma inherited from typeParametrageTrafic

    # Attribute Mu inherited from typeParametrageTrafic

    # Attribute Beta inherited from typeParametrageTrafic

    # Attribute BetaInt inherited from typeParametrageTrafic

    # Attribute pos_cpt_Av inherited from typeParametrageTrafic

    # Attribute ti inherited from typeParametrageTrafic

    # Attribute tt inherited from typeParametrageTrafic

    # Attribute depassement inherited from typeParametrageTrafic

    # Attribute traversees inherited from typeParametrageTrafic
    _ElementMap.update({

    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_171(pyxb.binding.basis.complexTypeDefinition):
    """Collection des coefficients directionnels pour un tronÃ§on amont, une voie donnÃ©e et un tronÃ§on aval"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               163, 44)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute id_aval uses Python identifier id_aval
    __id_aval = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id_aval'), 'id_aval',
                                                  '__AbsentNamespace0_CTD_ANON_171_id_aval',
                                                  pyxb.binding.datatypes.string, required=True)
    __id_aval._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 164, 46)
    __id_aval._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 164, 46)

    id_aval = property(__id_aval.value, __id_aval.set, None, 'Identifiant unique du tron\xe7on aval')


    # Attribute coeffs uses Python identifier coeffs
    __coeffs = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'coeffs'), 'coeffs',
                                                 '__AbsentNamespace0_CTD_ANON_171_coeffs', typeFloat01List,
                                                 required=True)
    __coeffs._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 170, 46)
    __coeffs._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 170, 46)

    coeffs = property(__coeffs.value, __coeffs.set, None,
                      'Vecteur des coefficients directionnels des voies du tron\xe7on aval pour le tron\xe7on amont et la voie amont consid\xe9r\xe9s. Les valeurs comprises entre 0 et 1 doivent \xeatre ordonn\xe9es selon la num\xe9rotation des voies (voie 1 la plus \xe0 droite dans le sens de la circulation).')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __id_aval.name(): __id_aval,
        __coeffs.name(): __coeffs
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_172(typeTypeDeVehicule):
    """Description d'un type de vÃ©hicule"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               1083, 14)
    _ElementMap = typeTypeDeVehicule._ElementMap.copy()
    _AttributeMap = typeTypeDeVehicule._AttributeMap.copy()
    # Base type is typeTypeDeVehicule

    # Element ACCELERATION_PLAGES (ACCELERATION_PLAGES) inherited from typeTypeDeVehicule

    # Element SOURCES_ACOUSTIQUES (SOURCES_ACOUSTIQUES) inherited from typeTypeDeVehicule

    # Attribute id inherited from typeTypeDeVehicule

    # Attribute w inherited from typeTypeDeVehicule

    # Attribute w_dispersion inherited from typeTypeDeVehicule

    # Attribute w_min inherited from typeTypeDeVehicule

    # Attribute w_max inherited from typeTypeDeVehicule

    # Attribute kx inherited from typeTypeDeVehicule

    # Attribute inv_kx_dispersion inherited from typeTypeDeVehicule

    # Attribute kx_min inherited from typeTypeDeVehicule

    # Attribute kx_max inherited from typeTypeDeVehicule

    # Attribute vx inherited from typeTypeDeVehicule

    # Attribute vx_dispersion inherited from typeTypeDeVehicule

    # Attribute vx_min inherited from typeTypeDeVehicule

    # Attribute vx_max inherited from typeTypeDeVehicule

    # Attribute ax inherited from typeTypeDeVehicule

    # Attribute deceleration inherited from typeTypeDeVehicule

    # Attribute deceleration_ecart_type inherited from typeTypeDeVehicule

    # Attribute espacement_arret inherited from typeTypeDeVehicule

    # Attribute agressivite inherited from typeTypeDeVehicule

    # Attribute pi_rabattement inherited from typeTypeDeVehicule

    # Attribute chgtvoie_tau inherited from typeTypeDeVehicule

    # Attribute vitesse_laterale inherited from typeTypeDeVehicule

    # Attribute depassement_tau inherited from typeTypeDeVehicule

    # Attribute largeur inherited from typeTypeDeVehicule

    # Attribute montee_descente_simultanee inherited from typeTypeDeVehicule

    # Attribute temps_montee_individuelle inherited from typeTypeDeVehicule
    _ElementMap.update({

    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_173(pyxb.binding.basis.complexTypeDefinition):
    """Description d'un horaire de vÃ©hicule guidÃ© (heure de dÃ©part et durÃ©e des arrÃªts>"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2591, 26)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute heuredepart uses Python identifier heuredepart
    __heuredepart = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'heuredepart'), 'heuredepart',
                                                      '__AbsentNamespace0_CTD_ANON_173_heuredepart',
                                                      pyxb.binding.datatypes.time, required=True)
    __heuredepart._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2592, 28)
    __heuredepart._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2592, 28)

    heuredepart = property(__heuredepart.value, __heuredepart.set, None, 'Heure de d\xe9part du v\xe9hicule guid\xe9')


    # Attribute dureearrets uses Python identifier dureearrets
    __dureearrets = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'dureearrets'), 'dureearrets',
                                                      '__AbsentNamespace0_CTD_ANON_173_dureearrets', STD_ANON_51,
                                                      unicode_default='0')
    __dureearrets._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2597, 28)
    __dureearrets._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2597, 28)

    dureearrets = property(__dureearrets.value, __dureearrets.set, None,
                           "Liste des dur\xe9es aux arr\xeats (en seconde), les dur\xe9es sont list\xe9es dans l'ordre de parcours des arr\xeats")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __heuredepart.name(): __heuredepart,
        __dureearrets.name(): __dureearrets
    })


# Complex type typeTraficExtremite with content type ELEMENT_ONLY
class typeTraficExtremite(typeTraficOriginePonctuelle):
    """Complex type typeTraficExtremite with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeTraficExtremite')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3482, 2)
    _ElementMap = typeTraficOriginePonctuelle._ElementMap.copy()
    _AttributeMap = typeTraficOriginePonctuelle._AttributeMap.copy()
    # Base type is typeTraficOriginePonctuelle

    # Element FLUX_GLOBAL (FLUX_GLOBAL) inherited from typeTraficOrigine

    # Element FLUX_TYPEVEHS (FLUX_TYPEVEHS) inherited from typeTraficOrigine

    # Element AGRESSIVITES (AGRESSIVITES) inherited from typeTraficOrigine

    # Element CREATION_VEHICULES (CREATION_VEHICULES) inherited from typeTraficOriginePonctuelle

    # Element CAPACITES uses Python identifier CAPACITES
    __CAPACITES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'CAPACITES'), 'CAPACITES',
                                                          '__AbsentNamespace0_typeTraficExtremite_CAPACITES', False,
                                                          pyxb.utils.utility.Location(
                                                              '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                              3486, 10), )

    CAPACITES = property(__CAPACITES.value, __CAPACITES.set, None,
                         "Liste des variantes de la capacit\xe9 de la sortie. Si cette liste n'existe pas, la sortie est libre.")


    # Attribute id inherited from typeTraficOrigine

    # Attribute typeCreationVehicule inherited from typeTraficOrigine
    _ElementMap.update({
        __CAPACITES.name(): __CAPACITES
    })
    _AttributeMap.update({

    })


Namespace.addCategoryObject('typeBinding', 'typeTraficExtremite', typeTraficExtremite)


# Complex type typeTraficParking with content type ELEMENT_ONLY
class typeTraficParking(typeTraficOriginePonctuelle):
    """Complex type typeTraficParking with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'typeTraficParking')
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3552, 2)
    _ElementMap = typeTraficOriginePonctuelle._ElementMap.copy()
    _AttributeMap = typeTraficOriginePonctuelle._AttributeMap.copy()
    # Base type is typeTraficOriginePonctuelle

    # Element FLUX_GLOBAL (FLUX_GLOBAL) inherited from typeTraficOrigine

    # Element FLUX_TYPEVEHS (FLUX_TYPEVEHS) inherited from typeTraficOrigine

    # Element AGRESSIVITES (AGRESSIVITES) inherited from typeTraficOrigine

    # Element CREATION_VEHICULES (CREATION_VEHICULES) inherited from typeTraficOriginePonctuelle

    # Element PARAMETRES uses Python identifier PARAMETRES
    __PARAMETRES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'PARAMETRES'),
                                                           'PARAMETRES',
                                                           '__AbsentNamespace0_typeTraficParking_PARAMETRES', False,
                                                           pyxb.utils.utility.Location(
                                                               '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                               3556, 10), )

    PARAMETRES = property(__PARAMETRES.value, __PARAMETRES.set, None, None)


    # Attribute id inherited from typeTraficOrigine

    # Attribute typeCreationVehicule inherited from typeTraficOrigine
    _ElementMap.update({
        __PARAMETRES.name(): __PARAMETRES
    })
    _AttributeMap.update({

    })


Namespace.addCategoryObject('typeBinding', 'typeTraficParking', typeTraficParking)


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_174(pyxb.binding.basis.complexTypeDefinition):
    """Description d'une variante d'une rÃ©partition des types de vÃ©hicule"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               3705, 18)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute duree uses Python identifier duree
    __duree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree'), 'duree',
                                                '__AbsentNamespace0_CTD_ANON_174_duree', typeDuree,
                                                unicode_default='always')
    __duree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3706, 20)
    __duree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3706, 20)

    duree = property(__duree.value, __duree.set, None,
                     'Identifiant de la plage temporelle associ\xe9e, ou dur\xe9e (en seconde) de la variante de la r\xe9partition des types de v\xe9hicule')


    # Attribute valeurs uses Python identifier valeurs
    __valeurs = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'valeurs'), 'valeurs',
                                                  '__AbsentNamespace0_CTD_ANON_174_valeurs', typeFloat01NormedList,
                                                  required=True)
    __valeurs._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3711, 20)
    __valeurs._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3711, 20)

    valeurs = property(__valeurs.value, __valeurs.set, None,
                       'Liste ordonn\xe9e (selon la d\xe9finition des types de v\xe9hicule)')

    _ElementMap.update({

    })
    _AttributeMap.update({
        __duree.name(): __duree,
        __valeurs.name(): __valeurs
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_175(typeParametrageSimulation):
    """ParamÃ©trage de la simulation"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               4036, 16)
    _ElementMap = typeParametrageSimulation._ElementMap.copy()
    _AttributeMap = typeParametrageSimulation._AttributeMap.copy()
    # Base type is typeParametrageSimulation

    # Element RESTITUTION (RESTITUTION) inherited from typeParametrageSimulation

    # Element ELEMENTS (ELEMENTS) inherited from typeParametrageSimulation

    # Attribute id inherited from typeParametrageSimulation

    # Attribute pasdetemps inherited from typeParametrageSimulation

    # Attribute debut inherited from typeParametrageSimulation

    # Attribute fin inherited from typeParametrageSimulation

    # Attribute simulation_trafic inherited from typeParametrageSimulation

    # Attribute simulation_acoustique inherited from typeParametrageSimulation

    # Attribute simulation_atmospherique inherited from typeParametrageSimulation

    # Attribute type_sortieacoustique inherited from typeParametrageSimulation

    # Attribute loipoursuite inherited from typeParametrageSimulation

    # Attribute comportementflux inherited from typeParametrageSimulation

    # Attribute nombre_pluscourtchemin inherited from typeParametrageSimulation

    # Attribute offre_aval_convergent_deltaN inherited from typeParametrageSimulation

    # Attribute calcul_tq_convergent inherited from typeParametrageSimulation

    # Attribute date inherited from typeParametrageSimulation

    # Attribute titre inherited from typeParametrageSimulation

    # Attribute proc_deceleration inherited from typeParametrageSimulation

    # Attribute proc_dec_taux inherited from typeParametrageSimulation

    # Attribute seed inherited from typeParametrageSimulation

    # Attribute affectation inherited from typeParametrageSimulation

    # Attribute periode_affectation inherited from typeParametrageSimulation

    # Attribute affectation_equilibre inherited from typeParametrageSimulation

    # Attribute affectation_type_temps_de_parcours inherited from typeParametrageSimulation

    # Attribute affectation_variation_temps_de_parcours inherited from typeParametrageSimulation

    # Attribute affectation_nb_connexion_amont inherited from typeParametrageSimulation

    # Attribute affectation_teta_logit inherited from typeParametrageSimulation

    # Attribute affectation_mode inherited from typeParametrageSimulation

    # Attribute affectation_seuil_convergence inherited from typeParametrageSimulation

    # Attribute affectation_nb_it_max inherited from typeParametrageSimulation

    # Attribute affectation_calculKSP inherited from typeParametrageSimulation

    # Attribute affectation_seuil_tempsdeparcours inherited from typeParametrageSimulation

    # Attribute affectation_poids_max inherited from typeParametrageSimulation

    # Attribute resolution inherited from typeParametrageSimulation

    # Attribute nb_cell_acoustique inherited from typeParametrageSimulation

    # Attribute longueur_cell_acoustique inherited from typeParametrageSimulation

    # Attribute simulation_sirane inherited from typeParametrageSimulation

    # Attribute nb_cell_sirane inherited from typeParametrageSimulation

    # Attribute min_longueur_cell_sirane inherited from typeParametrageSimulation

    # Attribute periode_agregation_sirane inherited from typeParametrageSimulation

    # Attribute mode_zone_origine inherited from typeParametrageSimulation

    # Attribute mode_zone_destination inherited from typeParametrageSimulation

    # Attribute affectation_reroutage inherited from typeParametrageSimulation

    # Attribute affectation_reroutage_dstmax inherited from typeParametrageSimulation

    # Attribute affectation_wardrop_tolerance inherited from typeParametrageSimulation

    # Attribute affectation_alpha inherited from typeParametrageSimulation

    # Attribute affectation_beta inherited from typeParametrageSimulation

    # Attribute affectation_gamma inherited from typeParametrageSimulation

    # Attribute affectation_commonality_filter inherited from typeParametrageSimulation

    # Attribute affectation_commonality_alpha inherited from typeParametrageSimulation

    # Attribute affectation_commonality_beta inherited from typeParametrageSimulation

    # Attribute affectation_commonality_gamma inherited from typeParametrageSimulation

    # Attribute EPSGinput inherited from typeParametrageSimulation
    _ElementMap.update({

    })
    _AttributeMap.update({

    })


# Complex type [anonymous] with content type EMPTY
class CTD_ANON_176(pyxb.binding.basis.complexTypeDefinition):
    """Description d'une variante temporelle de la rÃ©partition du flux par type de vÃ©hicule"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_EMPTY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               5042, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Attribute duree uses Python identifier duree
    __duree = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'duree'), 'duree',
                                                '__AbsentNamespace0_CTD_ANON_176_duree', typeDuree)
    __duree._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 5043, 16)
    __duree._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 5043, 16)

    duree = property(__duree.value, __duree.set, None, 'Dur\xe9e de la variante temporelle')


    # Attribute coeffs uses Python identifier coeffs
    __coeffs = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'coeffs'), 'coeffs',
                                                 '__AbsentNamespace0_CTD_ANON_176_coeffs', typeFloat01List)
    __coeffs._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 5048, 16)
    __coeffs._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 5048, 16)

    coeffs = property(__coeffs.value, __coeffs.set, None,
                      "Liste ordonn\xe9e des coefficients de r\xe9partition du flux selon le type de v\xe9hicule. La somme doit \xeatre \xe9gale \xe0 1, la liste doit contenir auntant d'\xe9l\xe9ment que de type de v\xe9hicule d\xe9fini, l'ordre des coefficients doit \xeatre identique \xe0 celui de la liste des types de v\xe9hicules.")

    _ElementMap.update({

    })
    _AttributeMap.update({
        __duree.name(): __duree,
        __coeffs.name(): __coeffs
    })


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_177(pyxb.binding.basis.complexTypeDefinition):
    """Description d'une ligne de transport guidÃ©e"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                               2579, 14)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType

    # Element HORAIRES uses Python identifier HORAIRES
    __HORAIRES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'HORAIRES'), 'HORAIRES',
                                                         '__AbsentNamespace0_CTD_ANON_177_HORAIRES', False,
                                                         pyxb.utils.utility.Location(
                                                             '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                             2581, 18), )

    HORAIRES = property(__HORAIRES.value, __HORAIRES.set, None,
                        "Liste des horaires des v\xe9hicules guid\xe9s (uniquement le premier v\xe9hicule guid\xe9 dans le cas d'un param\xe9trage de type global)")


    # Element FREQUENCES uses Python identifier FREQUENCES
    __FREQUENCES = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'FREQUENCES'),
                                                           'FREQUENCES', '__AbsentNamespace0_CTD_ANON_177_FREQUENCES',
                                                           False, pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2614, 18), )

    FREQUENCES = property(__FREQUENCES.value, __FREQUENCES.set, None,
                          'D\xe9finition des variations temporelles de fr\xe9quence des v\xe9hicules guid\xe9s sur la ligne, en cas de param\xe8trage de type \'Global\'. L\'attribut "fr\xe9quence" du NOEUD "LIGNE_TRANSPORT_GUIDEE" sera ignor\xe9 si des variations temporelles sotn d\xe9finies ici.')


    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id',
                                             '__AbsentNamespace0_CTD_ANON_177_id', pyxb.binding.datatypes.string,
                                             required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2639, 16)
    __id._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2639, 16)

    id = property(__id.value, __id.set, None, 'Identifiant de la ligne')


    # Attribute type_veh uses Python identifier type_veh
    __type_veh = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'type_veh'), 'type_veh',
                                                   '__AbsentNamespace0_CTD_ANON_177_type_veh',
                                                   pyxb.binding.datatypes.string, required=True)
    __type_veh._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2644, 16)
    __type_veh._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2644, 16)

    type_veh = property(__type_veh.value, __type_veh.set, None,
                        'Type de v\xe9hicule utilis\xe9 sur la ligne guid\xe9e (il doit \xeatre un des types d\xe9fini dans la section TYPES_DE_VEHICULE)')


    # Attribute type_parametrage uses Python identifier type_parametrage
    __type_parametrage = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'type_parametrage'),
                                                           'type_parametrage',
                                                           '__AbsentNamespace0_CTD_ANON_177_type_parametrage',
                                                           STD_ANON_25, required=True)
    __type_parametrage._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2649, 16)
    __type_parametrage._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2649, 16)

    type_parametrage = property(__type_parametrage.value, __type_parametrage.set, None,
                                'Type de param\xe9trage de la ligne')


    # Attribute frequence uses Python identifier frequence
    __frequence = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'frequence'), 'frequence',
                                                    '__AbsentNamespace0_CTD_ANON_177_frequence', typeIntStrictPositif)
    __frequence._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2668, 16)
    __frequence._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2668, 16)

    frequence = property(__frequence.value, __frequence.set, None,
                         'Fr\xe9quence en seconde entre le lancement de 2 v\xe9hicules (\xe0 d\xe9finir uniquement si le type de param\xe9trage est global)')


    # Attribute troncons uses Python identifier troncons
    __troncons = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'troncons'), 'troncons',
                                                   '__AbsentNamespace0_CTD_ANON_177_troncons', STD_ANON_47,
                                                   required=True)
    __troncons._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2673, 16)
    __troncons._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2673, 16)

    troncons = property(__troncons.value, __troncons.set, None,
                        'Itin\xe9raires de la ligne guid\xe9e (liste de tron\xe7ons successifs de la ligne)\nLe VGP est g\xe9n\xe9r\xe9 au niveau du premier arr\xeat de cette ligne (le premier arr\xeat doit donc se trouver sur le premier tron\xe7on list\xe9).\nLe VGP dispara\xeet du r\xe9seau apr\xe8s avoir parcouru le dernier tron\xe7on de la liste. Celui-ci doit donc avoir pour \xe9l\xe9ment aval une sortie.')


    # Attribute duree_arrets_dynamique uses Python identifier duree_arrets_dynamique
    __duree_arrets_dynamique = pyxb.binding.content.AttributeUse(
        pyxb.namespace.ExpandedName(None, 'duree_arrets_dynamique'), 'duree_arrets_dynamique',
        '__AbsentNamespace0_CTD_ANON_177_duree_arrets_dynamique', pyxb.binding.datatypes.boolean,
        unicode_default='false')
    __duree_arrets_dynamique._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2687, 16)
    __duree_arrets_dynamique._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2687, 16)

    duree_arrets_dynamique = property(__duree_arrets_dynamique.value, __duree_arrets_dynamique.set, None,
                                      'Indique si on utilise les param\xe8tres de mont\xe9e et de descente des passagers des bus pour calculer dynamiquement la dur\xe9e des arr\xeats.')


    # Attribute couleur uses Python identifier couleur
    __couleur = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'couleur'), 'couleur',
                                                  '__AbsentNamespace0_CTD_ANON_177_couleur', typeRGBAColor)
    __couleur._DeclarationLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2692, 16)
    __couleur._UseLocation = pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2692, 16)

    couleur = property(__couleur.value, __couleur.set, None,
                       'Indique le couleur utilis\xe9e pour repr\xe9senter la Ligne de transport guid\xe9e\n')

    _ElementMap.update({
        __HORAIRES.name(): __HORAIRES,
        __FREQUENCES.name(): __FREQUENCES
    })
    _AttributeMap.update({
        __id.name(): __id,
        __type_veh.name(): __type_veh,
        __type_parametrage.name(): __type_parametrage,
        __frequence.name(): __frequence,
        __troncons.name(): __troncons,
        __duree_arrets_dynamique.name(): __duree_arrets_dynamique,
        __couleur.name(): __couleur
    })


ROOT_SYMUBRUIT = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'ROOT_SYMUBRUIT'), CTD_ANON_87,
                                            documentation="Noeud racine des donn\xe9es d'entr\xe9e de la plateforme SymuVia",
                                            location=pyxb.utils.utility.Location(
                                                '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                3965, 2))
Namespace.addCategoryObject('elementBinding', ROOT_SYMUBRUIT.name().localName(), ROOT_SYMUBRUIT)


def _BuildAutomaton():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton
    del _BuildAutomaton
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 89, 4))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 90, 6))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.WildcardUse(
        pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_skip,
                                      namespace_constraint=pyxb.binding.content.Wildcard.NC_any),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 90, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeAny._Automaton = _BuildAutomaton()

typePointsInternes._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'POINT_INTERNE'), CTD_ANON_162,
                               scope=typePointsInternes,
                               documentation="\n                  Description d'un point interne du tron\xe7on\n                ",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 96, 6)))


def _BuildAutomaton_():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_
    del _BuildAutomaton_
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 96, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typePointsInternes._UseForTag(pyxb.namespace.ExpandedName(None, 'POINT_INTERNE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 96, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typePointsInternes._Automaton = _BuildAutomaton_()

typeCoeffDir._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'COEFF_DIR'), CTD_ANON, scope=typeCoeffDir,
                               documentation="Description d'une variante temporelle des coefficients directionnels",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 122, 6)))


def _BuildAutomaton_2():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_2
    del _BuildAutomaton_2
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(typeCoeffDir._UseForTag(pyxb.namespace.ExpandedName(None, 'COEFF_DIR')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 122, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


typeCoeffDir._Automaton = _BuildAutomaton_2()

CTD_ANON._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'COEFFS_TRONCON_AMONT'), CTD_ANON_, scope=CTD_ANON,
                               documentation='Collection des coefficients directionnels pour la liste des tron\xe7ons amont',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 128, 12)))


def _BuildAutomaton_3():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_3
    del _BuildAutomaton_3
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(None, 'COEFFS_TRONCON_AMONT')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 128, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON._Automaton = _BuildAutomaton_3()

CTD_ANON_._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'COEFF_TRONCON_AMONT'), CTD_ANON_2, scope=CTD_ANON_,
                               documentation='Description des coefficients directionnels pour un tron\xe7on amont',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 134, 18)))


def _BuildAutomaton_4():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_4
    del _BuildAutomaton_4
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_._UseForTag(pyxb.namespace.ExpandedName(None, 'COEFF_TRONCON_AMONT')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 134, 18))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_._Automaton = _BuildAutomaton_4()

CTD_ANON_2._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'COEFFS_VOIE_AMONT'), CTD_ANON_3, scope=CTD_ANON_2,
                               documentation='Collection des coefficients directionnels pour la liste des voies du tron\xe7on amont',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 140, 24)))


def _BuildAutomaton_5():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_5
    del _BuildAutomaton_5
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_2._UseForTag(pyxb.namespace.ExpandedName(None, 'COEFFS_VOIE_AMONT')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 140, 24))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_2._Automaton = _BuildAutomaton_5()

CTD_ANON_3._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'COEFF_VOIE_AMONT'), CTD_ANON_122, scope=CTD_ANON_3,
                               documentation='Description des coefficients directionnels pour un tron\xe7on amont et une voie donn\xe9e',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 146, 30)))


def _BuildAutomaton_6():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_6
    del _BuildAutomaton_6
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_3._UseForTag(pyxb.namespace.ExpandedName(None, 'COEFF_VOIE_AMONT')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 146, 30))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_3._Automaton = _BuildAutomaton_6()

CTD_ANON_4._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'COEFF_TRONCON_AVAL'), CTD_ANON_171, scope=CTD_ANON_4,
                               documentation='Collection des coefficients directionnels pour un tron\xe7on amont, une voie donn\xe9e et un tron\xe7on aval',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 158, 42)))


def _BuildAutomaton_7():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_7
    del _BuildAutomaton_7
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_4._UseForTag(pyxb.namespace.ExpandedName(None, 'COEFF_TRONCON_AVAL')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 158, 42))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_4._Automaton = _BuildAutomaton_7()

typeAffectation._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'AFFECTATION'), CTD_ANON_123, scope=typeAffectation,
                               documentation="Description d'une variante des donn\xe9es d'affectation de la connexion (ce noeud est d\xe9fini uniquement si le comportement de flux est de type 'destination').",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 216, 6)))


def _BuildAutomaton_8():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_8
    del _BuildAutomaton_8
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        typeAffectation._UseForTag(pyxb.namespace.ExpandedName(None, 'AFFECTATION')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 216, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


typeAffectation._Automaton = _BuildAutomaton_8()

CTD_ANON_5._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'COUPLE_ENTREE_DESTINATION'), CTD_ANON_6,
                               scope=CTD_ANON_5,
                               documentation="Description des donn\xe9es d'affectation d'un couple entr\xe9e / destination de la connexion",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 228, 18)))


def _BuildAutomaton_9():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_9
    del _BuildAutomaton_9
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_5._UseForTag(pyxb.namespace.ExpandedName(None, 'COUPLE_ENTREE_DESTINATION')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 228, 18))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_5._Automaton = _BuildAutomaton_9()

CTD_ANON_6._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SORTIES_CONNEXION'), CTD_ANON_7, scope=CTD_ANON_6,
                               documentation="Noeud d'acc\xe8s \xe0 la liste des sorties affect\xe9es",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 234, 24)))


def _BuildAutomaton_10():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_10
    del _BuildAutomaton_10
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_6._UseForTag(pyxb.namespace.ExpandedName(None, 'SORTIES_CONNEXION')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 234, 24))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_6._Automaton = _BuildAutomaton_10()

CTD_ANON_7._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SORTIE_CONNEXION'), CTD_ANON_124, scope=CTD_ANON_7,
                               documentation='Description de la sortie affect\xe9e',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 240, 30)))


def _BuildAutomaton_11():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_11
    del _BuildAutomaton_11
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_7._UseForTag(pyxb.namespace.ExpandedName(None, 'SORTIE_CONNEXION')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 240, 30))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_7._Automaton = _BuildAutomaton_11()

typeMouvementAutorise._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MOUVEMENT_AUTORISE'), CTD_ANON_125,
                               scope=typeMouvementAutorise,
                               documentation="Description d'un mouvement de la connexion interne",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 291, 6)))


def _BuildAutomaton_12():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_12
    del _BuildAutomaton_12
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        typeMouvementAutorise._UseForTag(pyxb.namespace.ExpandedName(None, 'MOUVEMENT_AUTORISE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 291, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


typeMouvementAutorise._Automaton = _BuildAutomaton_12()

CTD_ANON_8._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MOUVEMENT_SORTIE'), CTD_ANON_126, scope=CTD_ANON_8,
                               documentation="Description de l'aval d'un mouvement",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 303, 18)))


def _BuildAutomaton_13():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_13
    del _BuildAutomaton_13
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_8._UseForTag(pyxb.namespace.ExpandedName(None, 'MOUVEMENT_SORTIE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 303, 18))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_8._Automaton = _BuildAutomaton_13()

typeConnexionInterne._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MOUVEMENTS_AUTORISES'), typeMouvementAutorise,
                               scope=typeConnexionInterne, location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 375, 6)))


def _BuildAutomaton_14():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_14
    del _BuildAutomaton_14
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 375, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeConnexionInterne._UseForTag(pyxb.namespace.ExpandedName(None, 'MOUVEMENTS_AUTORISES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 375, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeConnexionInterne._Automaton = _BuildAutomaton_14()

CTD_ANON_9._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'AFFECTATION_TYPE_VEHICULE'), CTD_ANON_10,
                               scope=CTD_ANON_9,
                               documentation="Noeud d'acc\xe8s \xe0 la description de l'affectation pour un type de v\xe9hicule",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 399, 14)))


def _BuildAutomaton_15():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_15
    del _BuildAutomaton_15
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_9._UseForTag(pyxb.namespace.ExpandedName(None, 'AFFECTATION_TYPE_VEHICULE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 399, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_9._Automaton = _BuildAutomaton_15()

CTD_ANON_10._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'AFFECTATIONS'), typeAffectation, scope=CTD_ANON_10,
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 405, 20)))


def _BuildAutomaton_16():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_16
    del _BuildAutomaton_16
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_10._UseForTag(pyxb.namespace.ExpandedName(None, 'AFFECTATIONS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 405, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_10._Automaton = _BuildAutomaton_16()

CTD_ANON_11._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TEMPS_INSERTION'), CTD_ANON_127, scope=CTD_ANON_11,
                               documentation="Temps d'insertion sur la connexion pour un type de v\xe9hicule",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 426, 12)))


def _BuildAutomaton_17():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_17
    del _BuildAutomaton_17
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_11._UseForTag(pyxb.namespace.ExpandedName(None, 'TEMPS_INSERTION')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 426, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_11._Automaton = _BuildAutomaton_17()

CTD_ANON_12._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PLAGE_EXTRACTION'), CTD_ANON_13, scope=CTD_ANON_12,
                               documentation="Plage temporelle d'\xe9criture des instants de la simulation.",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 507, 18)))


def _BuildAutomaton_18():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_18
    del _BuildAutomaton_18
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_12._UseForTag(pyxb.namespace.ExpandedName(None, 'PLAGE_EXTRACTION')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 507, 18))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_12._Automaton = _BuildAutomaton_18()

CTD_ANON_14._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ELEMENT'), typeSimulationElement, scope=CTD_ANON_14,
                               documentation='El\xe9ment du r\xe9seau pour lequel sont d\xe9finis des param\xe8tres de simulation sp\xe9cifiques',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 613, 12)))


def _BuildAutomaton_19():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_19
    del _BuildAutomaton_19
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_14._UseForTag(pyxb.namespace.ExpandedName(None, 'ELEMENT')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 613, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_14._Automaton = _BuildAutomaton_19()

CTD_ANON_15._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRONCON'), typeTraficTroncon, scope=CTD_ANON_15,
                               documentation='Tron\xe7on pour lequel est d\xe9fini des param\xe8tres de trafic particuliers',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1065, 12)))


def _BuildAutomaton_20():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_20
    del _BuildAutomaton_20
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_15._UseForTag(pyxb.namespace.ExpandedName(None, 'TRONCON')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 1065, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_15._Automaton = _BuildAutomaton_20()

CTD_ANON_16._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TYPE_DE_VEHICULE'), CTD_ANON_172, scope=CTD_ANON_16,
                               documentation="Description d'un type de v\xe9hicule",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1079, 12)))


def _BuildAutomaton_21():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_21
    del _BuildAutomaton_21
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(None, 'TYPE_DE_VEHICULE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1079, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_16._Automaton = _BuildAutomaton_21()

CTD_ANON_17._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'EXTREMITE'), typeTraficExtremite, scope=CTD_ANON_17,
                               documentation="Description des param\xe8tres de trafic d'une extremit\xe9 (entr\xe9e ou sortie)",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1098, 12)))


def _BuildAutomaton_22():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_22
    del _BuildAutomaton_22
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1098, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_17._UseForTag(pyxb.namespace.ExpandedName(None, 'EXTREMITE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 1098, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_17._Automaton = _BuildAutomaton_22()

CTD_ANON_18._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PARKING'), typeTraficParking, scope=CTD_ANON_18,
                               documentation="Description des param\xe8tres de trafic d'un parking",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1113, 12)))


def _BuildAutomaton_23():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_23
    del _BuildAutomaton_23
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1113, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_18._UseForTag(pyxb.namespace.ExpandedName(None, 'PARKING')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 1113, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_18._Automaton = _BuildAutomaton_23()

CTD_ANON_19._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ZONE_DE_TERMINAISON'), typeTraficZone,
                               scope=CTD_ANON_19,
                               documentation="Description des param\xe8tres de trafic d'une zone de terminaison",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1127, 12)))


def _BuildAutomaton_24():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_24
    del _BuildAutomaton_24
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1127, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_19._UseForTag(pyxb.namespace.ExpandedName(None, 'ZONE_DE_TERMINAISON')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1127, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_19._Automaton = _BuildAutomaton_24()

CTD_ANON_20._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CONNEXION_INTERNE'), typeTraficConnexionInterne,
                               scope=CTD_ANON_20,
                               documentation='Connexion interne pour laquelle sont d\xe9finis des param\xe8tres de trafic particuliers',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1142, 12)))


def _BuildAutomaton_25():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_25
    del _BuildAutomaton_25
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_20._UseForTag(pyxb.namespace.ExpandedName(None, 'CONNEXION_INTERNE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1142, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_20._Automaton = _BuildAutomaton_25()

CTD_ANON_21._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CONTROLEUR_DE_FEUX'), typeControleurDeFeux,
                               scope=CTD_ANON_21, documentation="Description d'un contr\xf4leur de feux\n",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1163, 12)))


def _BuildAutomaton_26():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_26
    del _BuildAutomaton_26
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1163, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_21._UseForTag(pyxb.namespace.ExpandedName(None, 'CONTROLEUR_DE_FEUX')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1163, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_21._Automaton = _BuildAutomaton_26()

CTD_ANON_22._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'REGULATION'), typeRegulation, scope=CTD_ANON_22,
                               documentation="D\xe9finition d'une brique de r\xe9gulation",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1179, 12)))


def _BuildAutomaton_27():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_27
    del _BuildAutomaton_27
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1179, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_22._UseForTag(pyxb.namespace.ExpandedName(None, 'REGULATION')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 1179, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_22._Automaton = _BuildAutomaton_27()

CTD_ANON_23._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ACCELERATION_PLAGE'), CTD_ANON_163, scope=CTD_ANON_23,
                               documentation="Description d'une plage d'acc\xe9l\xe9ration",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1366, 12)))


def _BuildAutomaton_28():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_28
    del _BuildAutomaton_28
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_23._UseForTag(pyxb.namespace.ExpandedName(None, 'ACCELERATION_PLAGE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1366, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_23._Automaton = _BuildAutomaton_28()

CTD_ANON_24._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SOURCE_ACOUSTIQUE'), CTD_ANON_25, scope=CTD_ANON_24,
                               documentation="Description d'une source acoustique du type de v\xe9hicule parent",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1392, 12)))


def _BuildAutomaton_29():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_29
    del _BuildAutomaton_29
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_24._UseForTag(pyxb.namespace.ExpandedName(None, 'SOURCE_ACOUSTIQUE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1392, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_24._Automaton = _BuildAutomaton_29()

CTD_ANON_26._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VOIE_REDUITE'), CTD_ANON_129, scope=CTD_ANON_26,
                               documentation="Description d'une voie r\xe9duite", location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1607, 12)))


def _BuildAutomaton_30():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_30
    del _BuildAutomaton_30
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_26._UseForTag(pyxb.namespace.ExpandedName(None, 'VOIE_REDUITE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 1607, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_26._Automaton = _BuildAutomaton_30()

CTD_ANON_27._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VITESSE_REG'), CTD_ANON_130, scope=CTD_ANON_27,
                               documentation='Description des vitesses r\xe9glementaires du tron\xe7on pour une variante temporelle donn\xe9e',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1638, 12)))


def _BuildAutomaton_31():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_31
    del _BuildAutomaton_31
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_27._UseForTag(pyxb.namespace.ExpandedName(None, 'VITESSE_REG')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 1638, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_27._Automaton = _BuildAutomaton_31()

CTD_ANON_28._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VITESSE_REG_PAR_VOIE'), CTD_ANON_131,
                               scope=CTD_ANON_28,
                               documentation='Description de al vitesse r\xe9glementaire pour une voie et \xe9ventuellement une portion spaciale donn\xe9e',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1650, 24)))


def _BuildAutomaton_32():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_32
    del _BuildAutomaton_32
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_28._UseForTag(pyxb.namespace.ExpandedName(None, 'VITESSE_REG_PAR_VOIE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1650, 24))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_28._Automaton = _BuildAutomaton_32()

CTD_ANON_29._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRAVERSEE'), CTD_ANON_30, scope=CTD_ANON_29,
                               documentation="Description d'une travers\xe9e prioritaire",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1712, 12)))


def _BuildAutomaton_33():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_33
    del _BuildAutomaton_33
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_29._UseForTag(pyxb.namespace.ExpandedName(None, 'TRAVERSEE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 1712, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_29._Automaton = _BuildAutomaton_33()

CTD_ANON_30._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LISTE_TEMPS_TRAVERSEE'), CTD_ANON_31,
                               scope=CTD_ANON_30,
                               documentation='Liste des temps de travers\xe9e du tron\xe7on prioritaire pour tous les types de v\xe9hicule circulant sur le r\xe9seau',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1718, 18)))


def _BuildAutomaton_34():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_34
    del _BuildAutomaton_34
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_30._UseForTag(pyxb.namespace.ExpandedName(None, 'LISTE_TEMPS_TRAVERSEE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1718, 18))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_30._Automaton = _BuildAutomaton_34()

CTD_ANON_31._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TEMPS_TRAVERSEE'), CTD_ANON_132, scope=CTD_ANON_31,
                               documentation='Temps de travers\xe9e du tron\xe7on prioritaire pour un type de v\xe9hicule',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1724, 24)))


def _BuildAutomaton_35():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_35
    del _BuildAutomaton_35
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_31._UseForTag(pyxb.namespace.ExpandedName(None, 'TEMPS_TRAVERSEE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1724, 24))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_31._Automaton = _BuildAutomaton_35()

CTD_ANON_32._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VOIE_RESERVEE'), CTD_ANON_133, scope=CTD_ANON_32,
                               documentation="D\xe9finition d'une voie r\xe9serv\xe9e",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1761, 12)))


def _BuildAutomaton_36():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_36
    del _BuildAutomaton_36
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_32._UseForTag(pyxb.namespace.ExpandedName(None, 'VOIE_RESERVEE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 1761, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_32._Automaton = _BuildAutomaton_36()

CTD_ANON_33._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VOIE_INTERDITE'), CTD_ANON_34, scope=CTD_ANON_33,
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1802, 12)))


def _BuildAutomaton_37():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_37
    del _BuildAutomaton_37
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_33._UseForTag(pyxb.namespace.ExpandedName(None, 'VOIE_INTERDITE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1802, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_33._Automaton = _BuildAutomaton_37()

CTD_ANON_35._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TERRE_PLEIN'), CTD_ANON_134, scope=CTD_ANON_35,
                               documentation='Terre-plein pr\xe9sent sur le tron\xe7on',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1825, 12)))


def _BuildAutomaton_38():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_38
    del _BuildAutomaton_38
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_35._UseForTag(pyxb.namespace.ExpandedName(None, 'TERRE_PLEIN')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 1825, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_35._Automaton = _BuildAutomaton_38()

CTD_ANON_36._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ZONE_DEPASSEMENT_INTERDIT'), CTD_ANON_136,
                               scope=CTD_ANON_36,
                               documentation='Zone dans laquelle le d\xe9passement par passage sur la voie de gauche du tron\xe7on oppos\xe9 est interdit',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1875, 12)))


def _BuildAutomaton_39():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_39
    del _BuildAutomaton_39
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_36._UseForTag(pyxb.namespace.ExpandedName(None, 'ZONE_DEPASSEMENT_INTERDIT')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1875, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_36._Automaton = _BuildAutomaton_39()

CTD_ANON_37._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ZONE_EXCLUSION'), CTD_ANON_137, scope=CTD_ANON_37,
                               documentation='Zone dans laquelle le trafic ne doit pas \xeatre pris en compte. A exploiter au niveau des outils de post-traitement.',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1901, 12)))


def _BuildAutomaton_40():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_40
    del _BuildAutomaton_40
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_37._UseForTag(pyxb.namespace.ExpandedName(None, 'ZONE_EXCLUSION')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1901, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_37._Automaton = _BuildAutomaton_40()

CTD_ANON_38._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Z_LEVEL_CROSSING'), CTD_ANON_138, scope=CTD_ANON_38,
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1927, 12)))


def _BuildAutomaton_41():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_41
    del _BuildAutomaton_41
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_38._UseForTag(pyxb.namespace.ExpandedName(None, 'Z_LEVEL_CROSSING')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1927, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_38._Automaton = _BuildAutomaton_41()

CTD_ANON_39._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRONCON_AMONT'), CTD_ANON_139, scope=CTD_ANON_39,
                               documentation="Description d'un tron\xe7on amont du convergent",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2068, 16)))


def _BuildAutomaton_42():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_42
    del _BuildAutomaton_42
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_39._UseForTag(pyxb.namespace.ExpandedName(None, 'TRONCON_AMONT')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2068, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_39._Automaton = _BuildAutomaton_42()

CTD_ANON_40._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRONCON_INTERNE'), CTD_ANON_164, scope=CTD_ANON_40,
                               documentation="Caract\xe9ristiques d'un tron\xe7on de l'anneau du giratoire",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2147, 16)))


def _BuildAutomaton_43():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_43
    del _BuildAutomaton_43
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_40._UseForTag(pyxb.namespace.ExpandedName(None, 'TRONCON_INTERNE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2147, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_40._Automaton = _BuildAutomaton_43()

CTD_ANON_41._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'COEFFICIENT_INSERTION'), CTD_ANON_42,
                               scope=CTD_ANON_41,
                               documentation="D\xe9finition manuelle des taux de choix de la voie d'insertion d'un v\xe9hicule sur le giratoire (utile pour le cas de giratoires \xe0 plusieurs voies) pour une voie d'entr\xe9e et un troncon de sortie donn\xe9s",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2204, 16)))


def _BuildAutomaton_44():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_44
    del _BuildAutomaton_44
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_41._UseForTag(pyxb.namespace.ExpandedName(None, 'COEFFICIENT_INSERTION')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2204, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_41._Automaton = _BuildAutomaton_44()

CTD_ANON_43._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ENTREE_CAF'), CTD_ANON_140, scope=CTD_ANON_43,
                               documentation="Description d'une entr\xe9e du carrefour \xe0 feu (une entr\xe9e est d\xe9finie par un tron\xe7on et un num\xe9ro de voie)",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2303, 16)))


def _BuildAutomaton_45():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_45
    del _BuildAutomaton_45
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_43._UseForTag(pyxb.namespace.ExpandedName(None, 'ENTREE_CAF')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2303, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_43._Automaton = _BuildAutomaton_45()

CTD_ANON_44._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DIVERGENT'), CTD_ANON_165, scope=CTD_ANON_44,
                               documentation="Description d'un divergent d'une branche d'entr\xe9e",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2315, 28)))


def _BuildAutomaton_46():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_46
    del _BuildAutomaton_46
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_44._UseForTag(pyxb.namespace.ExpandedName(None, 'DIVERGENT')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2315, 28))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_44._Automaton = _BuildAutomaton_46()

CTD_ANON_45._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MOUVEMENT'), CTD_ANON_141, scope=CTD_ANON_45,
                               documentation="Description d'un mouvement", location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2354, 28)))


def _BuildAutomaton_47():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_47
    del _BuildAutomaton_47
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_45._UseForTag(pyxb.namespace.ExpandedName(None, 'MOUVEMENT')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2354, 28))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_45._Automaton = _BuildAutomaton_47()

CTD_ANON_46._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'POINT_D_ATTENTE'), CTD_ANON_142, scope=CTD_ANON_46,
                               documentation="Description d'un point d'attente du mouvement. Lors du calcul des points d'intersection des mouvements pour d\xe9tecter les travers\xe9es non prioritaires, celles-ci seront regroup\xe9es en consid\xe9rant leur position par rapport au point d'attente. Ainsi, un point d'attente est utilis\xe9 pour les travers\xe9es du mouvement se situant en amont du point jusqu'au prochain point d'attente d\xe9fini ou jusqu'\xe0 l'extr\xe9mit\xe9 du mouvement",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2372, 40)))


def _BuildAutomaton_48():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_48
    del _BuildAutomaton_48
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_46._UseForTag(pyxb.namespace.ExpandedName(None, 'POINT_D_ATTENTE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2372, 40))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_46._Automaton = _BuildAutomaton_48()

CTD_ANON_47._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SORTIE_CAF'), CTD_ANON_143, scope=CTD_ANON_47,
                               documentation="Description d'une sortie du carrefour \xe0 feu (une sortie est d\xe9finie par un tron\xe7on et un num\xe9ro de voie)",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2486, 16)))


def _BuildAutomaton_49():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_49
    del _BuildAutomaton_49
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_47._UseForTag(pyxb.namespace.ExpandedName(None, 'SORTIE_CAF')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2486, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_47._Automaton = _BuildAutomaton_49()

CTD_ANON_48._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CONVERGENT'), CTD_ANON_166, scope=CTD_ANON_48,
                               documentation="Description d'un divergent d'un tron\xe7on d'entr\xe9e",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2498, 28)))


def _BuildAutomaton_50():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_50
    del _BuildAutomaton_50
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_48._UseForTag(pyxb.namespace.ExpandedName(None, 'CONVERGENT')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2498, 28))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_48._Automaton = _BuildAutomaton_50()

typeLTG._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LIGNES_TRANSPORT_GUIDEES'), CTD_ANON_49,
                               scope=typeLTG, documentation='Liste des lignes de transport guid\xe9e du r\xe9seau',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2569, 6)))

typeLTG._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ARRETS'), CTD_ANON_52, scope=typeLTG,
                                               documentation='Liste des arr\xeats de la ligne',
                                               location=pyxb.utils.utility.Location(
                                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                   2703, 6)))


def _BuildAutomaton_52():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_52
    del _BuildAutomaton_52
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2569, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeLTG._UseForTag(pyxb.namespace.ExpandedName(None, 'LIGNES_TRANSPORT_GUIDEES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2569, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_53():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_53
    del _BuildAutomaton_53
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2703, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(typeLTG._UseForTag(pyxb.namespace.ExpandedName(None, 'ARRETS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2703, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_51():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_51
    del _BuildAutomaton_51
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2569, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2703, 6))
    counters.add(cc_1)
    states = []
    sub_automata = []
    sub_automata.append(_BuildAutomaton_52())
    sub_automata.append(_BuildAutomaton_53())
    final_update = set()
    symbol = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2568, 4)
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=True)
    st_0._set_subAutomata(*sub_automata)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeLTG._Automaton = _BuildAutomaton_51()

CTD_ANON_49._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LIGNE_TRANSPORT_GUIDEE'), CTD_ANON_177,
                               scope=CTD_ANON_49, documentation="Description d'une ligne de transport guid\xe9e",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2575, 12)))


def _BuildAutomaton_54():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_54
    del _BuildAutomaton_54
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_49._UseForTag(pyxb.namespace.ExpandedName(None, 'LIGNE_TRANSPORT_GUIDEE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2575, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_49._Automaton = _BuildAutomaton_54()

CTD_ANON_50._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'HORAIRE'), CTD_ANON_173, scope=CTD_ANON_50,
                               documentation="Description d'un horaire de v\xe9hicule guid\xe9 (heure de d\xe9part et dur\xe9e des arr\xeats>",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2587, 24)))


def _BuildAutomaton_55():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_55
    del _BuildAutomaton_55
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_50._UseForTag(pyxb.namespace.ExpandedName(None, 'HORAIRE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2587, 24))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_50._Automaton = _BuildAutomaton_55()

CTD_ANON_51._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FREQUENCE'), CTD_ANON_144, scope=CTD_ANON_51,
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2620, 24)))


def _BuildAutomaton_56():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_56
    del _BuildAutomaton_56
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_51._UseForTag(pyxb.namespace.ExpandedName(None, 'FREQUENCE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2620, 24))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_51._Automaton = _BuildAutomaton_56()

CTD_ANON_52._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ARRET'), CTD_ANON_167, scope=CTD_ANON_52,
                               documentation="Description d'un arr\xeat", location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2709, 12)))


def _BuildAutomaton_57():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_57
    del _BuildAutomaton_57
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_52._UseForTag(pyxb.namespace.ExpandedName(None, 'ARRET')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2709, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_52._Automaton = _BuildAutomaton_57()

CTD_ANON_53._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LIGNE'), CTD_ANON_54, scope=CTD_ANON_53,
                               documentation='D\xe9finition des param\xe8tres de mont\xe9e pour une ligne donn\xe9e',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2721, 24)))


def _BuildAutomaton_58():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_58
    del _BuildAutomaton_58
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_53._UseForTag(pyxb.namespace.ExpandedName(None, 'LIGNE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2721, 24))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_53._Automaton = _BuildAutomaton_58()

CTD_ANON_54._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DEMANDE'), CTD_ANON_145, scope=CTD_ANON_54,
                               documentation="D\xe9finition d'une variante temporelle de demande pour la ligne consid\xe9r\xe9e",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2727, 30)))


def _BuildAutomaton_59():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_59
    del _BuildAutomaton_59
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_54._UseForTag(pyxb.namespace.ExpandedName(None, 'DEMANDE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2727, 30))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_54._Automaton = _BuildAutomaton_59()

CTD_ANON_55._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LIGNE'), CTD_ANON_56, scope=CTD_ANON_55,
                               documentation="D\xe9finition des param\xe8tres de descente \xe0 l'arr\xeat et pour la ligne consid\xe9r\xe9e",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2768, 24)))


def _BuildAutomaton_60():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_60
    del _BuildAutomaton_60
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_55._UseForTag(pyxb.namespace.ExpandedName(None, 'LIGNE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2768, 24))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_55._Automaton = _BuildAutomaton_60()

CTD_ANON_57._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CAPTEUR'), typeCapteurPonctuel, scope=CTD_ANON_57,
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2860, 12)))

CTD_ANON_57._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CAPTEUR_LONGITUDINAL'), typeCapteurLongitudinal,
                               scope=CTD_ANON_57, location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2862, 12)))

CTD_ANON_57._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CAPTEUR_EDIE'), typeCapteurLongitudinal,
                               scope=CTD_ANON_57, location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2864, 12)))

CTD_ANON_57._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CAPTEUR_MFD'), typeCapteurMFD, scope=CTD_ANON_57,
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2866, 12)))

CTD_ANON_57._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CAPTEUR_BLUETOOTH'), typeCapteurBlueTooth,
                               scope=CTD_ANON_57, location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2868, 12)))


def _BuildAutomaton_61():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_61
    del _BuildAutomaton_61
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2860, 12))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2862, 12))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2864, 12))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2866, 12))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2868, 12))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_57._UseForTag(pyxb.namespace.ExpandedName(None, 'CAPTEUR')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2860, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_57._UseForTag(pyxb.namespace.ExpandedName(None, 'CAPTEUR_LONGITUDINAL')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2862, 12))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_57._UseForTag(pyxb.namespace.ExpandedName(None, 'CAPTEUR_EDIE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2864, 12))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_57._UseForTag(pyxb.namespace.ExpandedName(None, 'CAPTEUR_MFD')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2866, 12))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_57._UseForTag(pyxb.namespace.ExpandedName(None, 'CAPTEUR_BLUETOOTH')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2868, 12))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False)]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False)]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False)]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True)]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_57._Automaton = _BuildAutomaton_61()

CTD_ANON_58._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PLAN_DE_FEUX'), CTD_ANON_146, scope=CTD_ANON_58,
                               documentation="Noeud de description d'un plan de feux",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2936, 12)))


def _BuildAutomaton_62():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_62
    del _BuildAutomaton_62
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2936, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_58._UseForTag(pyxb.namespace.ExpandedName(None, 'PLAN_DE_FEUX')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2936, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_58._Automaton = _BuildAutomaton_62()

CTD_ANON_59._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SEQUENCE'), CTD_ANON_147, scope=CTD_ANON_59,
                               documentation="Noeud de description d'une s\xe9quence du plan de feux\n",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2948, 24)))


def _BuildAutomaton_63():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_63
    del _BuildAutomaton_63
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_59._UseForTag(pyxb.namespace.ExpandedName(None, 'SEQUENCE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2948, 24))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_59._Automaton = _BuildAutomaton_63()

CTD_ANON_60._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SIGNAL_ACTIF'), CTD_ANON_148, scope=CTD_ANON_60,
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2962, 36)))


def _BuildAutomaton_64():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_64
    del _BuildAutomaton_64
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_60._UseForTag(pyxb.namespace.ExpandedName(None, 'SIGNAL_ACTIF')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2962, 36))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_60._Automaton = _BuildAutomaton_64()

CTD_ANON_61._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LIGNE_GUIDEE_PRIORITAIRE'), CTD_ANON_168,
                               scope=CTD_ANON_61, documentation='', location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3062, 12)))


def _BuildAutomaton_65():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_65
    del _BuildAutomaton_65
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3062, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_61._UseForTag(pyxb.namespace.ExpandedName(None, 'LIGNE_GUIDEE_PRIORITAIRE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3062, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_61._Automaton = _BuildAutomaton_65()

CTD_ANON_62._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'POSITION_FEU'), CTD_ANON_169, scope=CTD_ANON_62,
                               documentation="Description de la position d'un feu pour une entr\xe9e du contr\xf4leur",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3136, 12)))


def _BuildAutomaton_66():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_66
    del _BuildAutomaton_66
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3136, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_62._UseForTag(pyxb.namespace.ExpandedName(None, 'POSITION_FEU')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3136, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_62._Automaton = _BuildAutomaton_66()

typeCapteurMFD._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRONCONS'), CTD_ANON_63, scope=typeCapteurMFD,
                               documentation='Liste des tron\xe7ons constituant la zone du capteur MFD',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3280, 6)))


def _BuildAutomaton_67():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_67
    del _BuildAutomaton_67
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(typeCapteurMFD._UseForTag(pyxb.namespace.ExpandedName(None, 'TRONCONS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3280, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


typeCapteurMFD._Automaton = _BuildAutomaton_67()

CTD_ANON_63._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRONCON'), CTD_ANON_64, scope=CTD_ANON_63,
                               documentation='Troncon appartenant \xe0 la zone MFD',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3286, 12)))


def _BuildAutomaton_68():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_68
    del _BuildAutomaton_68
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_63._UseForTag(pyxb.namespace.ExpandedName(None, 'TRONCON')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3286, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_63._Automaton = _BuildAutomaton_68()

typeCapteurBlueTooth._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'POSITION'), CTD_ANON_149, scope=typeCapteurBlueTooth,
                               documentation='Permet de sp\xe9cifier la positione des capteurs ponctuels d\xe9tectant les v\xe9hicules entrants et sortants du noeud (Par d\xe9faut, ces capteurs sont situ\xe9s aux extr\xe9mit\xe9s des tron\xe7ons amont et aval, au niveau du noeud)',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3313, 6)))


def _BuildAutomaton_69():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_69
    del _BuildAutomaton_69
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3313, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeCapteurBlueTooth._UseForTag(pyxb.namespace.ExpandedName(None, 'POSITION')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3313, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeCapteurBlueTooth._Automaton = _BuildAutomaton_69()

CTD_ANON_65._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FLUX_TYPEVEH'), CTD_ANON_66, scope=CTD_ANON_65,
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3360, 12)))


def _BuildAutomaton_70():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_70
    del _BuildAutomaton_70
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_65._UseForTag(pyxb.namespace.ExpandedName(None, 'FLUX_TYPEVEH')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3360, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_65._Automaton = _BuildAutomaton_70()

CTD_ANON_66._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FLUX'), typeFLUX, scope=CTD_ANON_66,
                               documentation="Description du flux pour un type de v\xe9hicule pour l'extr\xe9mit\xe9 courante",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3363, 18)))


def _BuildAutomaton_71():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_71
    del _BuildAutomaton_71
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_66._UseForTag(pyxb.namespace.ExpandedName(None, 'FLUX')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3363, 18))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_66._Automaton = _BuildAutomaton_71()

CTD_ANON_67._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'AGRESSIVITE'), CTD_ANON_150, scope=CTD_ANON_67,
                               documentation="Description du caract\xe8re agressif d'une classe de v\xe9hicule pour cette entr\xe9e (par d\xe9faut, le taux de v\xe9hicule agressif d'une classe est 0)\n",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3385, 12)))


def _BuildAutomaton_72():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_72
    del _BuildAutomaton_72
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3385, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_67._UseForTag(pyxb.namespace.ExpandedName(None, 'AGRESSIVITE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3385, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_67._Automaton = _BuildAutomaton_72()

CTD_ANON_68._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CREATION_VEHICULE'), CTD_ANON_151, scope=CTD_ANON_68,
                               documentation="D\xe9finition d'une cr\xe9ation", location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3448, 16)))


def _BuildAutomaton_73():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_73
    del _BuildAutomaton_73
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_68._UseForTag(pyxb.namespace.ExpandedName(None, 'CREATION_VEHICULE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3448, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_68._Automaton = _BuildAutomaton_73()

CTD_ANON_69._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CAPACITE'), CTD_ANON_152, scope=CTD_ANON_69,
                               documentation="Description d'une variante de la capacit\xe9",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3492, 16)))


def _BuildAutomaton_74():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_74
    del _BuildAutomaton_74
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_69._UseForTag(pyxb.namespace.ExpandedName(None, 'CAPACITE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3492, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_69._Automaton = _BuildAutomaton_74()

CTD_ANON_71._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRONCON'), CTD_ANON_72, scope=CTD_ANON_71,
                               documentation='Tron\xe7on appartenant \xe0 la zone',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3582, 16)))


def _BuildAutomaton_75():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_75
    del _BuildAutomaton_75
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_71._UseForTag(pyxb.namespace.ExpandedName(None, 'TRONCON')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3582, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_71._Automaton = _BuildAutomaton_75()

CTD_ANON_73._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PARKING'), typeParkingZone, scope=CTD_ANON_73,
                               documentation='Parking appartenant \xe0 la zone', location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3614, 16)))


def _BuildAutomaton_76():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_76
    del _BuildAutomaton_76
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_73._UseForTag(pyxb.namespace.ExpandedName(None, 'PARKING')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3614, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_73._Automaton = _BuildAutomaton_76()

CTD_ANON_74._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MATRICE_OD_INTERNE'), CTD_ANON_153, scope=CTD_ANON_74,
                               documentation="Description d'une variante de la matrice OD (la somme des coefficients d'affectation pour l'ensemble des destinations d\xe9clar\xe9es doit \xeatre \xe9gale \xe0 1, si une destination n'est pas d\xe9clar\xe9e son coefficient d'affectation est 0 par d\xe9faut)",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3633, 16)))


def _BuildAutomaton_77():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_77
    del _BuildAutomaton_77
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_74._UseForTag(pyxb.namespace.ExpandedName(None, 'MATRICE_OD_INTERNE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3633, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_74._Automaton = _BuildAutomaton_77()

CTD_ANON_75._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CREATION_VEHICULE'), CTD_ANON_76, scope=CTD_ANON_75,
                               documentation="D\xe9finition d'une cr\xe9ation", location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3670, 16)))


def _BuildAutomaton_78():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_78
    del _BuildAutomaton_78
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_75._UseForTag(pyxb.namespace.ExpandedName(None, 'CREATION_VEHICULE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3670, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_75._Automaton = _BuildAutomaton_78()

CTD_ANON_77._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'REPARTITION_TYPEVEHICULE'), CTD_ANON_174,
                               scope=CTD_ANON_77,
                               documentation="Description d'une variante d'une r\xe9partition des types de v\xe9hicule",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3701, 16)))


def _BuildAutomaton_79():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_79
    del _BuildAutomaton_79
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_77._UseForTag(pyxb.namespace.ExpandedName(None, 'REPARTITION_TYPEVEHICULE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3701, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_77._Automaton = _BuildAutomaton_79()

CTD_ANON_78._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ORIGINE'), CTD_ANON_155, scope=CTD_ANON_78,
                               documentation="D\xe9finition du coefficient d'affectation associ\xe9 \xe0 une origine",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3727, 16)))


def _BuildAutomaton_80():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_80
    del _BuildAutomaton_80
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_78._UseForTag(pyxb.namespace.ExpandedName(None, 'ORIGINE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3727, 16))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_78._Automaton = _BuildAutomaton_80()

CTD_ANON_79._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CAPTEUR'), CTD_ANON_80, scope=CTD_ANON_79,
                               documentation='Capteur associ\xe9 \xe0 la brique de r\xe9gulation',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3812, 12)))


def _BuildAutomaton_81():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_81
    del _BuildAutomaton_81
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3812, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_79._UseForTag(pyxb.namespace.ExpandedName(None, 'CAPTEUR')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3812, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_79._Automaton = _BuildAutomaton_81()

CTD_ANON_80._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PARAMETRES'), typeAny, scope=CTD_ANON_80,
                               documentation='D\xe9finition des param\xe8tres n\xe9cessaire \xe0 la fonction d\xe9finie pour le capteur',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3818, 18)))


def _BuildAutomaton_82():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_82
    del _BuildAutomaton_82
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3817, 16))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3818, 18))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_80._UseForTag(pyxb.namespace.ExpandedName(None, 'PARAMETRES')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3818, 18))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_80._Automaton = _BuildAutomaton_82()

CTD_ANON_81._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CONDITION'), CTD_ANON_82, scope=CTD_ANON_81,
                               documentation="Condition de d\xe9clenchement d'actions associ\xe9e \xe0 la brique de r\xe9gulation",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3850, 12)))


def _BuildAutomaton_83():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_83
    del _BuildAutomaton_83
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3850, 12))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_81._UseForTag(pyxb.namespace.ExpandedName(None, 'CONDITION')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3850, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_81._Automaton = _BuildAutomaton_83()

CTD_ANON_82._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PARAMETRES'), typeAny, scope=CTD_ANON_82,
                               documentation='D\xe9finition des param\xe8tres n\xe9cessaire \xe0 la fonction d\xe9finie pour la condition',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3856, 18)))


def _BuildAutomaton_84():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_84
    del _BuildAutomaton_84
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3855, 16))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3856, 18))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_82._UseForTag(pyxb.namespace.ExpandedName(None, 'PARAMETRES')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3856, 18))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_82._Automaton = _BuildAutomaton_84()

CTD_ANON_83._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ACTION'), CTD_ANON_84, scope=CTD_ANON_83,
                               documentation='Action associ\xe9e \xe0 la brique de r\xe9gulation',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3888, 12)))


def _BuildAutomaton_85():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_85
    del _BuildAutomaton_85
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_83._UseForTag(pyxb.namespace.ExpandedName(None, 'ACTION')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3888, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_83._Automaton = _BuildAutomaton_85()

CTD_ANON_84._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PARAMETRES'), typeAny, scope=CTD_ANON_84,
                               documentation="D\xe9finition des param\xe8tres n\xe9cessaire \xe0 la fonction d\xe9finie pour l'action",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3894, 18)))


def _BuildAutomaton_86():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_86
    del _BuildAutomaton_86
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3893, 16))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3894, 18))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_84._UseForTag(pyxb.namespace.ExpandedName(None, 'PARAMETRES')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3894, 18))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_84._Automaton = _BuildAutomaton_86()

CTD_ANON_85._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RESTITUTION'), CTD_ANON_86, scope=CTD_ANON_85,
                               documentation='D\xe9finition des sorties \xe0 produire dans le fichier de sortie poru la brique de r\xe9gulation',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3926, 12)))


def _BuildAutomaton_87():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_87
    del _BuildAutomaton_87
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_85._UseForTag(pyxb.namespace.ExpandedName(None, 'RESTITUTION')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3926, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_85._Automaton = _BuildAutomaton_87()

CTD_ANON_86._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PARAMETRES'), typeAny, scope=CTD_ANON_86,
                               documentation='D\xe9finition des param\xe8tres n\xe9cessaire \xe0 la fonction d\xe9finie pour la restitution',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3932, 18)))


def _BuildAutomaton_88():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_88
    del _BuildAutomaton_88
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3931, 16))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3932, 18))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_86._UseForTag(pyxb.namespace.ExpandedName(None, 'PARAMETRES')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3932, 18))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_86._Automaton = _BuildAutomaton_88()

CTD_ANON_87._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PLAGES_TEMPORELLES'), CTD_ANON_156, scope=CTD_ANON_87,
                               documentation='Ensemble des plages temporelles d\xe9finies pour l\'ensemble de la ou des simulations, dont l\'ID peut \xeatre utilis\xe9 pour renseigner la plage de validit\xe9 des variantes temporelles (attributs "duree" de certains \xe9l\xe9ments)',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3971, 8)))

CTD_ANON_87._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SIMULATIONS'), CTD_ANON_89, scope=CTD_ANON_87,
                               documentation='Liste des d\xe9finitions de param\xe8tres de simulation',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4026, 8)))

CTD_ANON_87._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRAFICS'), CTD_ANON_90, scope=CTD_ANON_87,
                               documentation='Liste des d\xe9finitions de param\xe8tres de trafic',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4045, 8)))

CTD_ANON_87._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RESEAUX'), CTD_ANON_91, scope=CTD_ANON_87,
                               documentation='Liste des d\xe9finitions de r\xe9seaux',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4064, 8)))

CTD_ANON_87._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SCENARIOS'), CTD_ANON_114, scope=CTD_ANON_87,
                               documentation='Liste des d\xe9finitions de sc\xe9narios',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4417, 8)))


def _BuildAutomaton_89():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_89
    del _BuildAutomaton_89
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3971, 8))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_87._UseForTag(pyxb.namespace.ExpandedName(None, 'PLAGES_TEMPORELLES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3971, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_87._UseForTag(pyxb.namespace.ExpandedName(None, 'SIMULATIONS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4026, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_87._UseForTag(pyxb.namespace.ExpandedName(None, 'TRAFICS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4045, 8))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_87._UseForTag(pyxb.namespace.ExpandedName(None, 'RESEAUX')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4064, 8))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_87._UseForTag(pyxb.namespace.ExpandedName(None, 'SCENARIOS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4417, 8))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
    ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
    ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
    ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_87._Automaton = _BuildAutomaton_89()

CTD_ANON_89._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SIMULATION'), CTD_ANON_175, scope=CTD_ANON_89,
                               documentation='Param\xe9trage de la simulation', location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4032, 14)))


def _BuildAutomaton_90():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_90
    del _BuildAutomaton_90
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_89._UseForTag(pyxb.namespace.ExpandedName(None, 'SIMULATION')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4032, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_89._Automaton = _BuildAutomaton_90()

CTD_ANON_90._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRAFIC'), CTD_ANON_170, scope=CTD_ANON_90,
                               documentation='Param\xe9trage du trafic', location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4051, 14)))


def _BuildAutomaton_91():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_91
    del _BuildAutomaton_91
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_90._UseForTag(pyxb.namespace.ExpandedName(None, 'TRAFIC')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4051, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_90._Automaton = _BuildAutomaton_91()

CTD_ANON_91._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RESEAU'), CTD_ANON_92, scope=CTD_ANON_91,
                               documentation='Donn\xe9es du r\xe9seau', location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4070, 14)))


def _BuildAutomaton_92():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_92
    del _BuildAutomaton_92
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_91._UseForTag(pyxb.namespace.ExpandedName(None, 'RESEAU')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4070, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_91._Automaton = _BuildAutomaton_92()

CTD_ANON_92._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRONCONS'), CTD_ANON_93, scope=CTD_ANON_92,
                               documentation='Liste des tron\xe7ons', location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4076, 20)))

CTD_ANON_92._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CONNEXIONS'), CTD_ANON_94, scope=CTD_ANON_92,
                               documentation='Noeud ', location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4090, 20)))

CTD_ANON_92._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ZONES_DE_TERMINAISON'), CTD_ANON_103,
                               scope=CTD_ANON_92, documentation='Liste des zones de terminaison',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4201, 20)))

CTD_ANON_92._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PARAMETRAGE_VEHICULES_GUIDES'), typeLTG,
                               scope=CTD_ANON_92,
                               documentation='Param\xe9trage des v\xe9hicules guid\xe9s du r\xe9seau',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4223, 20)))

CTD_ANON_92._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ROUTES'), CTD_ANON_105, scope=CTD_ANON_92,
                               documentation="Liste d'itin\xe9raires du r\xe9seau",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4228, 20)))

CTD_ANON_92._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'COORD_REFS'), CTD_ANON_109, scope=CTD_ANON_92,
                               documentation='Liste des r\xe9f\xe9rentiels de coordonn\xe9es g\xe9ographiques utilis\xe9s\n',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4277, 20)))

CTD_ANON_92._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'INIT'), CTD_ANON_112, scope=CTD_ANON_92,
                               documentation="Initialisation du r\xe9seau par une liste de v\xe9hicule pr\xe9sent sur le r\xe9seau \xe0 l'instant 0",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4331, 20)))


def _BuildAutomaton_94():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_94
    del _BuildAutomaton_94
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_92._UseForTag(pyxb.namespace.ExpandedName(None, 'TRONCONS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4076, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=st_0)


def _BuildAutomaton_95():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_95
    del _BuildAutomaton_95
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_92._UseForTag(pyxb.namespace.ExpandedName(None, 'CONNEXIONS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4090, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=st_0)


def _BuildAutomaton_96():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_96
    del _BuildAutomaton_96
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4201, 20))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_92._UseForTag(pyxb.namespace.ExpandedName(None, 'ZONES_DE_TERMINAISON')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4201, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_97():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_97
    del _BuildAutomaton_97
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4223, 20))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_92._UseForTag(pyxb.namespace.ExpandedName(None, 'PARAMETRAGE_VEHICULES_GUIDES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4223, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_98():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_98
    del _BuildAutomaton_98
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4228, 20))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_92._UseForTag(pyxb.namespace.ExpandedName(None, 'ROUTES')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4228, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_99():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_99
    del _BuildAutomaton_99
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4277, 20))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_92._UseForTag(pyxb.namespace.ExpandedName(None, 'COORD_REFS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4277, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_100():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_100
    del _BuildAutomaton_100
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4331, 20))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_92._UseForTag(pyxb.namespace.ExpandedName(None, 'INIT')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4331, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_93():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_93
    del _BuildAutomaton_93
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4201, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4223, 20))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4228, 20))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4277, 20))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4331, 20))
    counters.add(cc_4)
    states = []
    sub_automata = []
    sub_automata.append(_BuildAutomaton_94())
    sub_automata.append(_BuildAutomaton_95())
    sub_automata.append(_BuildAutomaton_96())
    sub_automata.append(_BuildAutomaton_97())
    sub_automata.append(_BuildAutomaton_98())
    sub_automata.append(_BuildAutomaton_99())
    sub_automata.append(_BuildAutomaton_100())
    final_update = set()
    symbol = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4075,
                                         18)
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=True)
    st_0._set_subAutomata(*sub_automata)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_92._Automaton = _BuildAutomaton_93()

CTD_ANON_93._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRONCON'), typeTroncon, scope=CTD_ANON_93,
                               documentation="Description d'un tron\xe7on", location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4082, 26)))


def _BuildAutomaton_101():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_101
    del _BuildAutomaton_101
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_93._UseForTag(pyxb.namespace.ExpandedName(None, 'TRONCON')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4082, 26))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_93._Automaton = _BuildAutomaton_101()

CTD_ANON_94._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'EXTREMITES'), CTD_ANON_95, scope=CTD_ANON_94,
                               documentation='Liste des extr\xe9mit\xe9s (anciennement entr\xe9es et sorties)',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4096, 26)))

CTD_ANON_94._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PARKINGS'), CTD_ANON_97, scope=CTD_ANON_94,
                               documentation='Liste des parkings', location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4117, 26)))

CTD_ANON_94._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'REPARTITEURS'), CTD_ANON_99, scope=CTD_ANON_94,
                               documentation='Liste des r\xe9partiteurs', location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4138, 26)))

CTD_ANON_94._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CONVERGENTS'), CTD_ANON_100, scope=CTD_ANON_94,
                               documentation='Liste des convergents', location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4153, 26)))

CTD_ANON_94._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'GIRATOIRES'), CTD_ANON_101, scope=CTD_ANON_94,
                               documentation='Liste des giratoires', location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4168, 26)))

CTD_ANON_94._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CARREFOURSAFEUX'), CTD_ANON_102, scope=CTD_ANON_94,
                               documentation='Liste des carrefours \xe0 feux', location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4183, 26)))


def _BuildAutomaton_103():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_103
    del _BuildAutomaton_103
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4096, 26))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_94._UseForTag(pyxb.namespace.ExpandedName(None, 'EXTREMITES')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4096, 26))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_104():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_104
    del _BuildAutomaton_104
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4117, 26))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_94._UseForTag(pyxb.namespace.ExpandedName(None, 'PARKINGS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4117, 26))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_105():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_105
    del _BuildAutomaton_105
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4138, 26))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_94._UseForTag(pyxb.namespace.ExpandedName(None, 'REPARTITEURS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4138, 26))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_106():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_106
    del _BuildAutomaton_106
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4153, 26))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_94._UseForTag(pyxb.namespace.ExpandedName(None, 'CONVERGENTS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4153, 26))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_107():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_107
    del _BuildAutomaton_107
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4168, 26))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_94._UseForTag(pyxb.namespace.ExpandedName(None, 'GIRATOIRES')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4168, 26))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_108():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_108
    del _BuildAutomaton_108
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4183, 26))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_94._UseForTag(pyxb.namespace.ExpandedName(None, 'CARREFOURSAFEUX')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4183, 26))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_102():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_102
    del _BuildAutomaton_102
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4096, 26))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4117, 26))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4138, 26))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4153, 26))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4168, 26))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4183, 26))
    counters.add(cc_5)
    states = []
    sub_automata = []
    sub_automata.append(_BuildAutomaton_103())
    sub_automata.append(_BuildAutomaton_104())
    sub_automata.append(_BuildAutomaton_105())
    sub_automata.append(_BuildAutomaton_106())
    sub_automata.append(_BuildAutomaton_107())
    sub_automata.append(_BuildAutomaton_108())
    final_update = set()
    symbol = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4095,
                                         24)
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=True)
    st_0._set_subAutomata(*sub_automata)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_94._Automaton = _BuildAutomaton_102()

CTD_ANON_95._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'EXTREMITE'), CTD_ANON_96, scope=CTD_ANON_95,
                               documentation="Description d'une extremit\xe9 du r\xe9seau",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4102, 32)))


def _BuildAutomaton_109():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_109
    del _BuildAutomaton_109
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4102, 32))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_95._UseForTag(pyxb.namespace.ExpandedName(None, 'EXTREMITE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4102, 32))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_95._Automaton = _BuildAutomaton_109()

CTD_ANON_97._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PARKING'), CTD_ANON_98, scope=CTD_ANON_97,
                               documentation="Description d'un parking du r\xe9seau",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4123, 32)))


def _BuildAutomaton_110():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_110
    del _BuildAutomaton_110
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4123, 32))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_97._UseForTag(pyxb.namespace.ExpandedName(None, 'PARKING')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4123, 32))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_97._Automaton = _BuildAutomaton_110()

CTD_ANON_99._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'REPARTITEUR'), typeRepartiteur, scope=CTD_ANON_99,
                               documentation="Description d'un r\xe9partiteur", location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4144, 32)))


def _BuildAutomaton_111():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_111
    del _BuildAutomaton_111
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4144, 32))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_99._UseForTag(pyxb.namespace.ExpandedName(None, 'REPARTITEUR')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4144, 32))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_99._Automaton = _BuildAutomaton_111()

CTD_ANON_100._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CONVERGENT'), typeConvergent, scope=CTD_ANON_100,
                               documentation="Description d'un convergent", location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4159, 32)))


def _BuildAutomaton_112():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_112
    del _BuildAutomaton_112
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4159, 32))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_100._UseForTag(pyxb.namespace.ExpandedName(None, 'CONVERGENT')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4159, 32))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_100._Automaton = _BuildAutomaton_112()

CTD_ANON_101._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'GIRATOIRE'), typeGiratoire, scope=CTD_ANON_101,
                               documentation="Description d'un r\xe9partiteur", location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4174, 32)))


def _BuildAutomaton_113():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_113
    del _BuildAutomaton_113
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4174, 32))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_101._UseForTag(pyxb.namespace.ExpandedName(None, 'GIRATOIRE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4174, 32))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_101._Automaton = _BuildAutomaton_113()

CTD_ANON_102._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CARREFOURAFEUX'), typeCarrefourAFeux,
                               scope=CTD_ANON_102, documentation="Description d'un carrefour \xe0 feux",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4189, 32)))


def _BuildAutomaton_114():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_114
    del _BuildAutomaton_114
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4189, 32))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_102._UseForTag(pyxb.namespace.ExpandedName(None, 'CARREFOURAFEUX')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4189, 32))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_102._Automaton = _BuildAutomaton_114()

CTD_ANON_103._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ZONE_DE_TERMINAISON'), CTD_ANON_104,
                               scope=CTD_ANON_103, documentation="Description d'une zone de terminaison",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4207, 26)))


def _BuildAutomaton_115():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_115
    del _BuildAutomaton_115
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4207, 26))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_103._UseForTag(pyxb.namespace.ExpandedName(None, 'ZONE_DE_TERMINAISON')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4207, 26))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_103._Automaton = _BuildAutomaton_115()

CTD_ANON_105._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ROUTE'), CTD_ANON_106, scope=CTD_ANON_105,
                               documentation="Description d'un itin\xe9raire du r\xe9seau",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4234, 26)))


def _BuildAutomaton_116():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_116
    del _BuildAutomaton_116
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4234, 26))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_105._UseForTag(pyxb.namespace.ExpandedName(None, 'ROUTE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4234, 26))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_105._Automaton = _BuildAutomaton_116()

CTD_ANON_106._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRONCONS_'), CTD_ANON_107, scope=CTD_ANON_106,
                               documentation="Liste ordonn\xe9e des tron\xe7ons composant l'itin\xe9raire",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4240, 32)))


def _BuildAutomaton_117():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_117
    del _BuildAutomaton_117
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_106._UseForTag(pyxb.namespace.ExpandedName(None, 'TRONCONS_')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4240, 32))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_106._Automaton = _BuildAutomaton_117()

CTD_ANON_107._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRONCON_'), CTD_ANON_108, scope=CTD_ANON_107,
                               documentation="Tron\xe7on de l'itin\xe9raire", location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4246, 38)))


def _BuildAutomaton_118():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_118
    del _BuildAutomaton_118
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_107._UseForTag(pyxb.namespace.ExpandedName(None, 'TRONCON_')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4246, 38))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_107._Automaton = _BuildAutomaton_118()

CTD_ANON_109._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'COORD_REF'), CTD_ANON_110, scope=CTD_ANON_109,
                               documentation="Description d'un r\xe9f\xe9renciel g\xe9ographiqe\n",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4284, 26)))


def _BuildAutomaton_119():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_119
    del _BuildAutomaton_119
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4283, 24))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_109._UseForTag(pyxb.namespace.ExpandedName(None, 'COORD_REF')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4284, 26))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_109._Automaton = _BuildAutomaton_119()

CTD_ANON_110._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'COORD_MAP'), CTD_ANON_111, scope=CTD_ANON_110,
                               documentation="Description d'un point du r\xe9seau dans le rep\xe8re r\xe9f\xe9rence et dans le rep\xe8re du r\xe9seau",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4291, 32)))


def _BuildAutomaton_120():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_120
    del _BuildAutomaton_120
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4291, 32))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_110._UseForTag(pyxb.namespace.ExpandedName(None, 'COORD_MAP')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4291, 32))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_110._Automaton = _BuildAutomaton_120()

CTD_ANON_112._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRAJS'), CTD_ANON_113, scope=CTD_ANON_112,
                               documentation="Liste des v\xe9hicules pr\xe9sents \xe0 l'instant 0\n\t\t\t\t\t\t",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4337, 26)))


def _BuildAutomaton_121():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_121
    del _BuildAutomaton_121
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4336, 24))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_112._UseForTag(pyxb.namespace.ExpandedName(None, 'TRAJS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4337, 26))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_112._Automaton = _BuildAutomaton_121()

CTD_ANON_113._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRAJ'), CTD_ANON_157, scope=CTD_ANON_113,
                               documentation="Description d'un v\xe9hicule pr\xe9sent sur le r\xe9seau \xe0 l'instant 0",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4344, 32)))


def _BuildAutomaton_122():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_122
    del _BuildAutomaton_122
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4344, 32))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_113._UseForTag(pyxb.namespace.ExpandedName(None, 'TRAJ')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4344, 32))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_113._Automaton = _BuildAutomaton_122()

CTD_ANON_114._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SCENARIO'), CTD_ANON_115, scope=CTD_ANON_114,
                               documentation="D\xe9finition d'un sc\xe9nario \xe0 simuler.",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4423, 14)))


def _BuildAutomaton_123():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_123
    del _BuildAutomaton_123
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_114._UseForTag(pyxb.namespace.ExpandedName(None, 'SCENARIO')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4423, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_114._Automaton = _BuildAutomaton_123()

CTD_ANON_116._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRONCON_'), CTD_ANON_117, scope=CTD_ANON_116,
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4869, 12)))


def _BuildAutomaton_124():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_124
    del _BuildAutomaton_124
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_116._UseForTag(pyxb.namespace.ExpandedName(None, 'TRONCON_')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4869, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_116._Automaton = _BuildAutomaton_124()

typeFLUX._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DEMANDES'), CTD_ANON_118, scope=typeFLUX,
                               documentation="Noeud d'acc\xe8s aux variantes temporelles de la demande pour l'extr\xe9mit\xe9 courante",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4895, 6)))

typeFLUX._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'REP_DESTINATIONS'), CTD_ANON_119, scope=typeFLUX,
                               documentation="Noeud d'acc\xe8s aux variantes temporelles de la r\xe9partition vers les destinations pour l'extr\xe9mit\xe9 courante",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4922, 6)))

typeFLUX._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'REP_VOIES'), CTD_ANON_120, scope=typeFLUX,
                               documentation="Noeud d'acc\xe8s aux variantes temporelles de la r\xe9partition par voie du flux provenant de l'extr\xe9mit\xe9 (origine) courante",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4997, 6)))


def _BuildAutomaton_126():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_126
    del _BuildAutomaton_126
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4895, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(typeFLUX._UseForTag(pyxb.namespace.ExpandedName(None, 'DEMANDES')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4895, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_127():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_127
    del _BuildAutomaton_127
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4922, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(typeFLUX._UseForTag(pyxb.namespace.ExpandedName(None, 'REP_DESTINATIONS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4922, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_128():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_128
    del _BuildAutomaton_128
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4997, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(typeFLUX._UseForTag(pyxb.namespace.ExpandedName(None, 'REP_VOIES')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4997, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_125():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_125
    del _BuildAutomaton_125
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4895, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4922, 6))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4997, 6))
    counters.add(cc_2)
    states = []
    sub_automata = []
    sub_automata.append(_BuildAutomaton_126())
    sub_automata.append(_BuildAutomaton_127())
    sub_automata.append(_BuildAutomaton_128())
    final_update = set()
    symbol = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4894, 4)
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=True)
    st_0._set_subAutomata(*sub_automata)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeFLUX._Automaton = _BuildAutomaton_125()

CTD_ANON_118._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DEMANDE'), CTD_ANON_158, scope=CTD_ANON_118,
                               documentation="Description d'une variante temporelle de demande de l'extr\xe9mit\xe9 courante",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4901, 12)))


def _BuildAutomaton_129():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_129
    del _BuildAutomaton_129
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_118._UseForTag(pyxb.namespace.ExpandedName(None, 'DEMANDE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4901, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_118._Automaton = _BuildAutomaton_129()

CTD_ANON_119._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'REP_DESTINATION'), CTD_ANON_159, scope=CTD_ANON_119,
                               documentation='Description de la variante temporelle de la r\xe9partition vers les destinations',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4928, 12)))


def _BuildAutomaton_130():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_130
    del _BuildAutomaton_130
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_119._UseForTag(pyxb.namespace.ExpandedName(None, 'REP_DESTINATION')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4928, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_119._Automaton = _BuildAutomaton_130()

CTD_ANON_120._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'REP_VOIE'), CTD_ANON_161, scope=CTD_ANON_120,
                               documentation="Description d'une variante temporelle de la r\xe9partition par voie du flux provenant de l'extr\xe9mit\xe9 (origine) courante",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 5003, 12)))


def _BuildAutomaton_131():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_131
    del _BuildAutomaton_131
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_120._UseForTag(pyxb.namespace.ExpandedName(None, 'REP_VOIE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 5003, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_120._Automaton = _BuildAutomaton_131()

typeFLUX_GLOBAL._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FLUX'), typeFLUX, scope=typeFLUX_GLOBAL,
                               documentation='Description du flux ', location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 5027, 6)))

typeFLUX_GLOBAL._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'REP_TYPEVEHICULES'), CTD_ANON_121,
                               scope=typeFLUX_GLOBAL,
                               documentation='Description des variantes temporelles de la r\xe9partition du flux par type de v\xe9hicule (cette r\xe9partition est utilis\xe9e pour calculer le type de v\xe9hicule lors de sa cr\xe9ation)',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 5032, 6)))


def _BuildAutomaton_132():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_132
    del _BuildAutomaton_132
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 5032, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(typeFLUX_GLOBAL._UseForTag(pyxb.namespace.ExpandedName(None, 'FLUX')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 5027, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeFLUX_GLOBAL._UseForTag(pyxb.namespace.ExpandedName(None, 'REP_TYPEVEHICULES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 5032, 6))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
    ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True)]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


typeFLUX_GLOBAL._Automaton = _BuildAutomaton_132()

CTD_ANON_121._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'REP_TYPEVEHICULE'), CTD_ANON_176, scope=CTD_ANON_121,
                               documentation="Description d'une variante temporelle de la r\xe9partition du flux par type de v\xe9hicule",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 5038, 12)))


def _BuildAutomaton_133():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_133
    del _BuildAutomaton_133
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_121._UseForTag(pyxb.namespace.ExpandedName(None, 'REP_TYPEVEHICULE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 5038, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_121._Automaton = _BuildAutomaton_133()

CTD_ANON_122._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'COEFFS_TRONCON_AVAL'), CTD_ANON_4, scope=CTD_ANON_122,
                               documentation="Collection des coefficients directionnels des tron\xe7ons aval pour un tron\xe7on et une voie donn\xe9es en amont. Si un tron\xe7on aval du r\xe9partiteur parent ne se trouve pas dans la liste, cela signifie qu'aucun v\xe9hicule ou flux provenant de la voie du tron\xe7on amont consid\xe9r\xe9 ne sort du r\xe9partiteur par ce tron\xe7on aval",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 152, 36)))


def _BuildAutomaton_134():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_134
    del _BuildAutomaton_134
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_122._UseForTag(pyxb.namespace.ExpandedName(None, 'COEFFS_TRONCON_AVAL')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 152, 36))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_122._Automaton = _BuildAutomaton_134()

CTD_ANON_123._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'COUPLES_ENTREE_DESTINATION'), CTD_ANON_5,
                               scope=CTD_ANON_123,
                               documentation="Noeud d'acc\xe8s \xe0 la collection des couples entr\xe9e / destination des donn\xe9es d'affectation",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 222, 12)))


def _BuildAutomaton_135():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_135
    del _BuildAutomaton_135
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_123._UseForTag(pyxb.namespace.ExpandedName(None, 'COUPLES_ENTREE_DESTINATION')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 222, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_123._Automaton = _BuildAutomaton_135()

CTD_ANON_125._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MOUVEMENT_SORTIES'), CTD_ANON_8, scope=CTD_ANON_125,
                               documentation="Description de l'aval du mouvement (si un tron\xe7on aval de la connexion n'est pas pr\xe9sent, les v\xe9hicules entrant par le tron\xe7on et la voie consid\xe9r\xe9s ne peuvent pas sortir par ce tron\xe7on)",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 297, 12)))


def _BuildAutomaton_136():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_136
    del _BuildAutomaton_136
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_125._UseForTag(pyxb.namespace.ExpandedName(None, 'MOUVEMENT_SORTIES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 297, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_125._Automaton = _BuildAutomaton_136()

typeTraficConnexionInterne._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'AFFECTATIONS'), typeAffectation,
                               scope=typeTraficConnexionInterne,
                               documentation="Noeud d'acc\xe8s \xe0 la description de l'affectation pour l'ensemble des v\xe9hicules",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 388, 8)))

typeTraficConnexionInterne._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'AFFECTATIONS_TYPE_VEHICULE'), CTD_ANON_9,
                               scope=typeTraficConnexionInterne,
                               documentation="Noeud d'acc\xe8s \xe0 la description des affectations par type de v\xe9hicule",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 393, 8)))

typeTraficConnexionInterne._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'COEFFS_DIR'), typeCoeffDir,
                               scope=typeTraficConnexionInterne, location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 419, 6)))

typeTraficConnexionInterne._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LISTE_TEMPS_INSERTION'), CTD_ANON_11,
                               scope=typeTraficConnexionInterne,
                               documentation="Liste des temps d'insertion sur la connexion pour tous les types de v\xe9hicule circulant sur le r\xe9seau",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 420, 6)))


def _BuildAutomaton_137():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_137
    del _BuildAutomaton_137
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 388, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 393, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 419, 6))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 420, 6))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficConnexionInterne._UseForTag(pyxb.namespace.ExpandedName(None, 'AFFECTATIONS')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 388, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficConnexionInterne._UseForTag(pyxb.namespace.ExpandedName(None, 'AFFECTATIONS_TYPE_VEHICULE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 393, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficConnexionInterne._UseForTag(pyxb.namespace.ExpandedName(None, 'COEFFS_DIR')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 419, 6))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficConnexionInterne._UseForTag(pyxb.namespace.ExpandedName(None, 'LISTE_TEMPS_INSERTION')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 420, 6))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False)]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False)]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True)]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeTraficConnexionInterne._Automaton = _BuildAutomaton_137()

CTD_ANON_128._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PLAGES_EXTRACTION'), CTD_ANON_12, scope=CTD_ANON_128,
                               documentation="Plages temporelles d'\xe9criture des instants de la simulation. Sans plage d'extraction l'\xe9criture est r\xe9alis\xe9e sur toute la simulation.",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 501, 12)))


def _BuildAutomaton_138():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_138
    del _BuildAutomaton_138
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 500, 10))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 501, 12))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_128._UseForTag(pyxb.namespace.ExpandedName(None, 'PLAGES_EXTRACTION')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 501, 12))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_128._Automaton = _BuildAutomaton_138()

typeParametrageTrafic._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRONCONS'), CTD_ANON_15, scope=typeParametrageTrafic,
                               documentation='Ensemble des tron\xe7ons pour lesquels sont d\xe9finis des param\xe8tres de trafic particuliers',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1059, 6)))

typeParametrageTrafic._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TYPES_DE_VEHICULE'), CTD_ANON_16,
                               scope=typeParametrageTrafic, documentation='Liste des types de v\xe9hicule',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1073, 6)))

typeParametrageTrafic._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'EXTREMITES'), CTD_ANON_17,
                               scope=typeParametrageTrafic,
                               documentation='Liste des extremit\xe9s (entr\xe9es et sorties) du r\xe9seau pour lesquelles des param\xe8tres de trafic sp\xe9cifiques sont d\xe9finis',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1092, 6)))

typeParametrageTrafic._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PARKINGS'), CTD_ANON_18, scope=typeParametrageTrafic,
                               documentation='Liste des parkings du r\xe9seau pour lesquels des param\xe8tres de trafic sp\xe9cifiques sont d\xe9finis',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1107, 6)))

typeParametrageTrafic._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ZONES_DE_TERMINAISON'), CTD_ANON_19,
                               scope=typeParametrageTrafic,
                               documentation='Liste des zones de terminaison du r\xe9seau pour lesquelles des param\xe8tres de trafic sp\xe9cifiques sont d\xe9finis',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1121, 6)))

typeParametrageTrafic._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CONNEXIONS_INTERNES'), CTD_ANON_20,
                               scope=typeParametrageTrafic,
                               documentation='Liste des connexions internes au r\xe9seau pour lesquelles des param\xe8tres de trafic sp\xe9cifiques sont d\xe9finis',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1136, 6)))

typeParametrageTrafic._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PARAMETRAGE_CAPTEURS'), typeParametrageCapteurs,
                               scope=typeParametrageTrafic, documentation='Param\xe9trage des capteurs du r\xe9seau',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1151, 6)))

typeParametrageTrafic._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CONTROLEURS_DE_FEUX'), CTD_ANON_21,
                               scope=typeParametrageTrafic, documentation='Liste des contr\xf4leurs de feux\n',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1156, 6)))

typeParametrageTrafic._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'REGULATIONS'), CTD_ANON_22,
                               scope=typeParametrageTrafic,
                               documentation='Liste des briques de r\xe9gulation de trafic d\xe9finies',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1173, 6)))


def _BuildAutomaton_139():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_139
    del _BuildAutomaton_139
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1058, 4))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1059, 6))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1073, 6))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1092, 6))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1107, 6))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1121, 6))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1136, 6))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1151, 6))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1156, 6))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1173, 6))
    counters.add(cc_9)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(
        typeParametrageTrafic._UseForTag(pyxb.namespace.ExpandedName(None, 'TRONCONS')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1059, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(
        typeParametrageTrafic._UseForTag(pyxb.namespace.ExpandedName(None, 'TYPES_DE_VEHICULE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1073, 6))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(
        typeParametrageTrafic._UseForTag(pyxb.namespace.ExpandedName(None, 'EXTREMITES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1092, 6))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(
        typeParametrageTrafic._UseForTag(pyxb.namespace.ExpandedName(None, 'PARKINGS')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1107, 6))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(
        typeParametrageTrafic._UseForTag(pyxb.namespace.ExpandedName(None, 'ZONES_DE_TERMINAISON')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1121, 6))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(
        typeParametrageTrafic._UseForTag(pyxb.namespace.ExpandedName(None, 'CONNEXIONS_INTERNES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1136, 6))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(
        typeParametrageTrafic._UseForTag(pyxb.namespace.ExpandedName(None, 'PARAMETRAGE_CAPTEURS')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1151, 6))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(
        typeParametrageTrafic._UseForTag(pyxb.namespace.ExpandedName(None, 'CONTROLEURS_DE_FEUX')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1156, 6))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(
        typeParametrageTrafic._UseForTag(pyxb.namespace.ExpandedName(None, 'REGULATIONS')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1173, 6))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, True)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False)]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, True)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False)]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, True)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False)]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_5, True)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False)]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_6, True)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False)]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_7, True)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, False)]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_8, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_8, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_8, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_8, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_8, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_8, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_8, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_8, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_8, True)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_8, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_8, False)]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_9, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_9, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_9, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_9, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_9, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_9, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_9, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_9, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_9, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_9, True)]))
    st_8._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeParametrageTrafic._Automaton = _BuildAutomaton_139()

CTD_ANON_130._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VITESSE_REG_PAR_TYPE'), CTD_ANON_28,
                               scope=CTD_ANON_130,
                               documentation='Description des vitesses r\xe9glementaires du tron\xe7on pour une liste de types de v\xe9hicules donn\xe9e',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1644, 18)))


def _BuildAutomaton_140():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_140
    del _BuildAutomaton_140
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_130._UseForTag(pyxb.namespace.ExpandedName(None, 'VITESSE_REG_PAR_TYPE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1644, 18))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_130._Automaton = _BuildAutomaton_140()

CTD_ANON_134._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TERRE_PLEIN_VARIATION'), CTD_ANON_135,
                               scope=CTD_ANON_134,
                               documentation='Variation temporelle de la pr\xe9sence du terre-plein',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1831, 18)))


def _BuildAutomaton_141():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_141
    del _BuildAutomaton_141
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1831, 18))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_134._UseForTag(pyxb.namespace.ExpandedName(None, 'TERRE_PLEIN_VARIATION')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1831, 18))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_134._Automaton = _BuildAutomaton_141()


def _BuildAutomaton_142():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_142
    del _BuildAutomaton_142
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 375, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeRepartiteur._UseForTag(pyxb.namespace.ExpandedName(None, 'MOUVEMENTS_AUTORISES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 375, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeRepartiteur._Automaton = _BuildAutomaton_142()

typeConvergent._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRONCONS_AMONT'), CTD_ANON_39, scope=typeConvergent,
                               documentation='Liste des tron\xe7ons amont du convergent',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2062, 10)))


def _BuildAutomaton_143():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_143
    del _BuildAutomaton_143
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 375, 6))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(
        typeConvergent._UseForTag(pyxb.namespace.ExpandedName(None, 'MOUVEMENTS_AUTORISES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 375, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        typeConvergent._UseForTag(pyxb.namespace.ExpandedName(None, 'TRONCONS_AMONT')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2062, 10))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


typeConvergent._Automaton = _BuildAutomaton_143()

typeGiratoire._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRONCONS_INTERNES'), CTD_ANON_40, scope=typeGiratoire,
                               documentation="Liste des tron\xe7ons composant l'anneau du giratoire",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2141, 10)))

typeGiratoire._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'COEFFICIENTS_INSERTION'), CTD_ANON_41,
                               scope=typeGiratoire,
                               documentation="Liste des coefficients permettant de d\xe9finir manuellement les taux de choix de la voie d'insertion d'un v\xe9hicule sur le giratoire (utile pour le cas de giratoires \xe0 plusieurs voies) en fonction de la voie d'entr\xe9e et du tron\xe7on de sortie",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2198, 10)))


def _BuildAutomaton_144():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_144
    del _BuildAutomaton_144
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 375, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2141, 10))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2198, 10))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeGiratoire._UseForTag(pyxb.namespace.ExpandedName(None, 'MOUVEMENTS_AUTORISES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 375, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(
        typeGiratoire._UseForTag(pyxb.namespace.ExpandedName(None, 'TRONCONS_INTERNES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2141, 10))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(
        typeGiratoire._UseForTag(pyxb.namespace.ExpandedName(None, 'COEFFICIENTS_INSERTION')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2198, 10))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False)]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True)]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeGiratoire._Automaton = _BuildAutomaton_144()

typeCarrefourAFeux._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ENTREES_CAF'), CTD_ANON_43, scope=typeCarrefourAFeux,
                               documentation='Liste des entr\xe9es et de ses caract\xe9ristiques du carrefour \xe0 feu',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2297, 10)))

typeCarrefourAFeux._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SORTIES_CAF'), CTD_ANON_47, scope=typeCarrefourAFeux,
                               documentation="Liste des sorties du CAF dans le cas o\xf9 les convergents de rattachement au sortie ont besoin d'\xeatre pr\xe9cis\xe9s (sinon tous les mouvements se rattachent a l'extr\xe9mit\xe9 aval de la sortie)",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2480, 10)))


def _BuildAutomaton_145():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_145
    del _BuildAutomaton_145
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 375, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2297, 10))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2480, 10))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeCarrefourAFeux._UseForTag(pyxb.namespace.ExpandedName(None, 'MOUVEMENTS_AUTORISES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 375, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(
        typeCarrefourAFeux._UseForTag(pyxb.namespace.ExpandedName(None, 'ENTREES_CAF')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2297, 10))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(
        typeCarrefourAFeux._UseForTag(pyxb.namespace.ExpandedName(None, 'SORTIES_CAF')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2480, 10))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False)]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True)]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeCarrefourAFeux._Automaton = _BuildAutomaton_145()

CTD_ANON_140._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DIVERGENTS'), CTD_ANON_44, scope=CTD_ANON_140,
                               documentation="Liste des divergents de l'entr\xe9e consid\xe9r\xe9e. Ils sont ordonn\xe9s (du 1er au dernier rencontr\xe9). Si cette liste n'existe pas, l'ensemble des mouvements issus de l'entr\xe9e divergent imm\xe9diatement \xe0 l'extr\xe9mit\xe9 aval du tron\xe7on d'entr\xe9e.",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2309, 22)))

CTD_ANON_140._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MOUVEMENTS'), CTD_ANON_45, scope=CTD_ANON_140,
                               documentation="Liste des mouvements possibles issus de l'entr\xe9e consid\xe9r\xe9",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2348, 22)))


def _BuildAutomaton_146():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_146
    del _BuildAutomaton_146
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2309, 22))
    counters.add(cc_0)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_140._UseForTag(pyxb.namespace.ExpandedName(None, 'DIVERGENTS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2309, 22))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_140._UseForTag(pyxb.namespace.ExpandedName(None, 'MOUVEMENTS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2348, 22))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_140._Automaton = _BuildAutomaton_146()

CTD_ANON_141._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'POINTS_INTERNES'), typePointsInternes,
                               scope=CTD_ANON_141,
                               documentation="Liste des points internes du mouvement situ\xe9s entre le divergent et le convergent de rattachement \xe0 la sortie (si aucun point n'est d\xe9fini, il se situe \xe0 l'extr\xe9mit\xe9 aval du tron\xe7on d'entr\xe9e du mouvement)",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2360, 34)))

CTD_ANON_141._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'POINTS_D_ATTENTE'), CTD_ANON_46, scope=CTD_ANON_141,
                               documentation="Liste des points d'attente des travers\xe9es du mouvement",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2366, 34)))


def _BuildAutomaton_147():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_147
    del _BuildAutomaton_147
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2360, 34))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2366, 34))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_141._UseForTag(pyxb.namespace.ExpandedName(None, 'POINTS_INTERNES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2360, 34))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_141._UseForTag(pyxb.namespace.ExpandedName(None, 'POINTS_D_ATTENTE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2366, 34))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True)]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_141._Automaton = _BuildAutomaton_147()

CTD_ANON_143._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CONVERGENTS'), CTD_ANON_48, scope=CTD_ANON_143,
                               documentation="Liste des convergents de la sortie. Ils sont ordonn\xe9s \xe0 partir de la fin (du dernier au 1er rencontr\xe9). Si cette liste n'existe pas, l'ensemble des mouvements arrivant sur cette sortie convergent  imm\xe9diatement \xe0 l'extr\xe9mit\xe9 amont du tron\xe7on de sortie.",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2492, 22)))


def _BuildAutomaton_148():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_148
    del _BuildAutomaton_148
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_143._UseForTag(pyxb.namespace.ExpandedName(None, 'CONVERGENTS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2492, 22))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_143._Automaton = _BuildAutomaton_148()

typeParametrageCapteurs._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CAPTEURS'), CTD_ANON_57,
                               scope=typeParametrageCapteurs, documentation='Liste des capteurs du r\xe9seau',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2854, 6)))


def _BuildAutomaton_149():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_149
    del _BuildAutomaton_149
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        typeParametrageCapteurs._UseForTag(pyxb.namespace.ExpandedName(None, 'CAPTEURS')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2854, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


typeParametrageCapteurs._Automaton = _BuildAutomaton_149()

typeControleurDeFeux._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PLANS_DE_FEUX'), CTD_ANON_58,
                               scope=typeControleurDeFeux,
                               documentation="Noeud d'acc\xe8s \xe0 la liste des plans de feux",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2930, 6)))

typeControleurDeFeux._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'LIGNES_GUIDEES_PRIORITAIRES'), CTD_ANON_61,
                               scope=typeControleurDeFeux,
                               documentation="Noeud d'acc\xe8s \xe0 la liste des lignes guid\xe9es prioritaires g\xe9r\xe9es par le contr\xf4leur de feux parent\n",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3055, 6)))

typeControleurDeFeux._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'POSITION_FEUX'), CTD_ANON_62,
                               scope=typeControleurDeFeux,
                               documentation="Noeud sp\xe9cifique \xe0 l'outils de visualisation Symuplayer permettant de param\xe9trer la position des feux du contr\xf4leur",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3130, 6)))


def _BuildAutomaton_150():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_150
    del _BuildAutomaton_150
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2930, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3055, 6))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3130, 6))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeControleurDeFeux._UseForTag(pyxb.namespace.ExpandedName(None, 'PLANS_DE_FEUX')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2930, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(
        typeControleurDeFeux._UseForTag(pyxb.namespace.ExpandedName(None, 'LIGNES_GUIDEES_PRIORITAIRES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3055, 6))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(
        typeControleurDeFeux._UseForTag(pyxb.namespace.ExpandedName(None, 'POSITION_FEUX')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3130, 6))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False)]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True)]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeControleurDeFeux._Automaton = _BuildAutomaton_150()

CTD_ANON_146._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SEQUENCES'), CTD_ANON_59, scope=CTD_ANON_146,
                               documentation="Noeud d'acc\xe8s \xe0 la liste des s\xe9quences du plan de feux",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2942, 18)))


def _BuildAutomaton_151():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_151
    del _BuildAutomaton_151
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2942, 18))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_146._UseForTag(pyxb.namespace.ExpandedName(None, 'SEQUENCES')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2942, 18))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_146._Automaton = _BuildAutomaton_151()

CTD_ANON_147._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SIGNAUX_ACTIFS'), CTD_ANON_60, scope=CTD_ANON_147,
                               documentation="Noeud d'acc\xe8s \xe0 la liste de description des signaux actifs de la s\xe9quence\n",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2955, 30)))


def _BuildAutomaton_152():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_152
    del _BuildAutomaton_152
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_147._UseForTag(pyxb.namespace.ExpandedName(None, 'SIGNAUX_ACTIFS')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2955, 30))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_147._Automaton = _BuildAutomaton_152()

typeTraficOrigine._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FLUX_GLOBAL'), typeFLUX_GLOBAL,
                               scope=typeTraficOrigine,
                               documentation="Noeud d'acc\xe8s \xe0 la description d'un flux global ayant pour origine l'extr\xe9mit\xe9 courante (pour tous les types de v\xe9hicule)",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3349, 6)))

typeTraficOrigine._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FLUX_TYPEVEHS'), CTD_ANON_65, scope=typeTraficOrigine,
                               documentation="Noeud d'acc\xe8s \xe0 la collection des flux par type de v\xe9hicule pour l'extr\xe9mit\xe9 courante",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3354, 6)))

typeTraficOrigine._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'AGRESSIVITES'), CTD_ANON_67, scope=typeTraficOrigine,
                               documentation="Description du caract\xe8re agressif des v\xe9hicules issus de l'entr\xe9e",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3379, 6)))


def _BuildAutomaton_153():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_153
    del _BuildAutomaton_153
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3349, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3354, 6))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3379, 6))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficOrigine._UseForTag(pyxb.namespace.ExpandedName(None, 'FLUX_GLOBAL')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3349, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficOrigine._UseForTag(pyxb.namespace.ExpandedName(None, 'FLUX_TYPEVEHS')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3354, 6))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficOrigine._UseForTag(pyxb.namespace.ExpandedName(None, 'AGRESSIVITES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3379, 6))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False)]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True)]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeTraficOrigine._Automaton = _BuildAutomaton_153()

typeParkingParameters._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TYPE_VEHICULE_INTERDIT'), CTD_ANON_70,
                               scope=typeParkingParameters,
                               documentation='Permet la d\xe9finition de types de v\xe9hicules interdits dans le parking',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3518, 6)))


def _BuildAutomaton_154():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_154
    del _BuildAutomaton_154
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3518, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeParkingParameters._UseForTag(pyxb.namespace.ExpandedName(None, 'TYPE_VEHICULE_INTERDIT')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3518, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeParkingParameters._Automaton = _BuildAutomaton_154()

CTD_ANON_153._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DESTINATION'), CTD_ANON_154, scope=CTD_ANON_153,
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3639, 22)))


def _BuildAutomaton_155():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_155
    del _BuildAutomaton_155
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_153._UseForTag(pyxb.namespace.ExpandedName(None, 'DESTINATION')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3639, 22))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_153._Automaton = _BuildAutomaton_155()

typeRegulation._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DETECTEURS'), CTD_ANON_79, scope=typeRegulation,
                               documentation='Ensemble des d\xe9tecteurs associ\xe9s \xe0 la brique de r\xe9gulation',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3806, 6)))

typeRegulation._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DECLENCHEURS'), CTD_ANON_81, scope=typeRegulation,
                               documentation='Ensemble des d\xe9clencheurs associ\xe9s \xe0 la brique de r\xe9gulation',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3844, 6)))

typeRegulation._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ACTIONS'), CTD_ANON_83, scope=typeRegulation,
                               documentation='Ensemble des actions associ\xe9es \xe0 la brique de r\xe9gulation',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3882, 6)))

typeRegulation._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RESTITUTIONS'), CTD_ANON_85, scope=typeRegulation,
                               documentation='Ensemble des d\xe9finitions de restitution dans le fichier de sortie pour la brique de r\xe9gulation',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3920, 6)))


def _BuildAutomaton_156():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_156
    del _BuildAutomaton_156
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3806, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3920, 6))
    counters.add(cc_1)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(typeRegulation._UseForTag(pyxb.namespace.ExpandedName(None, 'DETECTEURS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3806, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(
        typeRegulation._UseForTag(pyxb.namespace.ExpandedName(None, 'DECLENCHEURS')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3844, 6))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(typeRegulation._UseForTag(pyxb.namespace.ExpandedName(None, 'ACTIONS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3882, 6))
    st_2 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(
        typeRegulation._UseForTag(pyxb.namespace.ExpandedName(None, 'RESTITUTIONS')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3920, 6))
    st_3 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
    ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
    ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True)]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


typeRegulation._Automaton = _BuildAutomaton_156()

CTD_ANON_156._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PLAGE_TEMPORELLE'), CTD_ANON_88, scope=CTD_ANON_156,
                               documentation='Plage temporelle pouvant \xeatre utilis\xe9e en mode "horaire" pour renseigner la plage de validit\xe9 des variantes temporelles (attributs "duree" de certains \xe9l\xe9ments)',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3977, 14)))


def _BuildAutomaton_157():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_157
    del _BuildAutomaton_157
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3977, 14))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_156._UseForTag(pyxb.namespace.ExpandedName(None, 'PLAGE_TEMPORELLE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3977, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_156._Automaton = _BuildAutomaton_157()

typeITINERAIRE._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRONCONS_'), CTD_ANON_116, scope=typeITINERAIRE,
                               documentation="Liste des tron\xe7ons constituant l'itin\xe9raire",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4863, 6)))


def _BuildAutomaton_158():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_158
    del _BuildAutomaton_158
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4863, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(typeITINERAIRE._UseForTag(pyxb.namespace.ExpandedName(None, 'TRONCONS_')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4863, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeITINERAIRE._Automaton = _BuildAutomaton_158()

CTD_ANON_159._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'DESTINATION'), CTD_ANON_160, scope=CTD_ANON_159,
                               documentation="Description d'une destination de l'extr\xe9mit\xe9 courante\n",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4934, 18)))


def _BuildAutomaton_159():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_159
    del _BuildAutomaton_159
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_159._UseForTag(pyxb.namespace.ExpandedName(None, 'DESTINATION')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4934, 18))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
    ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_159._Automaton = _BuildAutomaton_159()

CTD_ANON_160._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ROUTE'), typeITINERAIRE, scope=CTD_ANON_160,
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4944, 24)))


def _BuildAutomaton_160():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_160
    del _BuildAutomaton_160
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 4944, 24))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_160._UseForTag(pyxb.namespace.ExpandedName(None, 'ROUTE')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 4944, 24))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_160._Automaton = _BuildAutomaton_160()

typeParametrageSimulation._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'RESTITUTION'), CTD_ANON_128,
                               scope=typeParametrageSimulation,
                               documentation="Noeud regroupant l'ensemble des options de modulation du contenu des fichiers de sortie",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 495, 6)))

typeParametrageSimulation._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ELEMENTS'), CTD_ANON_14,
                               scope=typeParametrageSimulation,
                               documentation='Ensemble des \xe9l\xe9ments du r\xe9seau pour lesquels sont d\xe9finis des param\xe8tres de simulation sp\xe9cifiques',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 607, 6)))


def _BuildAutomaton_161():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_161
    del _BuildAutomaton_161
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 495, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 607, 6))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeParametrageSimulation._UseForTag(pyxb.namespace.ExpandedName(None, 'RESTITUTION')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 495, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(
        typeParametrageSimulation._UseForTag(pyxb.namespace.ExpandedName(None, 'ELEMENTS')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 607, 6))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True)]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeParametrageSimulation._Automaton = _BuildAutomaton_161()

typeTypeDeVehicule._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ACCELERATION_PLAGES'), CTD_ANON_23,
                               scope=typeTypeDeVehicule,
                               documentation='Liste ordonn\xe9e des plages de l\'acc\xe9l\xe9ration en fonction de la vitesse dans le cas d\'une acc\xe9l\xe9ration non constante (ce noeud n\'est pas lu dans le cas o\xf9 la simulation a pour caract\xe9ristique "acc\xe9l\xe9ration non born\xe9e")',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1360, 6)))

typeTypeDeVehicule._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'SOURCES_ACOUSTIQUES'), CTD_ANON_24,
                               scope=typeTypeDeVehicule, documentation='Liste des sources acoustiques du v\xe9hicule',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1386, 6)))


def _BuildAutomaton_163():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_163
    del _BuildAutomaton_163
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1360, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTypeDeVehicule._UseForTag(pyxb.namespace.ExpandedName(None, 'ACCELERATION_PLAGES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1360, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_164():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_164
    del _BuildAutomaton_164
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1386, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTypeDeVehicule._UseForTag(pyxb.namespace.ExpandedName(None, 'SOURCES_ACOUSTIQUES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1386, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_162():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_162
    del _BuildAutomaton_162
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1360, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1386, 6))
    counters.add(cc_1)
    states = []
    sub_automata = []
    sub_automata.append(_BuildAutomaton_163())
    sub_automata.append(_BuildAutomaton_164())
    final_update = set()
    symbol = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1359, 4)
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=True)
    st_0._set_subAutomata(*sub_automata)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeTypeDeVehicule._Automaton = _BuildAutomaton_162()

typeTroncon._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VOIES_REDUITES'), CTD_ANON_26, scope=typeTroncon,
                               documentation='Liste des voies r\xe9duites pour les tron\xe7ons microscopiques(Symubruit force le changement de voie avant la fin du tron\xe7on pour de telles voies)',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1601, 6)))

typeTroncon._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VITESSES_REG'), CTD_ANON_27, scope=typeTroncon,
                               documentation="Liste des vitesses r\xe9glementaires sp\xe9cifiques \xe0 un type de v\xe9hicule (\xe0 d\xe9finir uniquement dans le cas d'un tron\xe7on microscopique et lorsque la vitesse r\xe9glementaire n'est pas commune \xe0 tous les types de v\xe9hicules)",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1632, 6)))

typeTroncon._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'POINTS_INTERNES'), typePointsInternes,
                               scope=typeTroncon,
                               documentation="\n            Description de la liste des points internes d\xe9crivant le tron\xe7on (ils doivent \xeatre d\xe9finis de l'amont vers l'aval)\n          ",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1699, 6)))

typeTroncon._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRAVERSEES'), CTD_ANON_29, scope=typeTroncon,
                               documentation='Liste des travers\xe9es prioritaires pour les tron\xe7ons microscopiques',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1706, 6)))

typeTroncon._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VOIES_RESERVEES'), CTD_ANON_32, scope=typeTroncon,
                               documentation='D\xe9finition des voies r\xe9serv\xe9es sur ce tron\xe7on',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1755, 6)))

typeTroncon._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'VOIES_INTERDITES'), CTD_ANON_33, scope=typeTroncon,
                               documentation='D\xe9finition des voies interdites sur le tron\xe7on',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1796, 6)))

typeTroncon._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TERRE_PLEINS'), CTD_ANON_35, scope=typeTroncon,
                               documentation='Ensemble des terre-pleins pr\xe9sents sur le tron\xe7on',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1819, 6)))

typeTroncon._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ZONES_DEPASSEMENT_INTERDIT'), CTD_ANON_36,
                               scope=typeTroncon,
                               documentation='Ensemble des zones dans lesquelles le d\xe9passement par passage sur la voie de gauche du tron\xe7on oppos\xe9 est interdit ',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1869, 6)))

typeTroncon._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ZONES_EXCLUSION'), CTD_ANON_37, scope=typeTroncon,
                               documentation='Ensemble des zones dans lesquelles le trafic ne doit pas \xeatre pris en compte. A exploiter au niveau des outils de post-traitement.',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1895, 6)))

typeTroncon._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'Z_LEVEL_CROSSINGS'), CTD_ANON_38, scope=typeTroncon,
                               documentation='D\xe9finition des portions du tron\xe7on pour lesquellse on d\xe9finit un zLevel particulier',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1921, 6)))


def _BuildAutomaton_166():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_166
    del _BuildAutomaton_166
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1601, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTroncon._UseForTag(pyxb.namespace.ExpandedName(None, 'VOIES_REDUITES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1601, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_167():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_167
    del _BuildAutomaton_167
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1632, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(typeTroncon._UseForTag(pyxb.namespace.ExpandedName(None, 'VITESSES_REG')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 1632, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_168():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_168
    del _BuildAutomaton_168
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1699, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTroncon._UseForTag(pyxb.namespace.ExpandedName(None, 'POINTS_INTERNES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1699, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_169():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_169
    del _BuildAutomaton_169
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1706, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(typeTroncon._UseForTag(pyxb.namespace.ExpandedName(None, 'TRAVERSEES')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 1706, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_170():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_170
    del _BuildAutomaton_170
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1755, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTroncon._UseForTag(pyxb.namespace.ExpandedName(None, 'VOIES_RESERVEES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1755, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_171():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_171
    del _BuildAutomaton_171
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1796, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTroncon._UseForTag(pyxb.namespace.ExpandedName(None, 'VOIES_INTERDITES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1796, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_172():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_172
    del _BuildAutomaton_172
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1819, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(typeTroncon._UseForTag(pyxb.namespace.ExpandedName(None, 'TERRE_PLEINS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 1819, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_173():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_173
    del _BuildAutomaton_173
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1869, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTroncon._UseForTag(pyxb.namespace.ExpandedName(None, 'ZONES_DEPASSEMENT_INTERDIT')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1869, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_174():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_174
    del _BuildAutomaton_174
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1895, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTroncon._UseForTag(pyxb.namespace.ExpandedName(None, 'ZONES_EXCLUSION')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1895, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_175():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_175
    del _BuildAutomaton_175
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1921, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTroncon._UseForTag(pyxb.namespace.ExpandedName(None, 'Z_LEVEL_CROSSINGS')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1921, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_165():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_165
    del _BuildAutomaton_165
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1601, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1632, 6))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1699, 6))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1706, 6))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1755, 6))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1796, 6))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1819, 6))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1869, 6))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1895, 6))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1921, 6))
    counters.add(cc_9)
    states = []
    sub_automata = []
    sub_automata.append(_BuildAutomaton_166())
    sub_automata.append(_BuildAutomaton_167())
    sub_automata.append(_BuildAutomaton_168())
    sub_automata.append(_BuildAutomaton_169())
    sub_automata.append(_BuildAutomaton_170())
    sub_automata.append(_BuildAutomaton_171())
    sub_automata.append(_BuildAutomaton_172())
    sub_automata.append(_BuildAutomaton_173())
    sub_automata.append(_BuildAutomaton_174())
    sub_automata.append(_BuildAutomaton_175())
    final_update = set()
    symbol = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1600, 4)
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=True)
    st_0._set_subAutomata(*sub_automata)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeTroncon._Automaton = _BuildAutomaton_165()

CTD_ANON_164._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'POINTS_INTERNES'), typePointsInternes,
                               scope=CTD_ANON_164,
                               documentation='\n\t\t\t\t\t\t\tListe des points internes du tron\xe7on\n\t\t\t\t\t\t',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2153, 22)))


def _BuildAutomaton_176():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_176
    del _BuildAutomaton_176
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2153, 22))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_164._UseForTag(pyxb.namespace.ExpandedName(None, 'POINTS_INTERNES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2153, 22))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_164._Automaton = _BuildAutomaton_176()

CTD_ANON_165._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'POINTS_INTERNES'), typePointsInternes,
                               scope=CTD_ANON_165,
                               documentation="Liste des points internes se situant entre le pr\xe9c\xe9dent divergent d\xe9fini et celui-ci (si c'est le premier divergent d\xe9fini, c'est entre l'extr\xe9mit\xe9 aval du tron\xe7on d'entr\xe9e et celui-ci)",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2321, 34)))


def _BuildAutomaton_177():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_177
    del _BuildAutomaton_177
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2321, 34))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_165._UseForTag(pyxb.namespace.ExpandedName(None, 'POINTS_INTERNES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2321, 34))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_165._Automaton = _BuildAutomaton_177()

CTD_ANON_166._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'POINTS_INTERNES'), typePointsInternes,
                               scope=CTD_ANON_166,
                               documentation="Liste des points internes se situant entre le pr\xe9c\xe9dent convergent d\xe9fini et celui-ci (si c'est le premier convergent d\xe9fini, c'est entre l'extr\xe9mit\xe9 amont du tron\xe7on de sortie et celui-ci)",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2504, 34)))


def _BuildAutomaton_178():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_178
    del _BuildAutomaton_178
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2504, 34))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_166._UseForTag(pyxb.namespace.ExpandedName(None, 'POINTS_INTERNES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2504, 34))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_166._Automaton = _BuildAutomaton_178()

CTD_ANON_167._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PARAMETRAGE_MONTEE'), CTD_ANON_53, scope=CTD_ANON_167,
                               documentation="Liste des variantes temporelles de d\xe9finition du profil des demandes pour l'arr\xeat",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2715, 18)))

CTD_ANON_167._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PARAMETRAGE_DESCENTE'), CTD_ANON_55,
                               scope=CTD_ANON_167,
                               documentation="D\xe9finition des param\xe8tres de descente des bus pour l'arr\xeat consid\xe9r\xe9",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2762, 18)))


def _BuildAutomaton_179():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_179
    del _BuildAutomaton_179
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2715, 18))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2762, 18))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_167._UseForTag(pyxb.namespace.ExpandedName(None, 'PARAMETRAGE_MONTEE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2715, 18))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_167._UseForTag(pyxb.namespace.ExpandedName(None, 'PARAMETRAGE_DESCENTE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2762, 18))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True)]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_167._Automaton = _BuildAutomaton_179()

typeTraficOriginePonctuelle._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CREATION_VEHICULES'), CTD_ANON_68,
                               scope=typeTraficOriginePonctuelle, documentation='Liste des v\xe9hicules \xe0 cr\xe9er',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3442, 10)))


def _BuildAutomaton_180():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_180
    del _BuildAutomaton_180
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3349, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3354, 6))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3379, 6))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3441, 8))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3442, 10))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficOriginePonctuelle._UseForTag(pyxb.namespace.ExpandedName(None, 'FLUX_GLOBAL')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3349, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficOriginePonctuelle._UseForTag(pyxb.namespace.ExpandedName(None, 'FLUX_TYPEVEHS')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3354, 6))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficOriginePonctuelle._UseForTag(pyxb.namespace.ExpandedName(None, 'AGRESSIVITES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3379, 6))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficOriginePonctuelle._UseForTag(pyxb.namespace.ExpandedName(None, 'CREATION_VEHICULES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3442, 10))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False)]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False)]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, True)]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeTraficOriginePonctuelle._Automaton = _BuildAutomaton_180()


def _BuildAutomaton_181():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_181
    del _BuildAutomaton_181
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3518, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeParkingZone._UseForTag(pyxb.namespace.ExpandedName(None, 'TYPE_VEHICULE_INTERDIT')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3518, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeParkingZone._Automaton = _BuildAutomaton_181()

typeTraficZone._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'TRONCONS'), CTD_ANON_71, scope=typeTraficZone,
                               documentation='Liste des tron\xe7ons d\xe9finissant la zone',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3576, 10)))

typeTraficZone._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'GROUPE_PARKING'), CTD_ANON_73, scope=typeTraficZone,
                               documentation='Liste des parkings compris dans la zone',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3608, 10)))

typeTraficZone._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'MATRICES_OD_INTERNES'), CTD_ANON_74,
                               scope=typeTraficZone,
                               documentation='Liste des variantes temporelles de la matrice OD interne \xe0 la zone de terminaison',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3627, 10)))

typeTraficZone._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CREATION_VEHICULES'), CTD_ANON_75,
                               scope=typeTraficZone, documentation='Liste des v\xe9hicules \xe0 cr\xe9er',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3664, 10)))

typeTraficZone._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'REPARTITIONS_TYPEVEHICULE'), CTD_ANON_77,
                               scope=typeTraficZone,
                               documentation='Liste des variantes des r\xe9partitions des types de v\xe9hicule',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3695, 10)))

typeTraficZone._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'REPARTITION_ORIGINES'), CTD_ANON_78,
                               scope=typeTraficZone,
                               documentation="Liste des coefficients de r\xe9partition de la demande sur les diff\xe9rents \xe9l\xe9ments de la zone d'origine (groupes de parkings et tron\xe7ons avec stationnement)",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3721, 10)))


def _BuildAutomaton_182():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_182
    del _BuildAutomaton_182
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3349, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3354, 6))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3379, 6))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3608, 10))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3627, 10))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3664, 10))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3695, 10))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3721, 10))
    counters.add(cc_7)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(
        typeTraficZone._UseForTag(pyxb.namespace.ExpandedName(None, 'FLUX_GLOBAL')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3349, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(
        typeTraficZone._UseForTag(pyxb.namespace.ExpandedName(None, 'FLUX_TYPEVEHS')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3354, 6))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(
        typeTraficZone._UseForTag(pyxb.namespace.ExpandedName(None, 'AGRESSIVITES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3379, 6))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(typeTraficZone._UseForTag(pyxb.namespace.ExpandedName(None, 'TRONCONS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 3576, 10))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficZone._UseForTag(pyxb.namespace.ExpandedName(None, 'GROUPE_PARKING')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3608, 10))
    st_4 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficZone._UseForTag(pyxb.namespace.ExpandedName(None, 'MATRICES_OD_INTERNES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3627, 10))
    st_5 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficZone._UseForTag(pyxb.namespace.ExpandedName(None, 'CREATION_VEHICULES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3664, 10))
    st_6 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficZone._UseForTag(pyxb.namespace.ExpandedName(None, 'REPARTITIONS_TYPEVEHICULE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3695, 10))
    st_7 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficZone._UseForTag(pyxb.namespace.ExpandedName(None, 'REPARTITION_ORIGINES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3721, 10))
    st_8 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False)]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False)]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
    ]))
    transitions.append(fac.Transition(st_5, [
    ]))
    transitions.append(fac.Transition(st_6, [
    ]))
    transitions.append(fac.Transition(st_7, [
    ]))
    transitions.append(fac.Transition(st_8, [
    ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False)]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False)]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, True)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False)]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, True)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False)]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, True)]))
    st_8._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


typeTraficZone._Automaton = _BuildAutomaton_182()


def _BuildAutomaton_183():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_183
    del _BuildAutomaton_183
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1058, 4))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1059, 6))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1073, 6))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1092, 6))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1107, 6))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1121, 6))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1136, 6))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1151, 6))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1156, 6))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1173, 6))
    counters.add(cc_9)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_170._UseForTag(pyxb.namespace.ExpandedName(None, 'TRONCONS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 1059, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_170._UseForTag(pyxb.namespace.ExpandedName(None, 'TYPES_DE_VEHICULE')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1073, 6))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_170._UseForTag(pyxb.namespace.ExpandedName(None, 'EXTREMITES')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 1092, 6))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_170._UseForTag(pyxb.namespace.ExpandedName(None, 'PARKINGS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 1107, 6))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_170._UseForTag(pyxb.namespace.ExpandedName(None, 'ZONES_DE_TERMINAISON')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1121, 6))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_170._UseForTag(pyxb.namespace.ExpandedName(None, 'CONNEXIONS_INTERNES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1136, 6))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_170._UseForTag(pyxb.namespace.ExpandedName(None, 'PARAMETRAGE_CAPTEURS')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1151, 6))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_170._UseForTag(pyxb.namespace.ExpandedName(None, 'CONTROLEURS_DE_FEUX')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1156, 6))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_170._UseForTag(pyxb.namespace.ExpandedName(None, 'REGULATIONS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 1173, 6))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, True)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False)]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, True)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_3, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False)]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, True)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False)]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_5, True)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_5, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False)]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_6, True)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False)]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_7, True)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_7, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, False)]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_8, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_8, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_8, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_8, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_8, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_8, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_8, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_8, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_8, True)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_8, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_8, False)]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_9, False)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_9, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_9, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_9, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_9, False)]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_9, False)]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_9, False)]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_9, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, True),
        fac.UpdateInstruction(cc_9, False)]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_9, True)]))
    st_8._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_170._Automaton = _BuildAutomaton_183()


def _BuildAutomaton_185():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_185
    del _BuildAutomaton_185
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1360, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_172._UseForTag(pyxb.namespace.ExpandedName(None, 'ACCELERATION_PLAGES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1360, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_186():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_186
    del _BuildAutomaton_186
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1386, 6))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        CTD_ANON_172._UseForTag(pyxb.namespace.ExpandedName(None, 'SOURCES_ACOUSTIQUES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1386, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=st_0)


def _BuildAutomaton_184():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_184
    del _BuildAutomaton_184
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1360, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1386, 6))
    counters.add(cc_1)
    states = []
    sub_automata = []
    sub_automata.append(_BuildAutomaton_185())
    sub_automata.append(_BuildAutomaton_186())
    final_update = set()
    symbol = pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 1359, 4)
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=True)
    st_0._set_subAutomata(*sub_automata)
    states.append(st_0)
    transitions = []
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_172._Automaton = _BuildAutomaton_184()

typeTraficExtremite._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'CAPACITES'), CTD_ANON_69, scope=typeTraficExtremite,
                               documentation="Liste des variantes de la capacit\xe9 de la sortie. Si cette liste n'existe pas, la sortie est libre.",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3486, 10)))


def _BuildAutomaton_187():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_187
    del _BuildAutomaton_187
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3349, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3354, 6))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3379, 6))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3441, 8))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3442, 10))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3485, 8))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3486, 10))
    counters.add(cc_6)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficExtremite._UseForTag(pyxb.namespace.ExpandedName(None, 'FLUX_GLOBAL')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3349, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficExtremite._UseForTag(pyxb.namespace.ExpandedName(None, 'FLUX_TYPEVEHS')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3354, 6))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficExtremite._UseForTag(pyxb.namespace.ExpandedName(None, 'AGRESSIVITES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3379, 6))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficExtremite._UseForTag(pyxb.namespace.ExpandedName(None, 'CREATION_VEHICULES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3442, 10))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(
        typeTraficExtremite._UseForTag(pyxb.namespace.ExpandedName(None, 'CAPACITES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3486, 10))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False)]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False)]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, True)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False),
        fac.UpdateInstruction(cc_4, False)]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_5, True),
        fac.UpdateInstruction(cc_6, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_6, True)]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


typeTraficExtremite._Automaton = _BuildAutomaton_187()

typeTraficParking._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'PARAMETRES'), typeParkingParameters,
                               scope=typeTraficParking, location=pyxb.utils.utility.Location(
            '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3556, 10)))


def _BuildAutomaton_188():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_188
    del _BuildAutomaton_188
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3349, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3354, 6))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3379, 6))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3441, 8))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3442, 10))
    counters.add(cc_4)
    states = []
    final_update = None
    symbol = pyxb.binding.content.ElementUse(
        typeTraficParking._UseForTag(pyxb.namespace.ExpandedName(None, 'FLUX_GLOBAL')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3349, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(
        typeTraficParking._UseForTag(pyxb.namespace.ExpandedName(None, 'FLUX_TYPEVEHS')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3354, 6))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(
        typeTraficParking._UseForTag(pyxb.namespace.ExpandedName(None, 'AGRESSIVITES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3379, 6))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = None
    symbol = pyxb.binding.content.ElementUse(
        typeTraficParking._UseForTag(pyxb.namespace.ExpandedName(None, 'CREATION_VEHICULES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3442, 10))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(
        typeTraficParking._UseForTag(pyxb.namespace.ExpandedName(None, 'PARAMETRES')),
        pyxb.utils.utility.Location('/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 3556, 10))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True)]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False)]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False)]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True),
        fac.UpdateInstruction(cc_4, False)]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, True)]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False),
        fac.UpdateInstruction(cc_4, False)]))
    st_3._set_transitionSet(transitions)
    transitions = []
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


typeTraficParking._Automaton = _BuildAutomaton_188()


def _BuildAutomaton_189():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_189
    del _BuildAutomaton_189
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 495, 6))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 607, 6))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_175._UseForTag(pyxb.namespace.ExpandedName(None, 'RESTITUTION')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 495, 6))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_175._UseForTag(pyxb.namespace.ExpandedName(None, 'ELEMENTS')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 607, 6))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True)]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False)]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True)]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)


CTD_ANON_175._Automaton = _BuildAutomaton_189()

CTD_ANON_177._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'HORAIRES'), CTD_ANON_50, scope=CTD_ANON_177,
                               documentation="Liste des horaires des v\xe9hicules guid\xe9s (uniquement le premier v\xe9hicule guid\xe9 dans le cas d'un param\xe9trage de type global)",
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2581, 18)))

CTD_ANON_177._AddElement(
    pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'FREQUENCES'), CTD_ANON_51, scope=CTD_ANON_177,
                               documentation='D\xe9finition des variations temporelles de fr\xe9quence des v\xe9hicules guid\xe9s sur la ligne, en cas de param\xe8trage de type \'Global\'. L\'attribut "fr\xe9quence" du NOEUD "LIGNE_TRANSPORT_GUIDEE" sera ignor\xe9 si des variations temporelles sotn d\xe9finies ici.',
                               location=pyxb.utils.utility.Location(
                                   '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2614, 18)))


def _BuildAutomaton_190():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_190
    del _BuildAutomaton_190
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location(
        '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd', 2614, 18))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_177._UseForTag(pyxb.namespace.ExpandedName(None, 'HORAIRES')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2581, 18))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_177._UseForTag(pyxb.namespace.ExpandedName(None, 'FREQUENCES')),
                                             pyxb.utils.utility.Location(
                                                 '/home/latty/__DEV__/__PYTHON__/__TESTS__/PyXB_on_Symuvia/reseau.xsd',
                                                 2614, 18))
    st_1 = fac.State(symbol, is_initial=False, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_1, [
    ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True)]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)


CTD_ANON_177._Automaton = _BuildAutomaton_190()

